#!/bin/sh
# sweet-clisp [clisp-options] [FILE-TO-RUN.slisp [args]]

# By David A. Wheeler. Start up clisp in "sweet-expression" reading mode,
# so you can try it out.  A useful "clisp-option" is "-modern".
# This sets *print-escape*; this isn't ideal, but
# in most circumstances it works well, and clisp has no better way
# of disabling its unnecessary escapes which otherwise look ugly.

# If you want to use un-installed sweet-expression implementation, you
# need to set CL_SOURCE_REGISTRY to point to it.  E.G.:
#    CL_SOURCE_REGISTRY="$PWD" ./sweet-clisp ...

clisp_options=""
origfile=""
# Use clisp standard repl:
crepl=0

setup_commands='
(require "asdf")
(asdf:load-system :readable)
(setq *print-escape* nil)
(readable:enable-sweet)
'

# Process command line arguments
while [ $# -gt 0 ]
do
  case "$1" in
    (-)            # File is standard input.
      break 2 ;;
    (--)
      shift
      break 2 ;;
    (-CREPL) # Special added "-CREPL" option
      crepl=1
      shift ;;
    (-B|-K|-M|-m|-L|-N|-p|-lp|-i|-c|-o|-x)
      # Options with parameters.
      clisp_options="$clisp_options $1 $2"
      shift ; shift ;;
    (-*)
      # Options without parameters, e.g., "-modern".
      clisp_options="$clisp_options $1"
      shift ;;
    (*)
      break 2 ;;
  esac
done
if [ $# -gt 0 ] ; then
  origfile="$1"
  shift
fi

# If it weren't for a bug in the clisp REPL, we could just do this:
#   clisp $clisp_options -x "$setup_commands" -repl
# But if two t-expressions are not separated by a newline, then
# clisp REPL throws away the first line of the second t-expression.
# Solution: If the user wants a REPL, we'll normally use our own.

fill_command_file () {  # Parameters: origfile commandfile
printf "$setup_commands" > "$2"
if [ -n "$1" ] ; then
  cat -- "$1" >> "$2"
else
  cat >> "$2" << "DONE"
format t "clisp sweet-expression REPL, use quit() to exit.~%~%"
loop
  do \\ progn
    write $ eval $ read()
    format t "~%"
DONE
fi
}


if [ $crepl = 1 ] ; then
  clisp $clisp_options -x "$setup_commands" -repl
else
  commandfile="$(mktemp)"
  fill_command_file "$origfile" "$commandfile"
  clisp --quiet --quiet $clisp_options "$commandfile" "$@"
  rm -fr "$commandfile"
fi

