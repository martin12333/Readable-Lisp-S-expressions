#!/bin/sh

# By David A. Wheeler. Start up clisp in "sweet-expression" reading mode,
# so you can try it out.  Setting *print-escape* isn't ideal, but
# in most circumstances it works out.

# NOTE: For now, this assumes that the current directory has the
# readable library *.lisp and *.asd files, and that tests/my-asdf.lisp
# has a valid asdf implementation.  That way, we can ensure that we
# run the current developmental version, not what's installed (if anything).

while [ $# -gt 0 ] ; do
  case "$1" in
    (--*) shift ; break ;;
    (-) break ;;
    (-*)
      echo "Option not supported." 1>&2
      exit 1
  esac
done

if [ $# -gt 0 ] ; then

# Have files.  "cat" the file contents.

(
cat << COMMAND_SET
(load "tests/my-asdf.lisp")
(asdf:load-system :readable)
(setq *print-escape* nil)
(readable:enable-sweet)
COMMAND_SET

cat -- "$@"

printf "\n\n"  # Ensure it ends on newlines.
) | \
 CL_SOURCE_REGISTRY="$PWD" "clisp" --quiet --quiet -lp "$PWD" -modern

else

# No files listed.  Use "expect" so readline will work interactively.
#       set login $spawn_id
#                 spawn tip modem
#                 # dial back out to user
#                 # connect user to login
#                 interact -u $login

# set interpreter \$spawn_id

CL_SOURCE_REGISTRY="$PWD" \
expect -c "
 spawn -noecho \"/usr/bin/clisp\" \"-lp\" \"$PWD\" -modern
 send \"
  (load \\\"tests/my-asdf.lisp\\\")
  (asdf:load-system :readable)
  (setq *print-escape* nil)
  (readable:enable-sweet)\n\n\"
 interact
 "

fi

