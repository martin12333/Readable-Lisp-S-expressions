#!/bin/sh

# By David A. Wheeler. Start up clisp in "sweet-expression" reading mode,
# so you can try it out.  Setting *print-escape* isn't ideal, but
# in most circumstances it works out.

# NOTE: For now, this assumes that the current directory has the
# readable library *.lisp and *.asd files, and that tests/my-asdf.lisp
# has a valid asdf implementation.  That way, we can ensure that we
# run the current developmental version, not what's installed (if anything).



if [ $# -gt 0 ] ; then

  shift

  commandfile="$(mktemp)"
  cat > "$commandfile" << COMMAND_SET
(require "asdf")
(asdf:load-system :readable)
(setq *print-escape* nil)
(readable:enable-sweet)
COMMAND_SET
  cat >> "$commandfile"

  # May need to add:
  # (eval-when (:compile-toplevel :load-toplevel :execute)
  # ...)

  CL_SOURCE_REGISTRY="$PWD" "clisp" --quiet --quiet -lp "$PWD" -modern \
                                    "$commandfile" "$@"

  # Clean up.
  rm -fr "$commandfile"

else

  # No files listed.  Use "expect" so readline will work interactively.
  #       set login $spawn_id
  #                 spawn tip modem
  #                 # dial back out to user
  #                 # connect user to login
  #                 interact -u $login
  
  # set interpreter \$spawn_id
  
  CL_SOURCE_REGISTRY="$PWD" expect -c "
    spawn -noecho clisp \"-lp\" \"$PWD\" -modern
    send \"
      (require \\\"asdf\\\")
      (asdf:load-system :readable)
      (setq *print-escape* nil)
      (readable:enable-sweet)\n\n\"
    interact
 "

fi

