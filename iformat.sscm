; iformat.scm
; Reformat an S-expression into indented sweet-expression.
;
; Copyright (C) 2006-2012 David A. Wheeler.
;
; This software is released as open source software under the "MIT" license:
;
; Permission is hereby granted, free of charge, to any person obtaining a
; copy of this software and associated documentation files (the "Software"),
; to deal in the Software without restriction, including without limitation
; the rights to use, copy, modify, merge, publish, distribute, sublicense,
; and/or sell copies of the Software, and to permit persons to whom the
; Software is furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.

; LIMITATIONS:
; Need to support same-line, {...} infix, etc.
;
; For efficiency, it should use another approach than string concatenation.
; Rewrite this using cons of strings, then flatten the list
; to a single string in a final pass.

define maxwidth 78
define indent-increment '(#\space #\space)
define max-unit-character-length 60
define max-unit-list-length 8

define group-string "group\n"
define infix-operators '(
            and or xor + - * / ^ ++ -- ** // ^^ < <= > >= = <> != ==)

define tab integer->char(9)
define LISTLP list( #\( )
define LISTRP list( #\) )
define LISTLBRACE list((integer->char 123))
define LISTRBRACE list((integer->char 125))


; Return length of x, which may be an improper list.
; If improper, count the two sides as two, so "(a . b)" is length 2.
define general-length(x)
  general-length-inner(x 0)

define general-length-inner(x count-so-far)
  cond
    null?(x)      count-so-far
    not(pair?(x)) {count-so-far + 1}
    #t
                  general-length-inner cdr(x) {count-so-far + 1}

; Return list x's *contents* represented as a list of characters.
; Each one must use modern-expressions, space-separated;
; it will be surrounded by (...) so no indentation processing is relevant.
define unit-list(x)
  cond
    null?(x) '()
    pair?(x)
      if null?(cdr(x))
        unit car(x)
        append unit(car(x)) '(#\space) unit-list(cdr(x))
    #t  append('(#\space #\. #\space) unit(x))


; Return #t if x should be represented using curly-infix notation {...}.
define represent-as-infix?(x)
  and
    pair? x
    symbol? car(x)
    memq car(x) infix-operators
    list? x
    {length(x) >= 3}
    {length(x) <= 6}

; Return tail of an infix expression, as list of chars
define infix-tail(op x)
  cond
    null?(x)  LISTRBRACE
    pair?(x)  append( '(#\space) op '(#\space) unit(car(x))
                       infix-tail(op cdr(x)) )
    ; The following is used if we get an improper list.
    ; This can't happen if only lists are represented with curly-infix:
    #t        append( '(#\space #\. #\space) unit(x) LISTRBRACE)

; Define an association list of Lisp abbreviations.
; Eventually use "group" to define this, but currently the group
; symbol is under discussion, so best not to use it yet:
define abbreviations '(
  (quote (#\'))
  (quasiquote (#\`))
  (unquote (#\,))
  (unquote-splicing (#\, #\@)))

; Given list of characters, return the characters that would REPRESENT
; those characters inside a string AFTER the initial double-quote,
; then return the double-quote.  This translates newline to \n, etc.
define unit-string-tail(x)
  if null?(x)
    '(#\")  ; Return the string's closing double-quote.
    append
      let ((c car(x)))
        cond             ; Can't use "case" because of "tab" variable.
          eq?(c #\\)        '(#\\ #\\)
          eq?(c #\")        '(#\\ #\")
          ; These aren't in R5RS, but NOT escaping them will
          ; cause more trouble:
          eq?(c #\newline)  '(#\\ #\n)
          eq?(c tab)        '(#\\ #\t)
          #t                list(car(x))
      unit-string-tail cdr(x)

; Return x represented as a modern-expression unit, as a list of characters.
; Indentation processing *may* be active, but the character sequence
; returned must not depend on that.
; This is widely-used; may want to memoize this.
define unit(x)
  cond
    null?(x)     string->list("()")
    number?(x)   string->list(number->string(x))
    boolean?(x)  if(x '(#\# #\t) '(#\# #\f))
    symbol?(x)   string->list(symbol->string(x))
    string?(x)   append('(#\") unit-string-tail(string->list(x)))
    pair?(x)
     cond
       {assq(car(x) abbreviations) and pair?(cdr(x)) and null?(cddr(x))}
         append cadr(assq(car(x) abbreviations)) unit(cadr(x))
       symbol?(car(x))
         if represent-as-infix?(x)
           append LISTLBRACE unit(cadr(x)) infix-tail(unit(car(x)) cddr(x))
           append unit(car(x)) LISTLP unit-list(cdr(x)) LISTRP
       #t append(LISTLP unit-list(x) LISTRP)
    #t  string->list(object->string(x))
    ; R5RS doesn't include "object->string", but it's painful to do without.
    ; You might be able to use these in a pinch:
    ; char?(x)     append '(#\# #\\) x ; Doesn't handle special chars

; Input: expression "m" with indentation string "indent".
; Output: List of characters representing it (#\newline for new line).
; This tail handles the body of a list (after its first entry) when
; indentation processing is active, each of these is its own initial line.
define iformat-body(m indent)
  if null?(m)
    '()
    append
      iformat-top  car(m) indent
      iformat-body cdr(m) indent

; Not currently used.
define iformat-list(m indent)
  if null?(m)
    '()
    append
      iformat-top  car(m) indent
      iformat-list cdr(m) indent


; Input: expression "m" with indentation string "indent".
; Output: List of characters representing it (#\newline for new line).
; At this point, we're at the beginning of a possibly-indented
; line with sweet-expression (indentation) processing active.
define iformat-top(m indent)
  cond
    not(pair?(m)) ; if not a list (atom, etc), print it. () handled here
      append(indent unit(m) '(#\newline))
    ;
    ;  TODO: handle non-atomic quotes.  There are questions about quote meaning
    ;  so let's be cautious for now.
    ; simple quote:
    {eq?(car(m) 'quote) and pair?(cdr(m)) and
     null?(cddr(m)) and symbol?(cadr(m))}
      append indent '(#\') unit(cadr(m)) '(#\newline)
    ;
    ; TODO: match backquote calls.
    ; At this point we have a list - is it special somehow?
    ; TODO: are null? and list? the right tests?
    ; {null?(cdr(m)) and not(pair?(car(m)))} ; singleton list, no descend
    ;  append indent LISTLP unit(car(m)) LISTRP '(#\newline)
    pair?(car(m)) ; Is its car also a list? If so, prefer using GROUP.
      append indent (string->list group-string)
        iformat-top  car(m) append(indent indent-increment)
        iformat-body cdr(m) append(indent indent-increment)
    #t
      ; Normal case: list with non-list as 1st element.
      let* ( asunit(unit(m)) length-asunit(length(asunit)) )
        if { {length-asunit < max-unit-character-length} and
             {{length-asunit + length(indent)} < maxwidth } and
             {general-length(m) < max-unit-list-length} }
          append indent asunit '(#\newline)
          append
            iformat-top  car(m) indent
            iformat-body cdr(m) append(indent indent-increment)

; Display formatted expression "m" using indentation string "indent".
define iformat(m indent)
  display list->string(iformat-top(m string->list(indent)))

; Copy one line from stdin to stdout, end on EOF or newline.
define (copy-line port)
  let ((c peek-char(port)))
    cond
      eof-object?(c)   c
      char=?(c #\newline) read-char() newline()
      #t display(read-char(port)) copy-line(port)

; filter stdin to stdout, reading in traditional s-expressions and outputting
; sweet-expressions.  Preserve the comments outside an s-expression.
define (iformat-filter)
  let ((c peek-char(current-input-port())))
    cond
      eof-object?(c)      c
      char=?(c #\newline) read-char() newline() iformat-filter()
      char=?(c #\space)   read-char() iformat-filter()
      char=?(c #\tab)     read-char() iformat-filter()
      char=?(c #\;)       copy-line(current-input-port()) iformat-filter()
      #t
        let ((result read(current-input-port())))
          if eof-object?(result)
            result
            begin iformat(result "") iformat-filter()

iformat-filter()

