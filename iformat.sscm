; iformat.scm
; Filter to read S-expressions and output indented sweet-expression.
;
; Copyright (C) 2006-2012 David A. Wheeler.
;
; This software is released as open source software under the "MIT" license:
;
; Permission is hereby granted, free of charge, to any person obtaining a
; copy of this software and associated documentation files (the "Software"),
; to deal in the Software without restriction, including without limitation
; the rights to use, copy, modify, merge, publish, distribute, sublicense,
; and/or sell copies of the Software, and to permit persons to whom the
; Software is furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.


; Note: The maxwidth may be violated if, at a current indent, there is a
; long non-pair that exceeds it.  But other than long atoms, it's respected,
; so it's unlikely to exceed this width in practice:
define maxwidth 78

define indent-increment '(#\space #\space)
define max-unit-character-length 60
define max-unit-list-length 8

define group-string "\\\\\n"
define infix-operators '(
            and or xor + - * / ^ ++ -- ** // ^^ < <= > >= = <> != ==)

; Lists with these symbols as first parameter, and aren't shown on 1 line,
; are be shown as a line with SYMBOL FIRST-PARAMETER and *then* indents.
; This is used when the first parameter is especially *special* and
; (normally) has a different semantic meaning from later parameters.
; This refinement isn't *necessary* but I think it looks better.
define cuddle-first-parameter '(define defun lambda set!
           if when unless let let* letrec do syntax-rules)

define tab integer->char(9)
define LISTLP list( #\( )
define LISTRP list( #\) )
define LISTLBRACE list((integer->char 123))
define LISTRBRACE list((integer->char 125))


; Return length of x, which may be an improper list.
; If improper, count the two sides as two, so "(a . b)" is length 2.
define general-length(x)
  general-length-inner(x 0)

define general-length-inner(x count-so-far)
  cond
    null?(x)      count-so-far
    not(pair?(x)) {count-so-far + 1}
    #t
                  general-length-inner cdr(x) {count-so-far + 1}

; Return list x's *contents* represented as a list of characters.
; Each one must use modern-expressions, space-separated;
; it will be surrounded by (...) so no indentation processing is relevant.
define unit-list(x)
  cond
    null?(x) '()
    pair?(x)
      if null?(cdr(x))
        unit car(x)
        append unit(car(x)) '(#\space) unit-list(cdr(x))
    #t  append('(#\space #\. #\space) unit(x))


; Return #t if x should be represented using curly-infix notation {...}.
define represent-as-infix?(x)
  and
    pair? x
    symbol? car(x)
    memq car(x) infix-operators
    list? x
    {length(x) >= 3}
    {length(x) <= 6}

; Return tail of an infix expression, as list of chars
define infix-tail(op x)
  cond
    null?(x)  LISTRBRACE
    pair?(x)  append( '(#\space) op '(#\space) unit(car(x))
                       infix-tail(op cdr(x)) )
    ; The following is used if we get an improper list.
    ; This can't happen if only lists are represented with curly-infix:
    #t        append( '(#\space #\. #\space) unit(x) LISTRBRACE)

; Define an association list of Lisp abbreviations.
; Eventually use "group" to define this, but currently the group
; symbol is under discussion, so best not to use it yet:
define abbreviations '(
  (quote (#\'))
  (quasiquote (#\`))
  (unquote (#\,))
  (unquote-splicing (#\, #\@)))


; return #t if we should as a traditional abbreviation, e.g., '
define represent-as-abbreviation?(x)
  and
    assq car(x) abbreviations
    pair? cdr(x)
    null? cddr(x)

; Given list of characters, return the characters that would REPRESENT
; those characters inside a string AFTER the initial double-quote,
; then return the double-quote.  This translates newline to \n, etc.
define unit-string-tail(x)
  if null?(x)
    '(#\")  ; Return the string's closing double-quote.
    append
      let ((c car(x)))
        cond             ; Can't use "case" because of "tab" variable.
          eq?(c #\\)        '(#\\ #\\)
          eq?(c #\")        '(#\\ #\")
          ; These aren't in R5RS, but NOT escaping them will
          ; cause more trouble:
          eq?(c #\newline)  '(#\\ #\n)
          eq?(c tab)        '(#\\ #\t)
          #t                list(car(x))
      unit-string-tail cdr(x)

; Return x represented as a modern-expression unit, as a list of characters.
; Indentation processing *may* be active, but the character sequence
; returned must not depend on that.
; This is widely-used; may want to memoize this.
define unit(x)
  cond
    null?(x)     string->list("()")
    number?(x)   string->list(number->string(x))
    boolean?(x)  if(x '(#\# #\t) '(#\# #\f))
    symbol?(x)   string->list(symbol->string(x))
    string?(x)   append('(#\") unit-string-tail(string->list(x)))
    pair?(x)
     cond
       represent-as-abbreviation?(x)
         append cadr(assq(car(x) abbreviations)) unit(cadr(x))
       symbol?(car(x))
         if represent-as-infix?(x)
           append LISTLBRACE unit(cadr(x)) infix-tail(unit(car(x)) cddr(x))
           append unit(car(x)) LISTLP unit-list(cdr(x)) LISTRP
       #t append(LISTLP unit-list(x) LISTRP)
    #t  string->list(object->string(x))
    ; R5RS doesn't include "object->string", but it's painful to do without.
    ; You might be able to use these in a pinch:
    ; char?(x)     append '(#\# #\\) x ; Doesn't handle special chars


; Return x, the rest of the list, as a list of characters. See line().
define line-tail(x)
  cond
    null?(x)  '()
    pair?(x)
      append unit(car(x)) '(#\space) line-tail(cdr(x))
    #t
      append '(#\. #\space) unit(x)

; Return x represented as a line of space-separated modern-expression units,
; as a list of characters.
; Indentation processing *MUST* be active.
define line(x)
  cond
    not(pair?(x))                 unit(x)
    represent-as-abbreviation?(x) unit(x)
    represent-as-infix?(x)        unit(x)
    {pair?(x) and null?(cdr(x))} ; Handle 1-datum case specially.
      if symbol?(car(x))
        append unit(car(x)) LISTLP LISTRP
        append LISTLP unit(car(x)) LISTRP
    #t
      append unit(car(x)) '(#\space) line-tail(cdr(x))
    
; Input: expression "m" with indentation string "indent".
; Output: List of characters representing it (#\newline for new line).
; This tail handles the body of a list (after its first entry) when
; indentation processing is active, each of these is its own initial line.
define iformat-body(m indent)
  if null?(m)
    '()
    append
      iformat-top  car(m) indent
      iformat-body cdr(m) indent

; Return list m represented in the typical indent style.
define iformat-top-normal-indent(m indent)
  append
    iformat-top  car(m) indent
    iformat-body cdr(m) append(indent indent-increment)

; Input: expression "m" with indentation string "indent".
; Output: List of characters representing it (#\newline for new line).
; At this point, we're at the beginning of a possibly-indented
; line with sweet-expression (indentation) processing active.
define iformat-top(m indent)
  if not(pair?(m)) ; if not a pair, just print it. () handled here
    append(indent unit(m) '(#\newline))
    ; We have a pair. Try to represent as one line of space-sep params.
    let* (asline(line(m)) length-asline(length(asline)))
      if { {length-asline < max-unit-character-length} and
           {{length-asline + length(indent)} < maxwidth } and
           {general-length(m) < max-unit-list-length} }
        append indent asline '(#\newline)
        ; Can't put entire expression on one line, now try alternatives:
        if pair?(car(m))  ; Is car a pair?  If so, we may need GROUP.
          let* (asline-car(line(car(m))))
            if {{length(asline-car) + length(indent)} < maxwidth }
              iformat-top-normal-indent(m indent) ; We can squeeze it in.
              append indent (string->list group-string) ; Can't squeze; GROUP
                iformat-top  car(m) append(indent indent-increment)
                iformat-body cdr(m) append(indent indent-increment)
          ; The car isn't a pair. Try to cuddle, else use normal indent style
          if { memq(car(m) cuddle-first-parameter) and {length(m) >= 3}}
            let* (asline-cuddled(line(list(car(m) cadr(m)))))
               if { {length(asline-cuddled) + length(indent)} < maxwidth}
                  append indent asline-cuddled '(#\newline) ; Cuddle up!
                    iformat-body cddr(m) append(indent indent-increment)
                  iformat-top-normal-indent(m indent) ; Don't cuddle.
            iformat-top-normal-indent(m indent)


; Display formatted expression "m" using indentation string "indent".
define iformat(m indent)
  display list->string(iformat-top(m string->list(indent)))

; Copy one line from stdin to stdout, end on EOF or newline.
define (copy-line port)
  let ((c peek-char(port)))
    cond
      eof-object?(c)   c
      char=?(c #\newline) read-char() newline()
      #t display(read-char(port)) copy-line(port)

; filter stdin to stdout, reading in traditional s-expressions and outputting
; sweet-expressions.  Preserve the comments outside an s-expression.
define (iformat-filter)
  let ((c peek-char(current-input-port())))
    cond
      eof-object?(c)      c
      char=?(c #\newline) read-char() newline() iformat-filter()
      char=?(c #\space)   read-char() iformat-filter()
      char=?(c #\tab)     read-char() iformat-filter()
      char=?(c #\;)       copy-line(current-input-port()) iformat-filter()
      #t
        let ((result read(current-input-port())))
          if eof-object?(result)
            result
            begin iformat(result "") iformat-filter()

iformat-filter()

