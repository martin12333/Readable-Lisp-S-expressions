; iformat.scm
; Reformat an S-expression into indented sweet-expression.
;
; Copyright (C) 2006-2012 David A. Wheeler.
;
; This software is released as open source software under the "MIT" license:
;
; Permission is hereby granted, free of charge, to any person obtaining a
; copy of this software and associated documentation files (the "Software"),
; to deal in the Software without restriction, including without limitation
; the rights to use, copy, modify, merge, publish, distribute, sublicense,
; and/or sell copies of the Software, and to permit persons to whom the
; Software is furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.

; LIMITATIONS:
; Need to support same-line, {...} infix, etc.
;
; For efficiency, it should use another approach than string concatenation.
; Rewrite this using cons of strings, then flatten the list
; to a single string in a final pass.

define maxwidth 78
define indent-increment '(#\space #\space)

define LISTLP list( #\( )
define LISTRP list( #\) )

define infix-operators '(and or xor + - * /)

define oneline-list(x)
  ; Return list x's contents, represented as a list of characters
  cond
    null?(x) '()
    pair?(x)
      if null?(cdr(x))
        oneline(car(x))
        append oneline(car(x)) '(#\space) oneline-list(cdr(x))
    #t       append('(#\space #\. #\space) oneline(x))

define represent-as-infix?(x)
  and
    list? x
    symbol? car(x)
    memq car(x) infix-operators
    {length(x) >= 3}
    {length(x) <= 6}

define infix-tail(op x)
  cond
    null?(x)  '(#\})
    pair?(x)  append( '(#\space) op '(#\space) oneline(car(x))
                       infix-tail(op cdr(x)) )
    #t        append( '(#\space #\. #\space) oneline(x) '(#\}) )

define oneline(x)
  ; Return x represented in a single line, as a list of characters.
  cond
    null?(x)     string->list("()")
    number?(x)   string->list(number->string(x))
    symbol?(x)   string->list(symbol->string(x))
    string?(x)   string->list(x)
    ; TODO handle double-quote, backslash, nl
    pair?(x)
     if symbol?(car(x))
       if represent-as-infix?(x)
         append '(#\{) oneline(cadr(x)) infix-tail(oneline(car(x)) cddr(x))
         append oneline(car(x)) LISTLP oneline-list(cdr(x)) LISTRP
       append LISTLP oneline-list(x) LISTRP
    ; TODO: Others, esp. vector

define iformat-body(m indent)
  if null?(m)
    '()
    append
      iformat-top  car(m) indent
      iformat-body cdr(m) indent

define iformat-list(m indent)
  if null?(m)
    '()
    append
      iformat-top  car(m) indent
      iformat-list cdr(m) indent


define iformat-top(m indent)
  cond
    not(pair?(m)) ; if not a list (atom, etc), print it. () handled here
      append(indent oneline(m) '(#\newline))
    ;
    ;  TODO: handle non-atomic quotes.  There are questions about quote meaning
    ;  so let's be cautious for now.
    ; simple quote:
    {eq?(car(m) 'quote) and pair?(cdr(m)) and
     null?(cddr(m)) and symbol?(cadr(m))}
      append indent '(#\') oneline(cadr(m)) '(#\newline)
    ;
    ; TODO: match backquote calls.
    ; At this point we have a list - is it special somehow?
    ; TODO: are null? and list? the right tests?
    ; {null?(cdr(m)) and not(pair?(car(m)))} ; singleton list, no descend
    ;  append indent LISTLP oneline(car(m)) LISTRP '(#\newline)
    pair?(car(m)) ; Is its car also a list? If so, must use GROUP.
     append indent (string->list "group\n")
        iformat-top  car(m) append(indent indent-increment)
        iformat-body cdr(m) append(indent indent-increment)
    #t
      ; Normal case: list with non-list as 1st element.
      if {length(oneline(m)) < 30}
        append indent oneline(m) '(#\newline)
        append
          iformat-top  car(m) indent
          iformat-body cdr(m) append(indent indent-increment)

define iformat(m indent)
  display list->string(iformat-top(m string->list(indent)))


define (copy-line port)
  ; Copy line from in to out - end on EOF or newline.
  let ((c peek-char(port)))
    cond
      eof-object?(c)   c
      char=?(c #\newline) read-char() newline()
      #t display(read-char(port)) copy-line(port)

; Filter - written this way to preserve "external" comments
define (iformat-filter)
  let ((c peek-char(current-input-port())))
    cond
      eof-object?(c)      c
      char=?(c #\newline) read-char() newline() iformat-filter()
      char=?(c #\space)   read-char() iformat-filter()
      char=?(c #\tab)     read-char() iformat-filter()
      char=?(c #\;)       copy-line(current-input-port()) iformat-filter()
      #t
        let ((result read(current-input-port())))
          if eof-object?(result)
            result
            begin iformat(result "") iformat-filter()

iformat-filter()

