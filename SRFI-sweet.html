<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
<title>Draft SRFI Sweet: Sweet-expressions</title>
<meta content="text/html; charset=us-ascii" http-equiv="content-type">
<meta name="description" content="This defines sweet-expressions (t-expressions) for Scheme, building on neoteric-expressions (n-expressions) and curly-infix-expressions (c-expressions). This defines an approach to making Scheme more 'readable' by adding syntactically-relevant indentation, as well as supporting infix and functions whose names precede the opening parenthesis.">
<meta name="keywords" content="sweet, sweet-expression, sweet-expressions, t-expression, Scheme, Lisp, Common Lisp, neoteric-expression, n-expression, readable, notation, s-expression, s-expr, M-expression, SRFI, implementation, David Wheeler, David A. Wheeler, Alan Manuel Gloria, Alan Manuel K. Gloria">
<meta name="generator" content="vim">
<!-- Copy CSS style of SRFI-64; credits to Per Bothner. -->
<!-- Note: "style" isn't in HTML 3.2, but SRFI-64 set a precedent
     for allowing this: -->
<style type="text/css">
  div.title h1 { font-size: small; color: blue }
  div.title { font-size: xx-large; color: blue; font-weight: bold }
  h1 { font-size: x-large; color: blue }
  h2 { font-size: large; color: blue }
  /* So var inside pre gets same font as var in paragraphs. */
  var { font-family: monospace; }
</style>
</head>
<body>

<!-- Note: "class" isn't in HTML 3.2, but SRFI-64 set a precedent
     for allowing this: -->
<div class="title">
<h1><a name="title">Title</a></h1>
<p>Sweet-expressions</p>
</div>

<!-- Some old browsers have problem with empty names. Work around here: -->
<h1><a name="authors">Authors</a><a name="author">&nbsp;</a></h1>
<p><a href="http://www.dwheeler.com">David A. Wheeler</a></p>

<h1><a name="status">Status</a></h1>
<p>This is a draft Scheme Request for Implementation (SRFI) for
SRFI ???. To see an explanation of each status that
a SRFI can hold, see <a href=
"http://srfi.schemers.org/srfi-process.html" rel=
"nofollow">here</a>.</p>
<p>To provide input on this SRFI, please <a href=
"mailto:srfi%20minus%20???%20at%20srfi%20dot%20schemers%20dot%20org">
mail to <code>&lt;srfi minus ??? at srfi dot schemers dot
org&gt;</code></a>. See <a href=
"http://srfi.schemers.org/srfi-list-subscribe.html" rel=
"nofollow">instructions here</a> to subscribe to the list. You can
access previous messages via <a href=
"http://srfi.schemers.org/srfi-???/mail-archive/maillist.html" rel=
"nofollow">the archive of the mailing list</a>.
This SRFI contains all the required sections, including
an <a href="#abstract">abstract</a>,
<a href="#rationale">rationale</a>,
<a href="#specification">specification</a>,
<a href="#design-rationale">design rationale</a>,
and
<a href="#reference-implementation">reference implementation</a>.
</p>

<h1><a name="related-srfis">Related SRFIs</a></h1>
<p>
<a href="http://srfi.schemers.org/srfi-49/">SRFI-49
(Indentation-sensitive syntax)</a>,
<a href="http://srfi.schemers.org/srfi-105/">SRFI-105
(Curly-infix-expressions)</a>
</p>

<h1><a name="abstract">Abstract</a></h1>
<p>
Many software developers find Lisp s-expression notation inconvenient and
unpleasant to read, in part because of the many parentheses required
in typical use.
Even those who like Lisp s-expressions typically use indentation
to show structure, and not just parentheses,
because structure is not obvious in raw un-indented s-expressions.
This SRFI defines an indentation-sensitive syntax, inspired by Python;
indentation-senstitive syntax eliminates the need for many parentheses
and the need to synchronize indentation with parentheses.
The previous
<a href="http://srfi.schemers.org/srfi-49/">SRFI-49</a> defines an
indentation-sensitive syntax, but in practice it is somewhat awkward,
and by itself it lacks
support for infix notation (e.g., <tt>{a&nbsp;+&nbsp;b}</tt>)
and prefix formats (e.g., <tt>f(x)</tt>).
</p>
<p>
This SRFI defines sweet-expressions (aka t-expressions),
an indentation-sensitive syntax developed from
experience in implementing real Scheme programs.
It is derived from
<a href="http://srfi.schemers.org/srfi-49/">SRFI-49</a>
and includes (by reference)
<a href="http://srfi.schemers.org/srfi-105/">SRFI-105</a>.
Unlike most past efforts to make Lisp more &#8220;readable&#8221;,
the sweet-expression notation is
generic (the notation does not depend on an underlying semantic),
homoiconic (the underlying data structure is clear from the syntax), and
backwards-compatible with well-formatted s-expressions.
</p>
<p>
For example, the following sweet-expression:
</p>
<pre>
define factorial(n)
  if {n <= 1}
    1
    {n * factorial{n - 1}}
</pre>
<p>
Maps to the following s-expression:
</p>
<pre>
(define (factorial n)
  (if (<= n 1)
    1
    (* n (factorial (- n 1)))))
</pre>

<p>
A sweet-expression reader would accept <i>either</i> form.
Note that the sweet-expression notation is derived from the
&#8220;<a href="http://readable.sourceforge.net/">
Readable Lisp S-expressions Project</a>&#8221;.
</p>

<h1><a name="rationale">Rationale</a></h1>
<p>
The large number of parentheses required by Lisp syntax is the butt
of many jokes in the software development community
and has been widely criticized.
The
<a href="http://www.catb.org/jargon/html/L/LISP.html">Jargon File</a>
says that Lisp is
&#8220;mythically from &#8216;Lots of Irritating Superfluous Parentheses&#8217; &#8220;.
<a href="http://fortunes.cat-v.org/kernelnewbies/">Linus Torvalds</a>
commented about some parentheses-rich C code,
&#8220;don&#8217;t ask me about the extraneous parenthesis.  I bet some
LISP programmer felt alone and decided to make it a bit more homey.&#8221;
<a href="http://www.linuxjournal.com/article/2070">
Larry Wall, the creator of Perl</a>, says that,
&#8220;Lisp has all the visual appeal of oatmeal
with fingernail clippings mixed in.
(Other than that, it&#8217;s quite a nice language.)&#8221;.
<a href="http://shriram.github.com/p4p/">Shriram Krishnamurthi</a> says,
&#8220;Racket [(a Scheme implementation)] has an excellent language design,
a great implementation, a superb programming environment, and terrific tools.
Mainstream adoption will, however, always be curtailed by the syntax.
Racket could benefit from [reducing]
the layers of parenthetical adipose that [needlessly] engird it.&#8221;
</p>
<p>
Since Lisp programs and data are often written using indentation anyway,
it seems reasonable to create
an indentation-sensitive syntax that would eliminate the need for
many of these &#8220;superfluous&#8221; parentheses, as well as eliminating the
need to keep the indentation and parentheses synchronized.
</p>
<p>
This is not a new observation.
<a href="http://paulgraham.com/popular.html">Lisp advocate
Paul Graham says</a>, regarding Lisp syntax,
&#8220;A more serious problem [in Lisp] is the diffuseness of prefix notation...
We can get rid of (or make optional) a lot of parentheses by making
indentation significant. That&#8217;s how programmers read code anyway: when
indentation says one thing and delimiters say another, we go by the
indentation.
Treating indentation as significant would eliminate this
common source of bugs as well as making programs shorter.
Sometimes infix syntax is easier to read. This is especially true for
math expressions. I&#8217;ve used Lisp my whole programming life and I still
don&#8217;t find prefix math expressions natural...
I don&#8217;t think we should be religiously opposed to introducing syntax
into Lisp, as long as it translates in a well-understood
way into underlying s-expressions.
There is already a good deal of syntax in Lisp.
It&#8217;s not necessarily bad to introduce more,
as long as no one is forced to use it.&#8221;
</p>
<p>
The indentation-sensitive syntax defined in this SRFI
is generic (the notation does not depend on an underlying semantic)
and homoiconic (the underlying data structure is clear from the syntax).
We believe previous efforts to improve the readability of
Lisp s-expressions, such as McCarthy&#8217;s M-expressions, failed because
they failed to be generic or homoiconic.
It often difficult to easily access new capabilities
(such as those defined by macros) in notations that are not
generic or homoiconic.
In contrast, because sweet-expressions <i>are</i> generic and homoiconic,
they can be easily used with other constructs
such as quasiquoting and macros.
In short, if a capability can be accessed using s-expressions, then they
can be accessed without any additional effort using sweet-expressions.
The indentation processing is simply
an abbreviation, in much the same way that
<samp>&#39;x</samp> is an abbreviation for <samp>(quote&nbsp;x)</samp>.
</p>
<p>
<a href="http://srfi.schemers.org/srfi-49/">SRFI-49</a> defines an
indentation-sensitive syntax.
Unfortunately, it has not been widely deployed among Scheme implementations.
We believe this is, at least in part,
because of various problems and limitations in it,
<a href="#srfi-49">described in more detail below</a>.
Nevertheless, SRFI-49 represented an important first step in devising
an indentation-sensitive syntax; sweet-expressions are derived from SRFI-49
and retain most of its syntax.

</p>
<p>
The notation defined in this sweet-expressions SRFI
is intentionally designed so that, unlike Python,
it works exactly the same way in both interactive mode (e.g., a REPL)
and when processing a file.
A difference in modes could cause failure when
cutting-and-pasting between a file and an interactive session.
Since many users often switch between the REPL and files,
such a difference was considered unacceptable.
</p>
<p>This notation is a <em>simple</em> and
<em>straightforward</em> technique, extended by a few abbreviations
based on real-world experience.

<p>
See the <a href="#design-rationale">design rationale</a> for a detailed
discussion on how and why it is designed this way.

<h1><a name="specification">Specification</a></h1>
<p>
The key words
&#8220;<em>MUST</em>&#8221;,
&#8220;<em>MUST NOT</em>&#8221;,
&#8220;<em>REQUIRED</em>&#8221;,
&#8220;<em>SHALL</em>&#8221;,
&#8220;<em>SHALL NOT</em>&#8221;,
&#8220;<em>SHOULD</em>&#8221;,
&#8220;<em>SHOULD NOT</em>&#8221;,
&#8220;<em>RECOMMENDED</em>&#8221;,
&#8220;<em>MAY</em>&#8221;,
and &#8220;<em>OPTIONAL</em>&#8221; in this
document are to be interpreted as described in
<a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>.
</p>

<p>
<p>&#8220;<dfn>Sweet-expressions</dfn>&#8221; (aka &#8220;<dfn>t-expressions</dfn>&#8221;) deduce parentheses from indentation.
A sweet-expression reader <em>MUST</em> interpret its input
as follows when indentation processing is active:
<ol>
<li>An indented line is a parameter of its parent.</li>
<li>Later terms on a line are parameters of the first term.</li>
<li>A line with exactly one term, and no child lines, is simply that term; multiple terms are wrapped into a list.</li>
<li>An empty line ends the expression; empty lines before expressions are ignored.</li>
<li>Indentation processing is not active (and thus does not occur) inside ( ), [ ], and { }, whether they are prefixed or not; they&#8217;re just neoteric-expressions.</li>
<li>Terms are neoteric-expressions as defined in
<a href="http://srfi.schemers.org/srfi-105/">SRFI-105</a>.
</ol>
</p>

<p>
Sweet-expression rule clarifications:
<ol>
<li>You can indent using one or more of the indent characters,
which are space, tab, and exclamation point (!).</li>
<li>An unescaped &#8220;;&#8221; not in a string (still) introduces comments
that end at the end of the line or file.</li>
<li>Lines with only a ;-comment (preceded by 0 or more indent characters)
are completely ignored - even their indentation (if any) is irrelevant.</li>
<li>A line with only indentation is an empty line.</li>
<li>An expression that starts indented enables &#8220;indented-compatibility&#8221; mode,
where indentation is completely ignored.
Instead, a sequence of white-space separated neoteric-expressions is read
until the first end of line or end of file.</li>
<li>Scheme&#8217;s #; datum comment comments out the next neoteric expression,
not the next sweet expression.</li>
<li>Block comments (<tt>#|</tt> ... <tt>|#</tt>) are removed, but if it
begins immediately after the indent (if any),
the indentation at the beginning of the block comment is used.
</li>
</ol>

<p>
The sweet-expression advanced features are defined as follows:
<ol>
<li>A \\ (aka SPLIT) <em>MUST</em> start a new line at the current indentation. If it&#8217;s immediately after indentation (aka GROUP in that case), it represents no symbol at all (at that indentation) - this is useful for lists of lists.</li>
<li>A $ (aka SUBLIST) in the middle of list <em>MUST</em> restart list processing; the right-hand-side (including its sub-blocks) is the last parameter of the left-hand side (of just that line). If there&#8217;s no left-hand-side, the right-hand-side is put in a list.</li>
<li>A leading traditional abbreviation (quote, comma, backquote, or comma-at), followed by space or tab, <em>MUST</em> be interpreted as that operator applied to the sweet-expression that follows.</li>
<li>The markers &lt;* and *&gt; are reserved for future use.
</ol>

<p>
The markers for the advanced sweet-expression features <em>MUST</em>
only be accepted as such when indentation processing is active,
and <em>MUST</em> only be
interpreted as above if they begin with their characters as shown.
For example, <samp><tt>{$}</tt></samp>
<em>MUST NOT</em> be interpreted as the SUBLIST marker; instead, it
<em>MUST</em> be interpreted as the symbol <tt>$</tt>.
</p>

<p>
Beginning an expression with indentation <em>MUST</em> cause that line&#8217;s
indentation to be ignored, improving backwards compatibility. We recommend
that editors highlight these lines as warnings, to reduce the risk of
their accidental use. It might be also useful for an editor to highlight
blank lines (as they separate expressions) and lines beginning at the
left column (as these start new expressions).
</p>

<p>A <dfn>sweet-expression reader</dfn> is a datum reader
that can correctly read and map sweet-expressions as defined above
(including the advanced sweet-expression features).
An implementation of this SRFI <em>MUST</em> accept
the marker <code>#!sweet</code> followed by a whitespace character
in its standard datum readers (e.g., <code>read</code> and, if applicable,
the default implementation REPL).
This marker (including the trailing whitespace character)
<em>MUST</em> be consumed and considered whitespace.
After reading this marker, the reader <em>MUST</em> accept
sweet-expressions in subsequent datums read from the same port,
overriding any conflicting marker (such as <code>#!curly-infix</code>
followed by whitespace)
until some other conflicting marker is given.
</p>

<p>
Implementations of this SRFI <em>MAY</em>
implement curly-infix-expressions in their datum readers by default,
even when the marker is not (yet) received.
Portable applications <em>SHOULD</em> include this marker before
using curly-infix-expressions, typically near the top of a file.
Portable applications <em>SHOULD NOT</em>
use this marker as the very first characters
of a file (e.g., it could be preceded by a newline),
because they might be misinterpreted on some platforms
as an executable script header.
</p>

<p>
Implementations <em>MAY</em> provide the procedure
<var>sweet-read</var> as a
sweet-expression reader.
If provided, this procedure
<em>SHOULD</em> support an optional port parameter.
</p>

<p>Note that, by definition, this SRFI modifies lexical syntax.</p>

<h2><a name="bnf">BNF</a></h2>
<p>
The following BNF defines sweet-expressions.
It is intended to capture the specification above; in case of (unintentional)
conflict, the specification text above governs.
</p>

<p>
???
</p>

<h1><a name="examples">Examples</a></h1>
<p>
Here are some examples and their mappings.
</p>

<table border="1" cellpadding="4">
<tr>
<th align="center">Sweet-expressions (t-expressions)</th>
<th align="center">s-expressions</th>
</tr>
<tr>
<td align="left" valign="top">
<pre>
define fibfast(n)  ; Typical function notation
  if {n &lt; 2}       ; Indentation, infix {...}
    n              ; Single expr = no new list
    fibup(n 2 1 0) ; Simple function calls
</pre>
</td>
<td align="left" valign="top">
<pre>
(define (fibfast n)
  (if (&lt; n 2)
    n
    (fibup n 2 1 0)))
</pre>
</td>
</tr>

<tr>
<td align="left" valign="top">
<pre>
define fibup(max count n-1 n-2)
  if {max = count}
    {n-1 + n-2}
    fibup max {count + 1} {n-1 + n-2} n-1
</pre>
</td>
<td align="left" valign="top">
<pre>
(define (fibup max count n-1 n-2)
  (if (= max count)
    (+ n-1 n-2)
    (fibup max (+ count 1) (+ n-1 n-2) n-1)))
</pre>
</td>
</tr>

<tr>
<td align="left" valign="top">
<pre>
define factorial(n)
  if {n &lt;= 1}
    1
    {n * factorial{n - 1}}
</pre>
</td>
<td align="left" valign="top">
<pre>
(define (factorial n)
  (if (&lt;= n 1)
    1
    (* n (factorial (- n 1)))))
</pre>
</td>
</tr>

<tr>
<td align="left" valign="top">
<pre>
f ; Demo improper lists
  a . b
</pre>
</td>
<td align="left" valign="top">
<pre>
(f
  (a . b))
</pre>
</td>
</tr>

<tr>
<td align="left" valign="top">
<pre>
' a b ; Demo abbreviations
  'c d e \\ f g h
</pre>
</td>
<td align="left" valign="top">
<pre>
'(a b
    ('c d e) (f g h))
</pre>
</td>
</tr>

<tr>
<td align="left" valign="top">
<pre>
ff ; Block comments
  #| qq |# t1 t2
  t3 t4
    t5 #| xyz |# t6
</pre>
</td>
<td align="left" valign="top">
<pre>
(ff
  (t1 t2)
  (t3 t4
    (t5 t6)))
</pre>
</td>
</tr>

<tr>
<td align="left" valign="top">
<pre>
; This BEGINS with an indent
  f(a) g(x)
</pre>
</td>
<td align="left" valign="top">
<pre>
(f a)
(g x)
</pre>
</td>
</tr>

<tr>
<td align="left" valign="top">
<!-- Inspired by letterfall's code:
define screen-initialize-post-show(toplevel-window drawing-area)
  let
    $ style $ get-style toplevel-window
    set! back-pen $ get-black-gc style
    set! fore-pen $ get-white-gc style
    let
      \\
        configure-handler $ make-configure-handler drawing-area
        expose-handler $    make-expose-handler drawing-area
      set! the-expose-handler expose-handler
      connect drawing-area 'configure-event configure-handler
      connect drawing-area 'expose-event expose-handler
      configure-handler()
rewritten to fit in 40 characters.
-->
<pre>
define init(win area)
  let
    $ style $ get-style win
    set! back-pen $ black style
    set! fore-pen $ white style
    let
      \\
        config $ make-c area
        expose $ make-e area
      set! now expose
      dostuff config expose
</pre>
</td>
<td align="left" valign="top">
<pre>
(define (init win area)
  (let
    ((style (get-style win)))
    (set! back-pen (black style))
    (set! fore-pen (white style))
    (let
      (
        (config (make-c area))
        (expose (make-e area)))
      (set! now expose)
      (dostuff config expose))))
</pre>
</td>
</tr>

</table>


<h1><a name="design-rationale">Design Rationale</a></h1>

<p>
This SRFI design
rationale is unusually long, especially when you compare it to
the simplicity of its specification.
We have separated the design rationale from the overall rationale,
as was previously done by SRFI-26, because it is easier to
understand the design rationale after reading the specification.
</p>

<h2>General and homoiconic formats</h2>

<p>There have been a huge number of past efforts
to create readable formats for Lisp-based languages,
going all the way back to the original
M-expression syntax that Lisp&#8217;s creator expected to be used when
programming.  Generally, they&#8217;ve been unsuccessful, or they end up
creating a completely different language that lacks the advantages
of Lisp-based languages.
</p>

<p>
After examining a huge number of them,
David A. Wheeler noticed a pattern: Past &#8220;readable&#8221; Lisp notations
typically failed to be <em>general</em> or <em>homoiconic</em>.
</p>

<p>
A <em>general</em>
format is <em>not</em> tied to some specific underlying semantic.
Most readability efforts focused on creating special syntax for each
language construct of an underlying language.  But since Lisp-based
languages can trivially create new semantic constructs (via macros), and
are often used to process fragments of <em>other</em> languages, these
did not work well.  It was often difficult to keep updating the parser to
match the underlying system, so the parser was always less capable than
using s-expressions... leading to its abandonment.  Sometimes the parser
was continuously maintained, but soon the parser led to the development
of a completely new language that was less suitable for self-analysis
of program fragments and similar tasks (and thus no longer a suitable
&#8220;Lisp&#8221;).
It&#8217;s easy to create a new &#8220;operator&#8221; in a Lisp, yet many
infix systems cannot work without having its precedence predefined.
Similarly, it&#8217;s easy to create a macro in Lisp, and using it must not
require that the parser be changed each time.
</p>
<p>
A <em>homoiconic</em> format is a surface format in which the <em>human</em>
reader can easily determine what the underlying representation is.
It is very difficult to take advantage of Lisp capabilities, such as
macros, without a homoiconic format. Yet many past readability efforts
made it difficult to determine exactly what structures were being
created by the notation.  Typical infix notations with precedence were
especially common examples of this problem - they would quietly create
multiple lists without obvious indications that this was happening.
<a href="http://javascript.crockford.com/tdop/tdop.html">
Top Down Operator Precedence by Douglas Crockford
(2007-02-21)</a>, for example, discusses Vaughan Pratt&#8217;s &#8220;Top Down
Operator Precedence&#8221; and shows how important homoiconicity is.
He stated that &#8220;parsing techniques are not greatly valued in the
LISP community, which celebrates the Spartan denial of syntax.
There
have been many attempts since LISP&#8217;s creation to give the language a
rich ALGOL-like syntax, including Pratt&#8217;s CGOL, LISP 2, MLISP, Dylan,
Interlisp&#8217;s Clisp, and McCarthy&#8217;s original M-expressions. All failed
to find acceptance. That community found the correspondence between
programs and data to be much more valuable than expressive syntax. But
the mainstream programming community likes its syntax, so LISP has
never been accepted by the mainstream.&#8221;
</p>

<p>
Now that
this pattern has been identified, new notations can be devised that are
general and homoiconic - avoiding the problems of past efforts.</p>

<p>See
<a href="http://www.dwheeler.com/readable/readable-s-expressions.html">http://www.dwheeler.com/readable/readable-s-expressions.html</a>
for a longer discussion on past efforts.
</p>

<h2>It is impossible to improve on the parentheses given to us by the gods!!</h2>

<p>
Some Lisp developers act as if Lisp notation descended from the gods,
and thus is impossible to improve.
The authors do not agree, and instead believe that Lisp
notation <i>can</i> be improved from the form created in the 1950s.
The following is a summary of a
<a href="http://sourceforge.net/p/readable/wiki/Retort/">retort</a>
to those who believe Lisp notation cannot be improved, based on the
claims in the
<a href="http://www.lispniks.com/faq/faq.html">Common Lisp FAQ</a> and
<a href="http://www.dreamsongs.com/Files/Hopl2.pdf">
&#8220;The Evolution of Lisp&#8221; by Guy Steele and Richard Gabriel</a>.
</p>

<p>
The Common Lisp FAQ says that people <i>&#8220;wonder why Lisp can&#8217;t
use a more &#8216;normal&#8217; syntax.
It&#8217;s not because Lispers have never thought of the idea - indeed,
Lisp was originally intended to have a syntax much like FORTRAN...&#8221;</i>.
But this is not a good argument.
In other words, even Lisp&#8217;s creator (John McCarthy)
understood that directly using s-expressions for Lisp programs was undesirable.
That is strong evidence that traditional s-expression notation has problems;
even Lisp&#8217;s creator thought its notation was poor.
</p>

<p>
<a href="http://www.dreamsongs.com/Files/Hopl2.pdf">
&#8220;The Evolution of Lisp&#8221; by Guy Steele and Richard Gabriel
(HOPL2 edition)</a> says that,
<i>&#8220;The idea of introducing Algol-like syntax into Lisp keeps popping up
and has seldom failed to create enormous controversy between those who
find the universal use of S-expressions a technical advantage (and don&#8217;t
mind the admitted relative clumsiness of S-expressions for numerical
expressions) and those who are certain that algebraic syntax is more
concise, more convenient, or even more natural...&#8221;.</i>
Note that the authors, who are advocates for s-expression notation,
admit that for numerical expressions they are clumsy.
</p>

<p>
It continues,
<i>&#8220;We conjecture that Algol-style syntax has not really caught on in the
Lisp community as a whole for two reasons. First, there are not enough
special symbols to go around. When your domain of discourse is limited
to numbers or characters, there are only so many operations of interest,
and it is not difficult to assign one special character to each and
be done with it. But Lisp has a much richer domain of discourse,
and a Lisp programmer often approaches an application as yet another
exercise in language design; the style typically involves designing new
data structures and new functions to operate on them - perhaps dozens
or hundreds&#8221; and it&#8217;s just too hard to invent that many distinct
symbols (though the APL community certainly has tried). Ultimately
one must always fall back on a general function-call notation; it&#8217;s
just that Lisp programmers don&#8217;t wait until they fail.&#8221;</i>
But this is a failing argument.
Practically all languages allow compound symbols made from multiple
characters, such as &gt;=; there is no shortage of symbols.
Also, nearly all programming languages have a function-call notation, but
only Lisp-based languages choose s-expressions to notate it, so
saying &#8220;we need function call notation&#8221;
do not excuse s-expressions.
You do not need legions of special syntactic constructs;
sweet-expressions allow developers to express anything that can be
expressed with s-expressions, without being tied to a particular
semantic or requiring a massive set of special symbols.
</p>

<p>
Then it said,
<i>
&#8220;Second, and
perhaps more important, Algol-style syntax makes programs look less
like the data structures used to represent them. In a culture where the
ability to manipulate representations of programs is a central paradigm,
a notation that distances the appearance of a program from the appearance
of its representation as data is not likely to be warmly received (and
this was, and is, one of the principal objections to the inclusion
of loop in Common Lisp).&#8221;
</i>
Here Steele and Gabriel are <b>extremely</b> insightful.
Today we would say that s-expressions are &#8220;homoiconic&#8221;,
and that is a rare trait among programming notations.
This property, homoiconicity, is an important reason that
Lisps are still used decades after their development.
</p>
<p>
Steele and Gabriel are absolutely right; there have been many efforts
to create readable Lisp formats, and they all failed because they
did not create formats that accurately represented the programs as
data structures.
The whole point of a Lisp-like language is that
you can treat code as data, and data as code.
Any notation that makes
this difficult means that you lose some of Lisp&#8217;s unique advantages.
Homoiconicity is critical if you&#8217;re going to treat a program as data.
To do so, you must be able to easily &#8220;see&#8221;
the program&#8217;s format.
If you can, you can do amazing manipulations.
</p>
<p>
But what Gabriel and Steele failed to appreciate in their paper is that
it&#8217;s possible to have both.
Now that we understand why past efforts failed, we can devise notations
that keep these key properties (generality and homoiconicity) - and succeed!
</p>

<p>
Many people have noted that there are tools to help deal with s-expressions,
but this misses the point.
If the notation is so bad that you need tools to deal with it,
it would be better to fix the notation.
The resulting notation could be easier to read, and you could focus your
tools on solving problems that were not self-inflicted.
In particular, &#8220;stopping to see the parentheses&#8221; is a sign of a
serious problem - the placement of parentheses fundamentally affects
interpretation, and serious bugs can hide there.
</p>
<p>
Others who have used Lisp for years,
such as <a href="http://www.paulgraham.com/arcll1.html">Paul Graham</a>,
see s-expressions as long-winded, and advocate for the use of
&#8220;abbreviations&#8221; that can map down to an underlying s-expression notation.
Sweet-expressions take this approach.
</p>

<h2>Why are sweet-expressions separate from curly-infix and neoteric-expressions?</h2>
<p>
Some Scheme users and implementors may not want indentation-sensitive
syntax, or may not want to accept any change that could change the
interpretation of a legal (though poorly-formatted) s-expression.
For those users and implementors, SRFI-105 adds
infix support and neoteric-expressions such as <tt>f(x)</tt>.
SRFI-105 makes it easier to describe the &#8220;leaves&#8221; of an
s-expression tree.
</p>
<p>
In contrast, sweet-expressions make it easier to describe the larger
structure of an s-expression, by using indentation (which is usually
present anyway) as syntactically relevant.
However, sweet-expressions can change the interpretation of some
poorly-formatted s-expressions.
We believe that users of sweet-expressions will want the ability to use
SRFI-105 capabilities as well, but do not require implementation the other way.
</p>
<p>
By making sweet-expressions a separate tier,
people can adopt curly-infix if they don&#8217;t
want meaningful indentation.

<h2>Why should indentation be syntactically relevant?</h2>

<p>
Making indentation synactically meaningful eliminates many
parentheses, thus making them more readable, by making indentation
itself meaningful.  Real Lisp programs are already indented,
and tools (like editors and pretty-printers) are used to try to
keep the indentation (used by humans) and parentheses (used by
the computers) in sync.  By making the indentation (which humans
depend on) actually used by the computer, they are automatically
kept in sync, and many parentheses become unnecessary.</p>

<p>The
page <a href="http://www.gregslepak.com/on-lisps-readability"
rel="nofollow">http://www.gregslepak.com/on-lisps-readability</a> shows
one of the many examples of endless closing parentheses and brackets to
close an expression, and the confusion that happens when indentation does
not match the parentheses. bhurt&#8217;s response to that article is telling:
&#8220;I&#8217;m always somewhat amazed by the claim that the parens &#8216;just
disappear&#8217;, as if this is a good thing. Bugs live in the
difference between the code in your head and the code on the
screen - and having the parens in the wrong place causes bugs. And
autoindenting isn&#8217;t the answer- I don&#8217;t want the indenting to follow
the parens, I want the parens to follow the indenting. The indenting
I can see, and can see is correct.&#8221;</p>

<p>An IDE can help keep the
indentation consistent with the parentheses, but <a class="alink notfound"
href="../http%3A//www.recursivity.com/blog/2012/10/28/ides-are-a-language-smell/%20needing%20IDEs%20is%20considered%20by%20some%20a%20language%20smell"></a><a
href="http://www.recursivity.com/blog/2012/10/28/ides-are-a-language-smell/"
rel="nofollow"></a><a
href="http://www.recursivity.com/blog/2012/10/28/ides-are-a-language-smell/"
rel="nofollow">http://www.recursivity.com/blog/2012/10/28/ides-are-a-language-smell/</a>
needing IDEs is considered by some a language smell.  If you need special
tools to work around problems with the notation, then the notation itself
is a problem.</p> <p>A solution, of course, is to make the indentation
actually matter: Now you don&#8217;t need an endless march of parentheses, and
indentation can&#8217;t be confusing because it is actually used.</p>
<p>&#8220;In
praise of mandatory indentation...&#8221; notes that it can be <em>helpful</em>
to have mandatory indentation:</p>
<blockquote> <p>It hurts me to say
that something so shallow as requiring a few extra spaces can have
a bigger effect than, say, Hindley-Milner type inference.
- <a href="http://okasaki.blogspot.com/2008/02/in-praise-of-mandatory-indentation-for.html">Chris Okasaki</a></p>
</blockquote>

<p>Other languages,
including Python, Haskell, Occam, and Icon, use indentation to indicate
structure, so this is a proven idea.  Other recently-developed languages
like <a href="http://cobralang.com/docs/python/" rel="nofollow">Cobra</a>
(a variant of Python with strong compile-time typechecking) have
decided to use indentation too, so clearly indentation-sensitive
languages are considered useful by many.</p>

<p>There&#8217;s a lot of
past work on indentation to represent s-expressions, too.  Examples
include:</p>
<ul>
<li>Paul Graham (developer of Arc) is known to
be an advocate of indentation for this purpose.  As I noted above, <a
href="http://lists.canonical.org/pipermail/kragen-tol/2002-January/000666.html"
rel="nofollow">Kragen Sitaker&#8217;s notes on Graham and Arc</a>
discusses how indentation can really help (in this notation,
functions with no parameters need to be surrounded by parentheses, to
distinguish them from atoms - &#8220;oh well&#8221; ).  Graham&#8217;s <a
href="http://en.wikipedia.org/wiki/RTML" rel="nofollow">RTML</a> is
implemented using Lisp, but uses indentation instead of parentheses to
define structure.  RTML is a proprietary programming language that at
least <em>was</em> used by Yahoo!&#8217;s Yahoo! Store and Yahoo! Site
hosting products (though Yahoo may have transitioning away from it).
See <a href="http://lib.store.yahoo.net/lib/paulgraham/bbnexcerpts.txt"
rel="nofollow">Paul Graham&#8217;s comments
about the RTML language design</a> and <a
href="http://lib.store.yahoo.net/lib/ytimes/rtmlintro.pdf"
rel="nofollow"> this introduction to RTML by Yahoo</a>.</li>
<li><a
href="http://www.accesscom.com/~darius/" rel="nofollow">Darius Bacon&#8217;s
&#8221;indent&#8221; file</a>, includes his own implementation of
a Python/Haskell-like syntax for Scheme using indentation in place
of parentheses, and in that file he also includes Paul D. Fernhout&#8217;s
implementation of an indentation approach.  Bacon&#8217;s syntax for indenting
uses colons in a way that is limiting (it interferes with other uses
of the colon in various Lisp-like languages).</li>
<li><a href="http://www.lispin.org/" rel="nofollow">Lispin</a>
discusses a way to get S-expressions with indentation.</li>
</ul>

<h2 id="srfi-49">What is the relationship with SRFI-49 (I-expressions)?</h2>

<p>The sweet-expression indentation system is based on <a
href="http://srfi.schemers.org/srfi-49/srfi-49.html">Scheme
SRFI-49 (&#8220;surfi-49&#8221;), aka I-expressions</a>.
The basic rules of SRFI-49
(I-expression) indentation are kept in sweet-expressions; these are:</p>
<ul>
<li>An indented line is a parameter of its parent.</li>
<li>Later terms on a line are parameters of the first term.</li>
<li>A line with exactly one term, and no child lines,
is simply that term; multiple terms are wrapped into a list.</li>
</ul>

<p>These basic rules seem quite
intuitive, and seem to be what most people &#8220;expect&#8221;
indentation to mean.
We&#8217;re grateful to the SRFI-49 author for his work, and at first, we just
used SRFI-49 directly.</p>

<p>
However, SRFI-49 turned out to have problems in practice when
we tried to use it seriously.
For example,
in SRFI-49, leading blank lines could produce the empty list <tt>()</tt>
instead of being ignored,
limiting the use of blank lines and leading to easy-to-create errors.
As specified, a SRFI-49 expression would never complete
until after the next expressions&#8217;s first line was entered, making
interactive use extremely unpleasant.
Lines with just spaces and tabs would be considered different from blank
lines, creating another opportunity for difficult-to-find errors.
The symbol <tt>group</tt> is given a special meaning, which is
inconsistent with the rest of Lisp
(where only punctuation has special syntactic meanings).
There were also a number of defects in both its
specification and implementation.
</p>

<p>
Thus, based on experience and experimentation we made several
changes to it.
First, we fixed the problems listed above.
We also addressed supporting other capabilities, namely,
infix notation and allowing formats like <tt>f(x)</tt>.
We also found that certain constructs were somewhat ugly if indentation
is required, so we added SUBLIST and SPLIT capabilities.
</p>

<p>
The very existence of SRFI-49 shows that others believe
there is value in using syntactically-significant indentation.
We are building on the experience of others to create what we hope
is a useful and refined notation.
</p>

<h2>How does this compare with P4P?</h2>

<p>
<a href="http://shriram.github.com/p4p/">
P4P: A Syntax Proposal</a> by Shriram Krishnamurthi
describes an alternative, more readable format for the Racket implementation
of Scheme.
There are some similarities, but many differences.
</p>

<p>
P4P supports functional name-prefixing such as f(x),
just as sweet-expressions do.
However, function parameters are separated by commas
(an extra character not typical in Lisp code, and in our experiments
something of a pain since parameters are very common).
P4P does not support infix notation at all, even though practically
all non-Lisp languages support them.
</p>

<p>
P4P has a very different view of indentation, compared to
sweet-expressions.
In P4P, indentation does not control semantics.
Instead,
&#8220;the semantics controls indentation: that is, each construct has
indentation rules, and the parser enforces them. However, changing the
indentation of a term either leaves the program&#8217;s meaning unchanged
or results in a syntax error; it cannot change the meaning of the
program.&#8221;
</p>

<p>
This means that P4P has a large number of special-case syntactic constructs.
For example, defvar: and deffun: specially use &#8220;=&#8221;,
if: has intermediate keywords, and so on.
While this looks nice when you stay within its set, it encounters
the same problem that McCarthy had with M-expressions: There are always
new constructs, including ones in meta-languages (not the underlying
Scheme implementation) and macros.
The P4P author notes that,
&#8220;it would be easy to add new constructs such as
provide:, test:, defconst: (to distinguish from defvar:), and so on&#8221;,
but this misses the point; the task of defining constructs
inhibits the use of those constructs, and may be impractical
if there are syntactic differences at different language levels.
For example, imagine processing lists where &#8220;deffun&#8221; has a different
definition than the underlying language; this is trivial with
s-expressions and sweet-expressions, but not practical using P4P.
</p>

<p>
The P4P author notes that, &#8220;the parser can be run in a mode where
indentation-checking is simply turned off...
This can be beneficial when dealing with program-generated code.&#8221;
However, now the developer must deal with enabling various modes,
and this mode is needed not just for program-generated code, but for
code that has mixtures of various languages.
Rather than having multiple modes, a single mode that works everywhere
seems more useful to the developers of the sweet-expression notation.
</p>

<p>
In short, P4P fails to be generic; it is tied to specific semantics.
Previous readability efforts, such as M-expressions, failed,
and we believe that one reason was that those notations
failed to be generic.
We applaud the admirable goals of P4P, but do not think it represents
the best way forward.
</p>

<p>
However, while we believe different design choices need to be made,
we applaud the effort.
In addition, we believe that
P4P is additional evidence that people are interested
in improving the readability of Lisp,
and that indentation can help do so.
</p>

<h2 id="blank-lines">Blank lines</h2>

<p>In sweet-expressions, a blank line
always terminates a datum, once an expression has started;
if (another) expression has not started, blank lines are ignored.
Htat means that in a REPL,
once you&#8217;ve entered a complete expression,
&#8220;Enter Enter&#8221; will always end it.
The &#8220;blank
lines at the beginning are ignored&#8221; rule eliminates a usability problem
with the original SRFI-49 (I-expression) spec, in which two sequential
blank lines before an expression surprisingly returned ().
This was a serious usability problem.
The sample
implementation <em>did</em> end expressions on a blank line - the problem
was that the spec didn&#8217;t clearly capture this.</p>

<p>It would be possible
to have blank lines end an expression &#8220;only in interactive use&#8221;.
In particular, Python has different rules for interactive use and files.
does this.  However, this means that you couldn&#8217;t cut-and-paste files into
the interpreter and them used.  David A. Wheeler
believes it&#8217;s important to have exactly
the same syntax in both cases, so
&#8220;Enter Enter&#8221; <em>always</em> ends an expression.</p>

<p>Of course, people sometimes want to have something like
a blank line in the middle of an s-expression.  Thus, comment-only lines
are ignored and not considered blank lines; that means you can use them
for that purpose.  The indentation of comment-only lines is ignored - that
way, you don&#8217;t have to worry about keeping them indented the same way.</p>

<p>Since a line with only indentation may look exactly identical to a
blank line, we decided to clearly state that &#8220;a line with only indentation
is an empty line&#8221;.  This eliminates some nasty usability problems that
could arise if a &#8220;blank&#8221; line
actually had some whitespace in it;
a silent error like this could be hard to debug.</p>

<h2 id="indentation-characters">Indentation characters (! as indent)</h2>
<p>Some
like to use spaces to indent; others like tabs.  Python allows either,
and SRFI-49 allows either as well - you just have to be consistent.
Thus, sweet-expressions are defined so that people can use what they like.
The only rule is that they must be consistent.</p>

<p>One objection that people raise about horizontal
whitespace characters is that they can get lost in many transports
(HTML readers, etc.).
In addition, sometimes there are indented groups that you&#8217;d
like to highlight; traditional whitespace indentation provides no
opportunity to highlight indented groups specially.
When discussing syntax,
users on the readable-discuss mailing list started to use characters
(initially period+space) to show where indentation occurred so that they
wouldn&#8217;t get lost or to highlight them.
Eventually, the idea was hit upon that perhaps sweet-expressions
needed to support a <em>non-whitespace</em> character for indentation.
This is highly unorthodox, but at a stroke it eliminates the complaints
some have about syntactically-important indentation (because it is
lost by some transports), and it also provides an
easy way to highlight particular indented groups.</p>

<p>At first, we tried
to use period, or period+space, as the indent, as this was vaguely
similar to its use in some tables of contents.
But period has too many
other traditional meanings in Lisp-like languages, including beginning
a number (.9), beginning a symbol (.xyz), and as a special operator to
set the cdr of a list.
Implementation of period as an indent character
is much easier if there is a way to perform two-character lookahead
(e.g., with an unread-char function),
but this is not standard in Scheme R5RS.
Eventually the &#8220;!&#8221; was selected instead; it
practically never begins a line, and if you need it, {!...} will work.
The exclamation point is much easier to implement as an indent character,
and it is also a great character for highlighting indented groups.</p>

<h2 id="disabling-indentation-processing-with-paired-characters">Disabling
indentation processing with paired characters</h2>

<p>Indentation
processing is disabled inside (...), [ ... ], and { ... }.
This was also true
of SRFI-49, and of Python, and has wonderful side-effects:</p> <ul>
<li>Indent parsing becomes very safe to use with existing code.
Pre-existing code will almost certainly start each expression with
an opening parenthesis, disabling the indentation processing it
wasn&#8217;t expecting.</li>
<li>It makes it easy to disable indentation
processing whenever it is inconvenient.  For example, it supports
dealing with text that is very close to running off the right-hand
side, or is complex to express with indentation.</li>
<li>It is similar to what other indentation-sensitive languages do, such
as Python.</li>
<li>It is a very easy rule to explain.</li>
</ul>

<p>This means that infix processing by curly-infix disables indentation
processing; in practice this doesn&#8217;t seem to be a problem.</p>

<h2 id="disabling-indentation-processing-with-an-initial-indent">Disabling
indentation processing with an initial indent</h2>

<p>Initial indentation also disables indentation processing,
which also improves backward
compatibility and makes it easy to disable indentation processing where
convenient.</p>

<p>This improves backward compatibility because a program
that uses odd formatting with a different meaning for sweet-expressions
is more likely to have initial indents.
Even if this is not
true, it&#8217;s trivially easy to add an initial indent on oddly-formatted
old files. This provides a trivial escape, making it easy to support
old files.  Then even if you have ancient code with odd formatting,
it would be likely to still &#8220;just work&#8221;
if there is any initial indentation.
We&#8217;d like this reader to be a drop-in replacement for read(),
so minimizing incompatibilities is important.</p>

<p>There is a risk that this
indentation will be accidental (e.g., a user might enter a blank line in
the middle of a routine and then start the next line indented).  However,
this is less likely to happen interactively (users can typically see
something happened immediately), and editors can easily detect and show
where surprising indentation is occurring (e.g., through highlighting),
so this risk appears to be minimal.</p>

<p>Disabling on initial indent
also deals with a subtle potential problem in implementation.
In a reader implementation, if we tried to just accept some indentation
of the first line and use it as the starting point, we create problems.
Typically readers return a whole value once that value has been
determined, and in many cases it&#8217;s tricky to store state (such as that
new indentation value) for an arbitrary port.  By disabling indentation
processing, we eliminate the need to store such state, as well as giving
users a useful tool.</p>

<p>Since this latter point isn&#8217;t obvious, here&#8217;s
a little more detailed explanation.  Obviously, to make indentation
syntactically meaningful, you need to know where an expression indents,
and where it ends. If you read in a line, and it has the same indentation
level, that should end the previous expression. If its indentation is
<em>less</em>, it should close out all the lines with deeper or equal
indentation.  But we&#8217;re trying to <em>minimize</em> the changes to the
underlying language, and in particular, we don&#8217;t want to change the &#8220;read&#8221;
interface and we&#8217;re not assuming arbitrary amounts of unread-char.
Scheme R5RS, for example, doesn&#8217;t have a standard unread-char
at all.  So let&#8217;s say you are trying to read the following:</p>
<pre>
! ! foo
! ! ! bar
! ! eggs
! ! cheese
</pre>
<p>You might expect this to
return three datums: (foo bar), eggs, and cheese. It won&#8217;t, in a typical
implementation; here&#8217;s why:
<ul>
<li>
In the first read(), it reads foo, bar, and it
consumes the indentation of &#8220;eggs&#8221; so that it can determine that another
is at the same level. It returns (foo bar).</li>
<li>In the second read(), it reads
eggs with NO indentation, because the indentation was consumed by the
first read() so it could determine when it was finished. It then reads
the indentation of cheese, which has an indentation more than zero. It
returns (eggs cheese), and we&#8217;ve consumed it all.</li>
</ul>

<p>Some solutions:</p>
<ul>
<li>If you have unlimited unread-char, there is no problem, just
unconsume characters once you&#8217;ve found the end. But many Lisps don&#8217;t have
that.</li>
<li>Read could store indentation state associated with the
port. But the user could call other routines, and a naive implementation
would read the wrong values. You&#8217;d have to re-wrap the entire I/O system
if you really wanted to be able to undo the indentation reliably. That
creates a complicated implementation that is likely to be unreliable,
and it&#8217;s lousy for performance.</li>
</ul>
<p>So for all the reasons
above, initial indent disables indentation processing for that line.</p>

<h2 id="grouping-and-splicing">Grouping and splicing (\\)</h2>
<p>SFRI-49
had a mechanism for defining lists of lists, using the symbol &#8220;group&#8221;.
This was a valuable contribution, since there needs to be <em>some</em>
way to show lists of lists.  But after use, it was determined that having
an alphabetic symbol being used to indicate a special abbreviation was
a mistake; all other abbreviations use punctuation, and this should too.
This symbol is called the GROUP symbol, and happens at the start of a line
(after indentation).</p>
<p>A different problem is that sometimes you&#8217;d
like to have a set of parameters, where they are at the &#8220;same level&#8221; but
writing them as indented parameters takes up too much vertical space.
An obvious example is keywords in various Lisps; having to write this
is painful:
</p>
<pre>
foo
  keyword1:
  parameter1
  keyword2:
  parameter2
  ....
</pre>
<p>
David A. Wheeler created an early splicing proposal. After much discussion, to solve the latter problem, the SPLIT symbol was created, so that you could do:
</p>
<pre>
foo
  keyword1: \\ parameter1
  keyword2: \\ parameter2
  ....
</pre>

<p>At first the symbol \ was used for SPLIT, but this
would cause serious problem on Lisps that supported slashification.
After long discussion, the symbol \\ was decided on for both; although
the number of characters in the underlying symbol could vary (depending on
whether or not slashification was used), this was irrelevant and seemed to
work everywhere.  By using the same symbol for both GTROUP and SPLIT, we
reduced the number of different symbols that users needed to escape.</p>

<p>We dropped the SRFI-49 method for escaping the symbol by repeating
it (group group); the {} escape mechanism is more regular, and
makes it far more obvious that some special escape is going on.</p>

<h2
id="why-does-initial-group-mean-nothing-if-there-are-datums-afterwards-on-the-same-line">Why
does initial \\ mean nothing if there are datums afterwards
on the same line?</h2>
<p>Since &#8220;let&#8221; occurs in many programs,
it would have been possible to define \\ to allow this:</p>
<pre>
let
! \\ var1 $ bar x
! !  var2 $ quux x
! nitz var1 var2
</pre>
<p>
We discussed this, but after long discussion we decided on a defined semantic that means that &#8220;\\&#8221; is an empty symbol, making that expression exactly the same as:
</p>
<pre>
let
! var1 $ bar x
! !  var2 $ quux x
! nitz var1 var2
</pre>

<p>We did this
intentionally.  It turns out that there are situations where you want a \\
as an empty symbol, even when text follows it on the line.  An example is
arc&#8217;s if-then-else, where there are <em>logically</em> pairs of items,
but from a <em>list</em> semantic are at the same level. E.G.:</p>
<pre>
if
! condition1()
! \\ action1()
! condition2()
! \\ action2()
! \\ otherwise-action()
</pre>
<p>It&#8217;s easy to handle let* with an extra line, but there&#8217;s
no easy way to insert a short pseudo-comment character in the front unless
we do it this way.</p>
<p>The multi-line nature of let* turns out to be
not a real problem, for 2 reasons:</p>
<ol>
<li>It turns out that in many
&#8220;let*s&#8221; the variable settings can be put on one line. As of 2012-08-02 the
&#8220;sweeten.sscm&#8221; has 305 non-blank, non-comment lines
(as determined by <tt>grep -v '^$' sweeten.sscm | grep -v '^ *;' | wc -l</tt>).
Of those, 13 lines use let or let*, and only one of those &#8220;lets&#8221; uses \\.
It&#8217;s not worth optimizing a case that only happens approximately once in
300 lines.</li>
<li>
Using the abbreviations as intended is REALLY
clear, even though it uses an extra vertical line.
</li>
</ol>
<p>So the savings for <em>let</em> aren&#8217;t significant, the
semantics as designed are clear, and are intentionally using that
notation for another purpose where it&#8217;s not as easy to use an
alternative.</p>

<h2 id="traditional-abbreviations">Traditional abbreviations</h2>

<p>As with SRFI-49, a leading traditional
abbreviation (quote, comma, backquote, or comma-at), followed by space
or tab, is that operator applied to the sweet-expression starting at the
same line.
This makes it easy to abbreviations to complex indented structures.
For example, a complex indented structure can be
quoted simply by prefixing a single quote and space.</p>

<h2 id="sublist">Sublist ($)</h2>

<p>Alan Manuel Gloria
noted that certain constructs were common and annoying to express,
e.g., first(second(third(fourth))), and based on Haskell experience,
suggested being able to write them as first $ second $ third(fourth).
Again, the idea is that this is an abbreviation for a common-enough
practice.</p>

<p>This is another example (like GROUP/SPLIT) of a
construct that, when you need it, is incredibly useful.
It&#8217;s not
all that unusual to have a few processing or cleanup functions that
take a single argument, and for all the &#8220;real work&#8221; to be nested
in something else.
This would require several levels of indentation
without sublist, but they are easily handled with sublist.
</p>
<p>
An example is
scsh, which has functions like &#8220;run&#8221; that another list.  With sublist,
this is easily expressed.  For example, here&#8217;s a sweet-expression using
scsh:
<pre>
  run $ grep -i "xx.*zz" &lt;(oldfile) &gt;(newfile)
</pre>


<p>After discussion, sublist was accepted in July 2012.</p>

<h2>Markers &lt;* and *&gt;</h2>
<p>
The markers &lt;* and *&gt; are reserved for future use.
These may, at some point, have the following syntax
as described in an
<a href="http://www.mail-archive.com/readable-discuss@lists.sourceforge.net/msg00806.html">email posted 2012-09-02</a>:

<blockquote>
<i>
&lt;* ... *&gt; are like ( ... ) in that they surround a list,
but they do NOT turn 
off indentation processing.
A &#8220;&lt;*&#8221; resets the &#8220;indent&#8221; level to a 0-length 
string, skips all horizontal whitespace, and then restarts reading an 
expression with indentation processing still live.
A blank line inside &lt;* ... 
*&gt; ends an expression WITHIN the &lt;* ... *&gt;,
but stays within &lt;* ... *&gt;; only 
eof or active *&gt; can close the &lt;*.
Once all that mapping is done, the range of 
&lt;* ... *&gt; is replaced with the mapped result.
</i>
</blockquote>

<p>
These markers may be very useful in the future, e.g., for let expressions.
However, we have not included them at this time, because
these markers can complicate processing.
Other markers can be read and handled with one-character lookahead, and
cause a simple return in some cases.
However, processing the closing *&gt; requires potentially a return up
multiple levels, which requires a different implementation approach than
is otherwise required.
It is also unclear that this is really necessary, and we are hesistant
to add yet more syntax beyond the <tt>$</tt> and <tt>\\</tt> markers.
</p>

<p>
Thus, the symbols <tt>&lt;*</tt> and <tt>*&gt;</tt>
must be escaped (e.g., using {...}) if they are used in an
indentation-processing context.
</p>


<h2 id="alternative-q2">Comparison to Q2</h2>
<p>An interesting
experimental notation, &#8220;Q2&#8221;, was developed by Per Bothner; see
<a href="http://per.bothner.com/blog/2010/Q2-extensible-syntax/"
rel="nofollow">http://per.bothner.com/blog/2010/Q2-extensible-syntax/</a>.
</p>
<p>Q2 has somewhat similar goals to the &#8220;readable&#8221; project, though
with a different approach. The big difference is that David A. Wheeler
decided it was important to have a generic notation for <em>any</em>
s-expression. Here is a brief additional comparison:</p>
<ul>
<li>Sweet-expressions have infix, though not built-in precedence
(precedence can be implemented by defining <tt>$nfx$</tt>).
</li>
<li>Both have &#8220;juxtaposition for function application&#8221;</li>
<li>Q2 has
&#8220;Naming a zero-argument function applies it&#8221; but this is awkward, indeed,
&#8220;The exact rule for a distinguishing between a variable reference
and a zero-argument function application isn&#8217;t decided yet.&#8221; In
sweet-expressions, a zero-argument function name is called by adding
() after it or around it, e.g., pi().</li>
<li>&#8220;Flexible token format&#8221;
- both require operators to be delimited.</li>
<li>&#8220;Use indentation
for grouping&#8221; - both use indentation for grouping</li>
<li>&#8220;Block
expressions yield multiple values&#8221; - In sweet-expressions, you use
usual Scheme procedures, including value, instead of having special
syntax.</li>
<li>REPL: In sweet-expressions, you usually end a line
with ENTER ENTER. Q2 doesn&#8217;t, but Wheeler worries that you have to be careful
or it&#8217;ll end where it syntactically might not need to.</li>
</ul>

<h2 id="writing-out-results">Writing out results</h2>
<p>An obvious question
is, &#8220;how do you write them out?&#8221;  After all, with these notations there is
more than one way to present expressions.</p>

<p>But no Lisp guarantees
that what it writes out is the same sequence of characters that was
written.  For example, <tt>(quote&nbsp;x)</tt>
when read might be written back
as <tt>'x</tt>, while on others, reading
<tt>'y</tt> might be printed as <tt>(quote&nbsp;y)</tt>.
Similarly, if you enter <tt>(a&nbsp;.&nbsp;(b&nbsp;.&nbsp;()))</tt>,
many Lisps will write that back as &#8220;(a&nbsp;b)&#8221;.
Nothing has fundamentally changed;
as always, you should implement your Lisp expression writer so that
it presents a format convenient to both human and machine readers.</p>

<h2 id="backwards-compatibility">Backwards compatibility</h1>
<p>Backwards compatibility with traditional Lisp notation is helpful.
These notations are fully compatible with <em>well-formatted</em> Lisp
s-expressions.
</p>
<p>
Neoteric-expressions
are compatible for what I&#8217;d call &#8220;normal&#8221; formatting.  The key issue is
that it changes the meaning of an opening paren after a character other
than whitespace or another opening paren.  So if you&#8217;re using to saving
whitespace that will be different.  Basically, a(b) becomes
the single expressions &#8220;(a&nbsp;b)&#8221;,
not the two expressions &#8220;a&#8221; followed later by &#8220;(b)&#8221;.
There are millions of lines of Lisp code that would never
see the difference.  So if you wrote &#8220;a(b)&#8221; expecting it to be &#8220;a&nbsp;(b)&#8221;,
you will need to insert the space.
</p>
<p>
Sweet-expressions add
indentation processing, but since indentation is disabled inside (...),
and initial indentation also disables indentation processing,
ordinary Lisp expressions immediately disable indentation processing and
typically don&#8217;t cause issues.
In rare cicumstances they can be intepreted differently:
</p>
<ul>
<li>If you have a <em>top-level</em> expression
when more than one datum on a line <em>and</em> the line doesn&#8217;t begin
with space/tab.  Thus, at the topmost level, &#8220;(a) (b)&#8221; on one line
is interpreted as two datums &#8220;(a)&#8221; followed by &#8220;(b)&#8221; in traditional
Lisp, but this is a single &#8220;((a) (b))&#8221; in sweet-expressions.</li>
<li>Sweet-expressions also count &#8220;!&#8221; at the beginning of a line as
an indent character.  This rarely causes any issue, since once you
use an open parenthesis to start an expression, this meaning for
&#8220;!&#8221; is disabled.  Generally, you&#8217;d have to have a symbol whose name
<em>starts</em> with &#8220;!&#8221; before any issue could come up.</li>
</ul>
<p>
In any case, you
can disable sweet-expression processing with a space indent, so just
inserting a space on every line <em>ensures</em> compatibility with the
sweet-expression indentation processing.</p>


<h2>Past experiences</h2>
<p>
At least two programs have been written using sweet-expressions:
<ul>
<li><a href="http://readable.sourceforge.net"><i>sweeten</i></a>
by David A. Wheeler is
a program that reads traditionally-formatted
s-expressions and writes sweet-expressions.
This program performs a great deal of traditional list processing, and
is part of the &#8220;readable&#8221; project&#8217;s git repository.
</li>
<li><a href="https://github.com/AmkG/letterfall"><i>letterfall</i></a>
by Alan Manuel K. Gloria is a graphical
real-time touch typing game to improve typing skills, which uses
GNOME libraries.
</li>
</ul>
<p>
The SRFI authors believe that the existence of these programs -
written by two different people for different application areas -
shows that sweet-expressions are mature enough to be standardized.
</p>
<p>
The <a href="http://readable.sourceforge.net">Readable Lisp S-expressions Project</a> developed these notations and implementations of them.
In particular, the project distributes the programs
<i>unsweeten</i> (which takes sweet-expressions and transforms them
into s-expressions) and
<i>sweeten</i> (which takes s-expressions and transforms them into
sweet-expressions), as well as other related tools.

<h1><a name="reference-implementation">Reference implementation</a></h1>
<p>
??? TODO
</p>

<p>The implementation below is portable, with the exception that
Scheme provides no standard mechanism to override the built-in reader.
An implementation that complies with this SRFI must
at least activate this behavior
when they read the <code>#!sweet</code> marker
followed by whitespace.
</p>
<p>This reference implementation is SRFI type 2: &#8220;A
mostly-portable solution that uses some kind of hooks provided in
some Scheme interpreter/compiler. In this case, a detailed
specification of the hooks must be included so that the SRFI is
self-contained.&#8221;</p>
<p>For clarity, this is split into two parts:
(1) code that implements the SRFI, and (2) a demo (with support procedures)
to show its use.
This SRFI is trivial to implement, so most of the code is actually in
part 2.
</p>
<h2>Key code to implement this SRFI</h2>
<pre>
  ; ------------------------------
  ; Curly-infix support procedures
  ; ------------------------------

  ; Return true if lyst has an even # of parameters, and the (alternating)
  ; first parameters are "op".  Used to determine if a longer lyst is infix.
  ; If passed empty list, returns true (so recursion works correctly).
  (define (even-and-op-prefix? op lyst)
    (cond
      ((null? lyst) #t)
      ((not (pair? lyst)) #f)
      ((not (equal? op (car lyst))) #f) ; fail - operators not the same
      ((not (pair? (cdr lyst)))  #f) ; Wrong # of parameters or improper
      (#t   (even-and-op-prefix? op (cddr lyst))))) ; recurse.

  ; Return true if the lyst is in simple infix format
  ; (and thus should be reordered at read time).
  (define (simple-infix-list? lyst)
    (and
      (pair? lyst)           ; Must have list;  '() doesn't count.
      (pair? (cdr lyst))     ; Must have a second argument.
      (pair? (cddr lyst))    ; Must have a third argument (we check it
                             ; this way for performance)
      (even-and-op-prefix? (cadr lyst) (cdr lyst)))) ; true if rest is simple

  ; Return alternating parameters in a lyst (1st, 3rd, 5th, etc.)
  (define (alternating-parameters lyst)
    (if (or (null? lyst) (null? (cdr lyst)))
      lyst
      (cons (car lyst) (alternating-parameters (cddr lyst)))))

  ; Not a simple infix list - transform it.  Written as a separate procedure
  ; so that future experiments or SRFIs can easily replace just this piece.
  (define (transform-mixed-infix lyst)
     (cons '$nfx$ lyst))

  ; Given curly-infix lyst, map it to its final internal format.
  (define (process-curly lyst)
    (cond
     ((not (pair? lyst)) lyst) ; E.G., map {} to ().
     ((null? (cdr lyst)) ; Map {a} to a.
       (car lyst))
     ((and (pair? (cdr lyst)) (null? (cddr lyst))) ; Map {a b} to (a b).
       lyst)
     ((simple-infix-list? lyst) ; Map {a OP b [OP c...]} to (OP a b [c...])
       (cons (cadr lyst) (alternating-parameters lyst)))
     (#t  (transform-mixed-infix lyst))))


  ; ------------------------------------------------
  ; Key procedures to implement neoteric-expressions
  ; ------------------------------------------------

  ; Read the "inside" of a list until its matching stop-char, returning list.
  ; stop-char needs to be closing paren, closing bracket, or closing brace.
  ; This is like read-delimited-list of Common Lisp.
  ; This implements a useful extension: (. b) returns b.
  (define (my-read-delimited-list my-read stop-char port)
    (let*
      ((c   (peek-char port)))
      (cond
        ((eof-object? c) (read-error "EOF in middle of list") '())
        ((eqv? c #\;)
          (consume-to-eol port)
          (my-read-delimited-list my-read stop-char port))
        ((my-char-whitespace? c)
          (read-char port)
          (my-read-delimited-list my-read stop-char port))
        ((char=? c stop-char)
          (read-char port)
          '())
        ((or (eq? c #\)) (eq? c #\]) (eq? c #\}))
          (read-char port)
          (read-error "Bad closing character"))
        (#t
          (let ((datum (my-read port)))
            (cond
               ((eq? datum '.)
                 (let ((datum2 (my-read port)))
                   (consume-whitespace port)
                   (cond
                     ((eof-object? datum2)
                      (read-error "Early eof in (... .)\n")
                      '())
                     ((not (eqv? (peek-char port) stop-char))
                      (read-error "Bad closing character after . datum"))
                     (#t
                       (read-char port)
                       datum2))))
               (#t
                   (cons datum
                     (my-read-delimited-list my-read stop-char port)))))))))


  ; Implement neoteric-expression's prefixed (), [], and {}.
  ; At this point, we have just finished reading some expression, which
  ; MIGHT be a prefix of some longer expression.  Examine the next
  ; character to be consumed; if it's an opening paren, bracket, or brace,
  ; then the expression "prefix" is actually a prefix.
  ; Otherwise, just return the prefix and do not consume that next char.
  ; This recurses, to handle formats like f(x)(y).
  (define (neoteric-process-tail port prefix)
      (let* ((c (peek-char port)))
        (cond
          ((eof-object? c) prefix)
          ((char=? c #\( ) ; Implement f(x)
            (read-char port)
            (neoteric-process-tail port
                (cons prefix (my-read-delimited-list neoteric-read-real #\) port))))
          ((char=? c #\[ )  ; Implement f[x]
            (read-char port)
            (neoteric-process-tail port
                  (cons '$bracket-apply$
                    (cons prefix
                      (my-read-delimited-list neoteric-read-real #\] port)))))
          ((char=? c #\{ )  ; Implement f{x}
            (read-char port)
            (neoteric-process-tail port
              (let ((tail (process-curly
                      (my-read-delimited-list neoteric-read-real #\} port))))
                (if (eqv? tail '())
                  (list prefix) ; Map f{} to (f), not (f ()).
                  (list prefix tail)))))
          (#t prefix))))


  ; To implement neoteric-expressions, modify the reader so
  ; that [] and {} are also delimiters, and make the reader do this:
  ; (let* ((prefix
  ;           read-expression-as-usual
  ;       ))
  ;   (if (eof-object? prefix)
  ;     prefix
  ;     (neoteric-process-tail port prefix)))

  ; Modify the main reader so that [] and {} are also delimiters, and so
  ; that when #\{ is detected, read using my-read-delimited-list
  ; any list from that port until its matching #\}, then process
  ; that list with "process-curly", like this:
  ;   (process-curly (my-read-delimited-list #\} port))

</pre>

<h2>Demo code</h2>

<pre>
  ; ------------------------------------------------
  ; Demo procedures to implement curly-infix and neoteric readers
  ; ------------------------------------------------

  ; This implements an entire reader, as a demonstration, but if you can
  ; update your existing reader you should just update that instead.
  ; This is a simple R5RS reader, with a few minor (common) extensions.
  ; The "my-read" is called if it has to recurse.
  (define (underlying-read my-read port)
    (let* ((c (peek-char port)))
      (cond
        ((eof-object? c) c)
        ((char=? c #\;)
          (consume-to-eol port)
          (my-read port))
        ((my-char-whitespace? c)
          (read-char port)
          (my-read port))
        ((char=? c #\( )
          (read-char port)
          (my-read-delimited-list my-read #\) port))
        ((char=? c #\[ )
          (read-char port)
          (my-read-delimited-list my-read #\] port))
        ((char=? c #\{ )
          (read-char port)
          (process-curly
            (my-read-delimited-list neoteric-read-real #\} port)))
        ; Handle missing (, [, { :
        ((char=? c #\) )
          (read-char port)
          (read-error "Closing parenthesis without opening")
          (my-read port))
        ((char=? c #\] )
          (read-char port)
          (read-error "Closing bracket without opening")
          (my-read port))
        ((char=? c #\} )
          (read-char port)
          (read-error "Closing brace without opening")
          (my-read port))
        ((char=? c #\") ; Strings are delimited by ", so can call directly
          (default-scheme-read port))
        ((char=? c #\')
          (read-char port)
          (list 'quote (my-read port)))
        ((char=? c #\`)
          (read-char port)
          (list 'quasiquote (my-read port)))
        ((char=? c #\,)
          (read-char port)
            (cond
              ((char=? #\@ (peek-char port))
                (read-char port)
                (list 'unquote-splicing (my-read port)))
              (#t
                (list 'unquote (my-read port)))))
        ((ismember? c digits) ; Initial digit.
          (read-number port '()))
        ((char=? c #\#) (process-sharp my-read port))
        ((char=? c #\.) (process-period port))
        ((or (char=? c #\+) (char=? c #\-))  ; Initial + or -
          (read-char port)
          (if (ismember? (peek-char port) digits)
            (read-number port (list c))
            (string->symbol (fold-case-maybe port
              (list->string (cons c
                (read-until-delim port neoteric-delimiters)))))))
        (#t ; Nothing else.  Must be a symbol start.
          (string->symbol (fold-case-maybe port
            (list->string
              (read-until-delim port neoteric-delimiters))))))))

  (define (curly-infix-read-real port)
    (underlying-read curly-infix-read-real port))

  (define (curly-infix-read . port)
    (if (null? port)
      (curly-infix-read-real (current-input-port))
      (curly-infix-read-real (car port))))

  ; Here's a real neoteric reader.
  ; The key part is that it implements [] and {} as delimiters, and
  ; after it reads in some datum (the "prefix"), it calls
  ; neoteric-process-tail to see if there's a "tail".
  (define (neoteric-read-real port)
    (let* ((prefix (underlying-read neoteric-read-real port)))
      (if (eof-object? prefix)
        prefix
        (neoteric-process-tail port prefix))))

  (define (neoteric-read . port)
    (if (null? port)
      (neoteric-read-real (current-input-port))
      (neoteric-read-real (car port))))


  ; ------------------
  ; Support procedures
  ; ------------------

  (define digits '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))
  (define linefeed (integer->char #x000A))        ; #\newline aka \n.
  (define carriage-return (integer->char #x000D)) ; \r.
  (define tab (integer->char #x0009))
  (define line-tab (integer->char #x000b))
  (define form-feed (integer->char #x000c))
  (define line-ending-chars (list linefeed carriage-return))
  (define whitespace-chars
    (list tab linefeed line-tab form-feed carriage-return #\space))

  ; Should we fold case of symbols by default?
  ; #f means case-sensitive (R6RS); #t means case-insensitive (R5RS).
  ; Here we'll set it to be case-sensitive, which is consistent with R6RS
  ; and guile, but NOT with R5RS.  Most people won't notice, I
  ; _like_ case-sensitivity, and the latest spec is case-sensitive,
  ; so let's start with #f (case-sensitive).
  ; This doesn't affect character names; as an extension,
  ; we always accept arbitrary case for them, e.g., #\newline or #\NEWLINE.
  (define foldcase-default #f)

  ; Returns a true value (not necessarily #t) if char ends a line.
  (define (char-line-ending? char) (memq char line-ending-chars))

  ; Returns true if item is member of lyst, else false.
  (define (ismember? item lyst)
     (pair? (member item lyst)))

  ; Create own version, in case underlying implementation omits some.
  (define (my-char-whitespace? c)
    (or (char-whitespace? c) (ismember? c whitespace-chars)))

  ; If fold-case is active on this port, return string "s" in folded case.
  ; Otherwise, just return "s".  This is needed to support our
  ; foldcase-default configuration value when processing symbols.
  ; The "string-foldcase" procedure isn't everywhere,
  ; so we use "string-downcase".
  (define (fold-case-maybe port s)
    (if foldcase-default
      (string-downcase s)
      s))

  (define (consume-to-eol port)
    ; Consume every non-eol character in the current line.
    ; End on EOF or end-of-line char.
    ; Do NOT consume the end-of-line character(s).
    (let ((c (peek-char port)))
      (cond
        ((not (or (eof-object? c)
                  (char-line-ending? c)))
          (read-char port)
          (consume-to-eol port)))))

  (define (consume-whitespace port)
    (let ((char (peek-char port)))
      (cond
        ((eof-object? char) char)
        ((eqv? char #\;)
          (consume-to-eol port)
          (consume-whitespace port))
        ((my-char-whitespace? char)
          (read-char port)
          (consume-whitespace port)))))

  ; Identifying the list of delimiter characters is harder than you'd think.
  ; This list is based on R6RS section 4.2.1, while adding [] and {},
  ; but removing "#" from the delimiter set.
  ; NOTE: R6RS has "#" has a delimiter.  However, R5RS does not, and
  ; R7RS probably will not - http://trac.sacrideo.us/wg/wiki/WG1Ballot3Results
  ; shows a strong vote AGAINST "#" being a delimiter.
  ; Having the "#" as a delimiter means that you cannot have "#" embedded
  ; in a symbol name, which hurts backwards compatibility, and it also
  ; breaks implementations like Chicken (has many such identifiers) and
  ; Gambit (which uses this as a namespace separator).
  ; Thus, this list does NOT have "#" as a delimiter, contravening R6RS
  ; (but consistent with R5RS, probably R7RS, and several implementations).
  ; Also - R7RS draft 6 has "|" as delimiter, but we currently don't.
  (define neoteric-delimiters
     (append (list #\( #\) #\[ #\] #\{ #\}  ; Add [] {}
                   #\" #\;)                 ; Could add #\# or #\|
             whitespace-chars))

  (define (read-until-delim port delims)
    ; Read characters until eof or a character in "delims" is seen.
    ; Do not consume the eof or delimiter.
    ; Returns the list of chars that were read.
    (let ((c (peek-char port)))
      (cond
         ((eof-object? c) '())
         ((ismember? c delims) '())
         (#t (cons (read-char port) (read-until-delim port delims))))))

  (define (read-error message)
    (display "Error: ")
    (display message)
    (display "\n")
    '())

  (define (read-number port starting-lyst)
    (string->number (list->string
      (append starting-lyst
        (read-until-delim port neoteric-delimiters)))))

  ; detect #| or |#
  (define (nest-comment port)
    (let ((c (read-char port)))
      (cond
        ((eof-object? c))
        ((char=? c #\|)
          (let ((c2 (peek-char port)))
            (if (char=? c2 #\#)
                (read-char port)
                (nest-comment port))))
        ((char=? c #\#)
          (let ((c2 (peek-char port)))
            (if (char=? c2 #\|)
                (begin
                  (read-char port)
                  (nest-comment port)))
            (nest-comment port)))
        (#t
          (nest-comment port)))))

  (define (process-sharp my-read port)
    ; We've peeked a # character.  Returns what it represents.
    (read-char port) ; Remove #
    (cond
      ((eof-object? (peek-char port)) (peek-char port)) ; If eof, return eof.
      (#t
        ; Not EOF. Read in the next character, and start acting on it.
        (let ((c (read-char port)))
          (cond
            ((char-ci=? c #\t)  #t)
            ((char-ci=? c #\f)  #f)
            ((ismember? c '(#\i #\e #\b #\o #\d #\x
                            #\I #\E #\B #\O #\D #\X))
              (read-number port (list #\# (char-downcase c))))
            ((char=? c #\( )  ; Vector.
              (list->vector (my-read-delimited-list my-read #\) port)))
            ((char=? c #\\) (process-char port))
            ; This supports SRFI-30 #|...|#
            ((char=? c #\|) (nest-comment port) (my-read port))
            ; If #!xyz, consume xyz and recurse.
            ; In a real reader, consider handling "#! whitespace" per SRFI-22,
            ; and consider "#!" followed by / or . as a comment until "!#".
            ((char=? c #\!) (my-read port) (my-read port))
            (#t (read-error "Unsupported # extension")))))))

  (define (process-period port)
    ; We've peeked a period character.  Returns what it represents.
    (read-char port) ; Remove .
    (let ((c (peek-char port)))
      (cond
        ((eof-object? c) '.) ; period eof; return period.
        ((ismember? c digits)
          (read-number port (list #\.)))  ; period digit - it's a number.
        (#t
          ; At this point, Scheme only requires support for "." or "...".
          ; As an extension we can support them all.
          (string->symbol
            (fold-case-maybe port
              (list->string (cons #\.
                (read-until-delim port neoteric-delimiters)))))))))

  (define (process-char port)
    ; We've read #\ - returns what it represents.
    (cond
      ((eof-object? (peek-char port)) (peek-char port))
      (#t
        ; Not EOF. Read in the next character, and start acting on it.
        (let ((c (read-char port))
              (rest (read-until-delim port neoteric-delimiters)))
          (cond
            ((null? rest) c) ; only one char after #\ - so that's it!
            (#t
              (let ((rest-string (list->string (cons c rest))))
                (cond
                  ; Implement R6RS character names, see R6RS section 4.2.6.
                  ; As an extension, we will ALWAYS accept character names
                  ; of any case, no matter what the case-folding value is.
                  ((string-ci=? rest-string "space") #\space)
                  ((string-ci=? rest-string "newline") #\newline)
                  ((string-ci=? rest-string "tab") tab)
                  ((string-ci=? rest-string "nul") (integer->char #x0000))
                  ((string-ci=? rest-string "alarm") (integer->char #x0007))
                  ((string-ci=? rest-string "backspace") (integer->char #x0008))
                  ((string-ci=? rest-string "linefeed") (integer->char #x000A))
                  ((string-ci=? rest-string "vtab") (integer->char #x000B))
                  ((string-ci=? rest-string "page") (integer->char #x000C))
                  ((string-ci=? rest-string "return") (integer->char #x000D))
                  ((string-ci=? rest-string "esc") (integer->char #x001B))
                  ((string-ci=? rest-string "delete") (integer->char #x007F))
                  ; Additional character names as extensions:
                  ((string-ci=? rest-string "ht") tab)
                  ((string-ci=? rest-string "cr") (integer->char #x000d))
                  ((string-ci=? rest-string "bs") (integer->char #x0008))
                  (#t (read-error "Invalid character name"))))))))))


  ; Record the original read location, in case it's changed later:
  (define default-scheme-read read)

  ; --------------
  ; Demo of reader
  ; --------------

  ; repeatedly read in curly-infix and write traditional s-expression.
  (define (process-input)
    (let ((result (curly-infix-read)))
      (cond
        ((not (eof-object? result))
          (write result)
          (display "\n")
          ; (force-output) ; flush, so can interactively control something else
          (process-input)))))

  (process-input)
</pre>

<h1><a name="references">References</a></h1>
<p>The readable project website has more information: <a href=
"http://readable.sourceforge.net">http://readable.sourceforge.net</a></p>

<h1><a name="acknowledgments">Acknowledgments</a></h1>
<p>
??? TODO
</p>

<p>We thank all the participants on the &#8220;readable-discuss&#8221;
and &#8220;SRFI-105&#8221; mailing lists,
including John Cowan, Shiro Kawai, Per Bothner, Mark H. Weaver,
and many others whose names
should be here but aren&#8217;t.</p>

<h1><a name="copyright">Copyright</a></h1>
<p>Copyright (C) 2012 <a href="http://www.dwheeler.com">David A. Wheeler</a>
and Alan Manuel K. Gloria.
All Rights Reserved.</p>
<pre>
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
</pre>
<pre>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</pre>
<pre>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY
OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</pre>
</body>
</html>
<!--
Notes on HTML 3.2:
* HTML 3.2 has no attribute "id", so we use <a name="ID">...</a> instead.
* HTML 3.2 doesn't include CSS "style", so a table is is used to format
  the curly-infix list BNF.
* HTML 3.2 lacks many named entities, so we use numbered entities.
  Although HTML 3.2 includes a mechanism to define new entities inline
  (as part of the DOCTYPE), this is not supported by more modern
  systems (e.g., Firefox).  In contrast, *EVERYONE* supports HTML
  numbered entities.
* The character ' is fine in HTML and XML, but the "quoter" tool
  (that automatically convert single and double quotes into curly quotes)
  will convert them.  That's fine for constructs like "doesn't", but
  is wrong when referring to Scheme's "quote" abbreviation.
  A useful solution is to represent it as an HTML entity.
  The named entity &apos; is in XML 1.0 and HTML 4.0, but not in HTML 3.2,
  so we cannot use "&apos;" to represent it.  Instead, this file
  uses &#39; for single vertical apostrophe.  That way, it will
  not be converted later to curly quotes by "quoter" and similar tools.
* HTML 3.2 doesn't allow <style...> in the head; but this is
  commonly-implemented, and implementations that don't will just
  back off to a less-pretty format.
* HTML 3.2 doesn't allow <div> to declare a class, but this is
  widely implemented, and helpful for the CSS.  Systems that
  don't implement it can trivially back off of it.
-->
