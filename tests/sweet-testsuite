; The following is a set of test cases for the sweet-expression reader.
; The first line is the traditional S-expression format;
; the second is the equivalent sweet-expression reader
; (it's in this order so that if the sweet-expression reader screws up,
; the data it's comparing to is known correct.)
; Some of these tests are basically duplicative; it's better to have
; "extra" tests than not enough.


x
x

; Fibonacci example
(define (fibfast n)
  (if (< n 2)
    n
    (fibup n 2 1 0)))

define fibfast(n)
  if {n < 2}
    n
    fibup(n 2 1 0)

(define (fibup max count n-1 n-2)
  (if (= max count)
    (+ n-1 n-2)
    (fibup max (+ count 1) (+ n-1 n-2) n-1)))

define fibup(max count n-1 n-2)
  if {max = count}
    {n-1 + n-2}
    fibup(max {count + 1} {n-1 + n-2} n-1)


(define (factorial n)
  (if (<= n 1)
    1
    (* n (factorial (- n 1)))))

define factorial(n)
  if {n <= 1}
    1
    {n * factorial{n - 1}}

x
x

'y
'y

xyz
; Hello
  ; another comment
xyz

qqq
qqq ; inline comment

rrr
; preceded with comment line
rrr ; inline comment


`(x ,y)
`(x ,y)

;
`(x ,y)
`    (x ,y)


(abc def)

abc def



(abc def ghi)
abc def ghi



(abc def ghi klm)
abc def ghi klm

()
()


(a b)
a
  b

(i j k)
i
  j
  k

(i (j k) m)
i
  j k
  m

()
{}

1
{1}

(- x)
{- x}

(+ 3 4)
{3 + 4}

($nfx$ 3 + 4 +)
{3 + 4 +}

(+ 3 4 5)
{3 + 4 + 5}

($nfx$ 3 + 4 + 5 +)
{3 + 4 + 5 +}

(+ 3 (* 5 6))
{3 + {5 * 6}}

($nfx$ 3 + 5 * 6)
{3 + 5 * 6}

($nfx$ a . z)
{a . z}

($nfx$ a + . z)
{a + . z}

($nfx$ a + b . z)
{a + b . z}

($nfx$ a + b + . z)
{a + b + . z}

($nfx$ a + b + c . z)
{a + b + c . z}

($nfx$ a + b + c + . z)
{a + b + c + . z}

; This isn't spec'ed, but we sure don't want to crash, so force this.
z
{. z}

(f)
f()

(f x)
f(x)


(define (fibfast n)
  (if (< n 2)
    n
    (fibup n 2 1 0)))

define fibfast(n)  ; function notation
  if {n < 2}       ; infix, indentation
    n              ; single-atom
    fibup(n 2 1 0) ; function call works.

x
; hi
  ; there
;hi
x

(x y)
;hi
x
;sadfasd
;  asdfsdf
    ; sdfasdf
  y


(x (yabba dabba) z)
; hi
  ; there
;hi
x
;sadfasd
;  asdfsdf
    ; sdfasdf
  yabba dabba
;asdfasdfasdf
                ;a  adf
 ; asdf
  z
; helllo


q
q

; This tests to see that all-spaces is the same as "return":
(x y)
x
  y
           
  z
  z


; Empty lines at beginning are ignored.
(aa bb)







  ; hi
;hi
                 ;hi
aa
; hi
       bb


(x y z)
x
  y
  z

(x y z)
x y
  z

(a b c)
a b c

(hello)
\\
  hello

((hello there))
\\
  hello there


(hi \\)
hi (. \\)

(a (b c) (d e))
a
  b c
  d e


(a b (d e))
a
  b
  d e

(a (b c) d)
a
  b c
  d

(a (b c) (d e))
a (b c)
  d e


(a (b c) (d e))
a (b c) (d e)

(x (y))
x
  \\
     y

(let ((x 1) (y 2)))
let
  \\
    x 1
    y 2

(cond
  ((< y 1) (frob))
  ((> y 1) (knob x))
  ((= y 1) (blob y z)))
cond
  {y < 1} frob()
  {y > 1} knob(x)
  {y = 1} blob(y z)


'x
'x

`x
`x

,x
,x

,@x
,@x

; Test SPLIT
(a b c (d e f))
a b
  c \\ d e f

; Test SPLIT
(a c (d e f))
a
  c \\ d e f

; test initial indent - this is a trivial test, it's hard to test this
; using this test suite approach
(first)

  (first)

((x y))
\\
  x y


'(x y)
' x y

()
(;comment
)

'((x y))
' \\
   x y

`(,x)
` \\
   ,x

`(,@x)
` \\
   ,@x

; other examples
; s-expr
(define-module (foo bar quux)
  :export (quux1 quux2))
; sweet-expr
define-module
  foo bar quux
  :export
  \\
    quux1
    quux2

; initial split
x
\\ \\ \\ \\ \\ x


; Test "initial period".  This is tricky, because it could be a:
; number: .5
; symbol: .hello
; cons separator: ( a . b)  and ( . x)
; indent: .<space>a

.5
.5

.hello
.hello

...
...

(foo ...)
foo ...

(bar ...)
bar
   ...

(a . b)
(a . b)

(a . (b c))
(a . (b c))

xyz
(. xyz)

abc
( . abc)

.qq
(. .qq)

.qq
( . .qq)

(bar (x y))
bar
! x y

(foo (a b) . c)
foo
  a b
  .
  c

(foo nnn)
foo
  . nnn

; Tests to focus on grouping (SPLIT symbol at beginning).

(z)
\\
  z

((z a))
\\
  z a

(a b)
\\ a
  b

(a (b c))
\\ a
  b c

(a b (c d))
\\ a b
  c d

(foo (a))
foo
  \\
     a

(foo ((a b)))
foo
  \\
     a b

(foo (z (a b)))
foo
  \\ z
     a b

(foo (a b))
foo
  \\
  a b


(foo7 nnn)
foo7
  \\
  \\
  \\
  nnn


; Tests for SPLIT in middle.

(foo a b)
foo
  a \\ b


(bar a (c b))
bar
  a \\ c b

(bar2 (z a) (c b))
bar2
  z a \\ c b

(bar3 (z a) c)
bar3
  z a \\ c

(bar4 z y x w v)
bar4
   z \\ y \\ x \\ w \\ v

; Check lots of parameters

(foo a z y x w v)
foo a z y x w v


(foo1 a z y x w v)
foo1
  a
  z
  y
  x
  w
  v


(foo2 a z y x w v)
foo2 a
  z
  y
  x
  w
  v

(foo3 a z y x w v)
foo3 a z
  y
  x
  w
  v

(f x q)
f(x q)

; Boring s-expressions should work too
()
()

(a b)
(a b)

(a . b)
(a . b)

(z (q x) (f n))
(z (q x) (f n))

123
123

5.5
5.5

-7
-7

+8
+8

-5.5
-5.5

(->x)
(->x)

#\x
#\x

(#\newline #\space #\x)
(#\newline #\space #\x)

( #\( #\) #\[ #\] #\{ #\} )
( #\( #\) #\[ #\] #\{ #\} )

#b10101
#b10101

#xca9a
#xca9a

#t
#t

#f
#f

"I am a string"
"I am a string"

"String\n with embedded newline"
"String\n with embedded newline"


; Test indentation

(foo z)
foo
                             z

; tab:
(foo2 z)
foo2
	z

(foo3 z)
foo3
		z

; Mixed:
(foo4 a)
foo4
	 a

(foo6 z)
foo6
! ! ! ! z


; Initial quote + space:
'ab
' ab

'(ab cd)
' ab cd

'(aa cc ff)
' aa cc
  ff

'(aa cc (ff gg))
' aa cc
  ff gg

'((a b))
' \\
  a b

'((a b))
' \\
  a(b)

'(aaa)
' \\
  aaa 

'((ccc ddd))
' \\
  (ccc ddd)

'(c (a b))
' \\ c
  a b

; Quote followed by newline: interpret ' as quote.
; This is debatable, but I think it makes sense.
; In particular, if you start with:
; \\
;    aaa
; and then quote it:
; ' \\
;   aaa
; It should produce '(aaa).  So, if there's no \\, it makes sense
; to interpret it like this:

'(aaa bbb)
'
  (aaa bbb)


'(aa bb)
'
  aa bb

; quote followed by space + newline should be same as just followed by newline:
'(e f)
' 
  e f


; Test comments.
(zz aa)
; before
zz
; ignore
    ; ignore
  aa
     ; ignore


($bracket-apply$ b)
b[]


($bracket-apply$ b q)
b[q]

(a . port)
a(. port)


(b c . port)
b(c . port)

(f)
f()

(f)
f{}

(f (+ a b))
f{a + b}

(f (+ a b))
f({a + b})

(f ($nfx$ a + b * c))
f{a + b * c}

(- 5)
-(5)

(- b c)
-(b c)

(* x y)
*(x y)

(/ n d)
/(n d)

(->x)
->x()

(a->b 0)
a->b(0)

(+ a (* b c))
{a + {b * c}}

("Hello" 3)
"Hello"(3)

(q (a b c) (d e (f h (i j))))
q(a(b c) d(e f(h i(j))))

(qq (a b c) (d e (f h (i j))))
qq(   a(b c) 
  d(e f(h i(j))))

((f a) c d)
f(a)(c d)

((g h) ((f a) c d))
g(h)f(a)(c d)

((((hello))))
((((hello))))

(1 (2 (3 (4 (5 (6 (7 (8 (9 9) 8) 7) 6) 5) 4) 3) 2) 1)
(1 (2 (3 (4 (5 (6 (7 (8 (9 9) 8) 7) 6) 5) 4) 3) 2) 1)

(a (2 (3 (4 (5 (6 (7 (8 (9 9) 8) 7) 6) 5) 4) 3) 2) 1)
a(2(3(4(5(6(7(8(9(9) 8) 7) 6) 5) 4) 3) 2) 1)

; SUBLIST

(foo bar)
foo $ bar ; not a subLIST, so disable sublist behavior

(probe (let ((var val))
  (secretify var (do innocuous stuff))))
probe $ let ((var val))
  secretify var $ do innocuous stuff

(run (head -10 README))
run $ head(-10 README)

(run (head -10 README))
run $ head -10 README

(cleanup (run (cat README)))
cleanup $ run $ cat(README)

(cleanup 'nicely (run (cat README)))
cleanup 'nicely $ run $ cat(README)

(aa bb (cc (dd ee)))
aa bb $ cc
  dd ee

(a b c d)
a b c $ d

(a b (c d))
a b $ c d

(a (b c d))
a $ b c d

((a b c d))
$ a b c d

(q)
$ q

((f g))
$ f g

((f x))
$ f(x)

((f (a b)))
$ f
  a b

((f a))
$ f
  a

((f q (a b)))
$ f q
  a b

(solo (z))
solo
  $ z

(foo ((a b)))
foo
  $ a b

(far ((a b (c d))))
far
  $ a b
    c d

(((f x) xyz))
$ f(x)
  xyz

; multiline comments

x
#|
 #|
  |#
 |#
x

(x y)
  #| shouldn't disable t-expression mode
   #|
    |#
   |#
x y

x
x #|
   #|
    |#
   |#

(x
  y)
x
 #|
  #|
   |#
  |# y

(y z)
#; x y z

(x z)
x #; y z

(x y)
x #|comment|# y

(f
 (x y))
f
  x #|comment|# y

