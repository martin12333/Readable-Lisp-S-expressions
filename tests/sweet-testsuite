; The following is a set of test cases for the sweet-expression reader.
; The first line is the traditional S-expression format;
; the second is the equivalent sweet-expression reader
; (it's in this order so that if the sweet-expression reader screws up,
; the data it's comparing to is known correct.)
; Some of these tests are basically duplicative; it's better to have
; "extra" tests than not enough.


x
x

; Fibonacci example
(define (fibfast n)
  (if (< n 2)
    n
    (fibup n 2 1 0)))

define fibfast(n)
  if {n < 2}
    n
    fibup(n 2 1 0)

(define (fibup max count n-1 n-2)
  (if (= max count)
    (+ n-1 n-2)
    (fibup max (+ count 1) (+ n-1 n-2) n-1)))

define fibup(max count n-1 n-2)
  if {max = count}
    {n-1 + n-2}
    fibup(max {count + 1} {n-1 + n-2} n-1)


(define (factorial n)
  (if (<= n 1)
    1
    (* n (factorial (- n 1)))))

define factorial(n)
  if {n <= 1}
    1
    {n * factorial{n - 1}}

x
x

'y
'y

xyz
; Hello
  ; another comment
xyz

qqq
qqq ; inline comment

rrr
; preceded with comment line
rrr ; inline comment


`(x ,y)
`(x ,y)

;
`(x ,y)
`    (x ,y)


(abc def)

abc def



(abc def ghi)
abc def ghi



(abc def ghi klm)
abc def ghi klm

()
()


(a b)
a
  b

(i j k)
i
  j
  k

(i (j k) m)
i
  j k
  m

()
{}

1
{1}

(- x)
{- x}

(+ 3 4)
{3 + 4}

($nfx$ 3 + 4 +)
{3 + 4 +}

(+ 3 4 5)
{3 + 4 + 5}

($nfx$ 3 + 4 + 5 +)
{3 + 4 + 5 +}

(+ 3 (* 5 6))
{3 + {5 * 6}}

($nfx$ 3 + 5 * 6)
{3 + 5 * 6}

($nfx$ a . z)
{a . z}

($nfx$ a + . z)
{a + . z}

($nfx$ a + b . z)
{a + b . z}

($nfx$ a + b + . z)
{a + b + . z}

($nfx$ a + b + c . z)
{a + b + c . z}

($nfx$ a + b + c + . z)
{a + b + c + . z}

; This isn't spec'ed, but we sure don't want to crash, so force this.
z
{. z}

(f)
f()

(f x)
f(x)


(define (fibfast n)
  (if (< n 2)
    n
    (fibup n 2 1 0)))

define fibfast(n)  ; function notation
  if {n < 2}       ; infix, indentation
    n              ; single-atom
    fibup(n 2 1 0) ; function call works.

x
; hi
  ; there
;hi
x

(x y)
;hi
x
;sadfasd
;  asdfsdf
    ; sdfasdf
  y


(x (yabba dabba) z)
; hi
  ; there
;hi
x
;sadfasd
;  asdfsdf
    ; sdfasdf
  yabba dabba
;asdfasdfasdf
                ;a  adf
 ; asdf
  z
; helllo


q
q

; This tests to see that all-spaces is the same as "return":
(x y)
x
  y
           
  z
  z


; Empty lines at beginning are ignored.
(aa bb)







  ; hi
;hi
                 ;hi
aa
; hi
       bb


(x y z)
x
  y
  z

(x y z)
x y
  z

(a b c)
a b c

(hello)
\\
  hello

((hello there))
\\
  hello there


(hi \\)
hi (. \\)

(a (b c) (d e))
a
  b c
  d e


(a b (d e))
a
  b
  d e

(a (b c) d)
a
  b c
  d

(a (b c) (d e))
a (b c)
  d e


(a (b c) (d e))
a (b c) (d e)

(x (y))
x
  \\
     y

(let ((x 1) (y 2)))
let
  \\
    x 1
    y 2

(cond
  ((< y 1) (frob))
  ((> y 1) (knob x))
  ((= y 1) (blob y z)))
cond
  {y < 1} frob()
  {y > 1} knob(x)
  {y = 1} blob(y z)


'x
'x

`x
`x

,x
,x

,@x
,@x

; Test SPLIT
(a b c (d e f))
a b
  c \\ d e f

; Test SPLIT
(a c (d e f))
a
  c \\ d e f

; test initial indent - this is a trivial test, it's hard to test this
; using this test suite approach
(first)

  (first)

((x y))
\\
  x y


'(x y)
' x y

()
(;comment
)

'((x y))
' \\
   x y

`(,x)
` \\
   ,x

`(,@x)
` \\
   ,@x

; other examples
; s-expr
(define-module (foo bar quux)
  :export (quux1 quux2))
; sweet-expr
define-module
  foo bar quux
  :export
  \\
    quux1
    quux2

; initial split
x
\\ \\ \\ \\ \\ x


; Test "initial period".  This is tricky, because it could be a:
; number: .5
; symbol: .hello
; cons separator: ( a . b)  and ( . x)
; indent: .<space>a

.5
.5

.hello
.hello

...
...

(foo ...)
foo ...

(bar ...)
bar
   ...

(a . b)
(a . b)

(a . (b c))
(a . (b c))

xyz
(. xyz)

abc
( . abc)

.qq
(. .qq)

.qq
( . .qq)

(bar (x y))
bar
! x y

; Disable for now; it's not clear this should be supported.
; Re-enable if this is (re)instated.
; (foo (a b) . c)
; foo
;   a b
;   .
;   c

(foo nnn)
foo
  . nnn

; Tests to focus on grouping (SPLIT symbol at beginning).

(z)
\\
  z

((z a))
\\
  z a

(a b)
\\ a
  b

(a (b c))
\\ a
  b c

(a b (c d))
\\ a b
  c d

(foo (a))
foo
  \\
     a

(foo ((a b)))
foo
  \\
     a b

(foo (z (a b)))
foo
  \\ z
     a b

(foo (a b))
foo
  \\
  a b


(foo7 nnn)
foo7
  \\
  \\
  \\
  nnn


; Tests for SPLIT in middle.

(foo a b)
foo
  a \\ b


(bar a (c b))
bar
  a \\ c b

(bar2 (z a) (c b))
bar2
  z a \\ c b

(bar3 (z a) c)
bar3
  z a \\ c

(bar4 z y x w v)
bar4
   z \\ y \\ x \\ w \\ v

; Check lots of parameters

(foo a z y x w v)
foo a z y x w v


(foo1 a z y x w v)
foo1
  a
  z
  y
  x
  w
  v


(foo2 a z y x w v)
foo2 a
  z
  y
  x
  w
  v

(foo3 a z y x w v)
foo3 a z
  y
  x
  w
  v

(f x q)
f(x q)

; Boring s-expressions should work too
()
()

(a b)
(a b)

(a . b)
(a . b)

(z (q x) (f n))
(z (q x) (f n))

123
123

5.5
5.5

-7
-7

+8
+8

-5.5
-5.5

(->x)
(->x)

#\x
#\x

(#\newline #\space #\x)
(#\newline #\space #\x)

( #\( #\) #\[ #\] #\{ #\} )
( #\( #\) #\[ #\] #\{ #\} )

#b10101
#b10101

#xca9a
#xca9a

#t
#t

#f
#f

"I am a string"
"I am a string"

"String\n with embedded newline"
"String\n with embedded newline"


; Test indentation

(foo z)
foo
                             z

; tab:
(foo2 z)
foo2
	z

(foo3 z)
foo3
		z

; Mixed:
(foo4 a)
foo4
	 a

(foo6 z)
foo6
! ! ! ! z


; Initial quote + space:
'ab
' ab

'(ab cd)
' ab cd

'(aa cc ff)
' aa cc
  ff

'(aa cc (ff gg))
' aa cc
  ff gg

'((a b))
' \\
  a b

'((a b))
' \\
  a(b)

'(aaa)
' \\
  aaa 

'((ccc ddd))
' \\
  (ccc ddd)

'(c (a b))
' \\ c
  a b

; Quote followed by newline: interpret ' as quote.
; This is debatable, but I think it makes sense.
; In particular, if you start with:
; \\
;    aaa
; and then quote it:
; ' \\
;   aaa
; It should produce '(aaa).  So, if there's no \\, it makes sense
; to interpret it like this:

'(aaa bbb)
'
  (aaa bbb)


'(aa bb)
'
  aa bb

; quote followed by space + newline should be same as just followed by newline:

'(e f)
' 
  e f

'(f)
'
  f()

'((f) (g))
'
  f() g()

; Test support for multi-argument quasiquote.
; (quasiquote abc def)
; `
;   abc
;   def

; Test comments.
(zz aa)
; before
zz
; ignore
    ; ignore
  aa
     ; ignore


($bracket-apply$ b)
b[]


($bracket-apply$ b q)
b[q]

(a . port)
a(. port)


(b c . port)
b(c . port)

(f)
f()

(f)
f{}

(f (+ a b))
f{a + b}

(f (+ a b))
f({a + b})

(f ($nfx$ a + b * c))
f{a + b * c}

(- 5)
-(5)

(- b c)
-(b c)

(* x y)
*(x y)

(/ n d)
/(n d)

(->x)
->x()

(a->b 0)
a->b(0)

(+ a (* b c))
{a + {b * c}}

("Hello" 3)
"Hello"(3)

(q (a b c) (d e (f h (i j))))
q(a(b c) d(e f(h i(j))))

(qq (a b c) (d e (f h (i j))))
qq(   a(b c) 
  d(e f(h i(j))))

((f a) c d)
f(a)(c d)

((g h) ((f a) c d))
g(h) f(a)(c d)

((((hello))))
((((hello))))

(1 (2 (3 (4 (5 (6 (7 (8 (9 9) 8) 7) 6) 5) 4) 3) 2) 1)
(1 (2 (3 (4 (5 (6 (7 (8 (9 9) 8) 7) 6) 5) 4) 3) 2) 1)

(a (2 (3 (4 (5 (6 (7 (8 (9 9) 8) 7) 6) 5) 4) 3) 2) 1)
a(2(3(4(5(6(7(8(9(9) 8) 7) 6) 5) 4) 3) 2) 1)

; SUBLIST

(foo bar)
foo $ bar ; not a subLIST, so disable sublist behavior

(probe (let ((var val))
  (secretify var (do innocuous stuff))))
probe $ let ((var val))
  secretify var $ do innocuous stuff

(run (head -10 README))
run $ head(-10 README)

(run (head -10 README))
run $ head -10 README

(cleanup (run (cat README)))
cleanup $ run $ cat(README)

(cleanup 'nicely (run (cat README)))
cleanup 'nicely $ run $ cat(README)

(aa bb (cc (dd ee)))
aa bb $ cc
  dd ee

(a b c d)
a b c $ d

(a b (c d))
a b $ c d

(a (b c d))
a $ b c d

((a b c d))
$ a b c d

(q)
$ q

((f g))
$ f g

((f x))
$ f(x)

((f (a b)))
$ f
  a b

((f a))
$ f
  a

((f q (a b)))
$ f q
  a b

(solo (z))
solo
  $ z

(foo ((a b)))
foo
  $ a b

(far ((a b (c d))))
far
  $ a b
    c d

(((f x) xyz))
$ f(x)
  xyz

; multiline comments

x
#|
 #|
  |#
 |#
x

(x y)
  #| shouldn't disable t-expression mode
   #|
    |#
   |#
x y

x
x #|
   #|
    |#
   |#

(x
  y)
x
 #|
  #|
   |#
  |# y

(y z)
#; x y z

(x z)
x #; y z

(x y)
x #|comment|# y

(f
 (x y))
f
  x #|comment|# y


(define (f x) x x)
define f(x)
  x
  x

(define (f x) x)
define f(x) x

(defun x (a b) (q a b) (n a b))
defun x (a b)
  q a b
  n a b

(car (gettimeofday))
car $ gettimeofday()

(list-test aa bb . cc)
list-test
  aa
  bb
  .
  cc

(another aa . bb)
another
  aa
  .
  bb

; MORE


one
one

(one two)
one two

(one two three)
one two three

(one two three four)
one two three
  four

(one two three four five)
one two three
  four
  five

(one two three four five six)
one two three
  four
  five
  six

(a b c (d e))
a b
  c
  d e

(a (quote (c d e (g h i))))
a
   ' c d e
      g h i

(cos 0)
cos 0

42
42

7.0
7.0

#xffff
#xffff

#i#b1001
#i#b1001

#b#e1001
#b#e1001

#e42
#e42

; TO FIX
; #! SRFI-22
; one
; #!/bin/sh
;   weird script should be ignored
; !#
; two
; #!sweet
; three
; #!
; four

(a)
$ a

((a b))
$ a b

((a b c))
$ a b c

(x a)
x $ a

(x (a b))
x $ a b

(x (a b c))
x $ a b c

(x y a)
x y $ a

(x y (a b))
x y $ a b

(x y (a b c))
x y $ a b c

(x y z a)
x y z $ a

(x y z (a b))
x y z $ a b

(x y z (a b c))
x y z $ a b c

((a b))
$ a
  b

((a (b c)))
$ a
  b c

((a z (o p)))
$ a z
  o p

; "$" is different from \\; initial "$" always makes another list. Since:
; \\
;   d
; would create (d), a "$" inserts another (...) level vs \\, making ((d)):
((d))
$ \\
  d

(((d e)))
$ \\
  d e

(((d e f)))
$ \\
  d e f

(fee (fie (foe fum)))
fee $ fie
  foe fum

'(a b (c d))
' a b
  c d

(m 'n o (p q))
m ' n o
  p q

('x y z (c d))
'x y z
  c d

('a b c)
'a b c

(a 'c e)
a 'c e

(m n 'o)
m n 'o

(q1)
\\
  q1

((q1 q2))
\\
  q1 q2

((q1 q2 q3))
\\
  q1 q2 q3

((a1 a2) (b1 b2) (c1 c2))
\\
  a1 a2
  b1 b2
  c1 c2

a
\\ a

(a b)
\\ a
  b

(a (b c))
\\ a
  b c


(x y z (aa bb) (cc dd) (ee ff))
\\ x y z
  aa bb
  cc dd
  ee ff

(a b c d (e f) (g h) (i j k) (l m n) (o p q))
a b
  c \\ d
  e f \\ g h
  i j k \\ l m n \\ o p q

; Reserve top-level tests for some other test approach
; p \\ q
; 
; n a b \\ sing sang sung
; n a b \\ sing sang sung
;  d e f
; a $ b \\ c $ d
; e f $ g h \\ i j $ k l
; a b c $ d e f $ g h i \\ j k l $ m n o $ p q r \\ s t u $ v w x $ y z zz


use-dash
use-dash

(let ())
let <* *>

(let (hello))
let <* hello *>

(let ((var1 value1)))
let <* var1 value1 *>

(let ((var1 value1) (var2 value2)))
let <* var1 value1 \\ var2 value2 *>

(let ((var1 value1)) (fact var1))
let <* var1 value1 *>
  fact var1

; "$" inside parens is just another atom.
(a b $ c d)
(a b $ c d)

($ x)
($ x)

; Test tabs

(f a b)
f
	a
	b

(g h)
g
! h

(h i)
h
; ignore me.
  ; ignore me, too.
  i

; TEST ANOTHER WAY
;  first second third
;back to
;  working correctly

; NOT WORKING YET - restart after head:
;  define-library (example grid)
;  \>  export make rows cols ref each rename(put! set!)

; import (scheme short) <* *>

(import (scheme base) (begin (define (make n m) (do-make)) (define (rows grid) (vector-length grid))))
import (scheme base) <* begin

define make(n m)
  do-make()

define rows(grid)
  vector-length(grid)
*>



; import (scheme base) <* begin stuff
; 
; define make(n m)
;   do-make()
; 
; define rows(grid)
;   vector-length(grid)
; *>


; Initial indents:
;   indent-disabled
; 
;   indent-disabled1 indent-disabled2
; 
;   indent-disabled1   indent-disabled2     indent-disabled3
; 
;   initial-indents $ disable \\ processing
; 
;   indent-disabled
;   indent-disabled-another
;   ; Indented comments should be ignored
; g 1 2
;   ; Even if they occur after a normal line
; h 3 4
 
(f 1 2 (a 3 4 (b 5 6 (c 7 8) (d 9 9))))
; Check deep nesting - does it dedent?
f 1 2
  a 3 4
    ; Embedded comments should be ignored.
    b 5 6
      c 7 8
      d 9 9

(a 1 2 (b 2 3) (c 4 5 (d 6 7) (e 8 9 (f 10 11))) (g again))
a 1 2
  b 2 3
  c 4 5
    d 6 7
    e 8 9
      f 10 11
  g again

((1 2))
\\
  1 2

((4 5))
\\ #| Ignore this |#
  4 5

((1 2) (3 4))
\\
  1 2
  3 4

((4 5) (a b))
\\ #| Ignore this |#
  4 5
  a b

((6 7) (8 9))
#| Ignore this |#
  6 7
  8 9

((1 2) (3 4))
\\
  1 2
  3 4

(((1 2) (3 4)))
$ \\
  1 2
  3 4

(f a b)
f
  a
  \\
  b

(x . y)
x . y

(x y . z)
x y . z

()
{}

solo
{solo}

(+ x)
{+ x}

(eq a b)
{a eq b}

(+ a b c)
{a + b + c}

($nfx$ a + b + c +)
{a + b + c +}

(x y z)
(  x  y  z  )

(x y)
(  x  y  )

(x)
(  x  )

()
(  )

a
(  . a  )

(a . b)
(  a . b  )

(a b . c)
(  a  b  .  c  )

; NO TEST:
; (  .  )
; (  quote  .  )

(f)
f()

(f x)
f(x)

(f a b)
f(a b)

(f a b c)
f(a b c)

($bracket-apply$ f)
f[]

($bracket-apply$ f x)
f[x]

(f)
f{}

(f x)
f{x}

(f (+ x))
f{+ x}

(f (+ x 1))
f{x + 1}

((x a) b)
x(a)(b)

#t
#t

#f
#f

(#\Q 1 #\( 2 #\a 3 #\newline 4)
#\Q 1 #\( 2 #\a 3 #\newline 4

#(1 2 3)
#(1 2 3)

; TODO:
; #u8(5 6 7)
; 
; TODO:
; #!sweet
; 

(* n (factorial (- n 1)))
{n * factorial{n - 1}}

; TODO: FIXME
; ((x) z)
; #;a#|hi|#(x) z

()
<* *>

(hi)
<* hi *>

((a b))
<* a b *>

((a b c))
<* a b c *>

(((x) (y) (z)))
<* (x) (y) (z) *>

((this) is a test)
<* this *> is a test

((((define x 5) (define y 7))) is a test)
<* define(x 5) define(y 7) *> is a test

(library (amkg animals (1 0)) (export cat (rename (rover dog))) (import (only (amkg pets (1 0)) rover)) (define cat (quote meow)))
<*
library \\ amkg animals $ 1 0
export
  cat
  rename $ rover dog
import
  only
    amkg pets $ 1 0
    rover

define cat 'meow

*>


(let ((x (cos (f c)))) (dostuff x))
let ((x cos(f(c))))
! dostuff x


; TODO: FIXME
; (let ((x (cos (f c)))) (dostuff x))
; let <* x $ cos $ f c *>
; ! dostuff x

(test ((x 1)) ((y 2)) (((a 3)) ((b 4))))
test <* x 1 *> <* y 2 *>
  <* a 3 *> <* b 4 *>

(((t 1)) ((u 2)))
<* t 1 *>
   <* u 2 *>


(fuss library (amkg animals (1 0)))
fuss
  library \\ amkg animals $ 1 0

another
another

(amkg animals (1 0))
amkg animals $ 1 0

(define cuddle-first-parameter '(
  if when unless case define lambda define-module library export import
  letrec let let* let1 let-syntax letcrec-syntax define-syntax syntax-rules
  set! do setq block typecase))
define cuddle-first-parameter '(
  if when unless case
  define lambda
  define-module                  ; Guile modules
  library export import          ; R6RS library modules
  letrec let let* let1
  let-syntax letcrec-syntax
  define-syntax syntax-rules
  set! do
  setq block typecase)           ; Common Lisp

fred
fred

; FIXME: Test initial indent
;     (define (f a) (* 2 a)) (define x 4)
; 
; FIXME: Sharp-bang processing
; #!sweet
; 
;   hello world


all-okay
all-okay

(define f before (let (begin (define x 1) (define y 2)) q) after)
define f
  before
  let <* begin
define x 1
define y 2
*> q
  after

after-okay
after-okay


(let (first last))
let <*
first

last
*>

((hello) (f x))
<* hello *>
  f x

((bye) a b (f x))
<* bye *> a b
  f x

((one) (two) (three) ((four) (five)) (f x))
<* one *> <* two *> <* three *>
  <* four *> <* five *>
  f x

(n expr)
. n(expr)

(foo1 foo2)
foo1
  \\ ; comment_eol
  ; same followed by comment_eol
  foo2

(foo a b)
foo
  a
  \\
  b

; FIXME: Enable these tests
; a \\ b
; 
; a
; \\
; b
; 

(foo c d)
foo
! c \\ d

(foo c d)
foo
! c
! \\
! d

(f a b c)
f
 \\ a
 \\ b
 \\ c

; FIXME: Move these tests
; \\ a
; \\ b
; \\ c
; 


(foo (bar batz) (nitz koo))
foo
! bar batz
; comment
! nitz koo

(car (gettimeofday))
car $ gettimeofday()

'hi
'
  hi

'hi
' hi

'(one two)
'
  one two

'(one two)
' one two

'(f)
'
  f()

'(f)
' f()

'((f) (g))
'
  f() g()


'((f) (g))
' f() g()


'((f))
'
  ((f))

'((f))
' ((f))

'((f 1) (g 1))
' f(1) g(1)

; ; Multiline - interpret this way so you can access weird extensions
; ; such as multi-line quasiquote ("Bawden quasiquote")
; 
; '
;   f(1)
;   g(1)
; 
; '
;   a
;   b
; 
; ' a b
; 
; (dd1 ee1 . ff1)
; 
; foo1
;  bar
;   aa1
;   bb1
;   .
;   cc1
; 


(define-library
  (srfi 41 primitive)
  (export
    stream-cons
    stream-null
    stream-pair?
    stream-null?
    stream?
    stream-car
    stream-cdr
    stream-lambda))

<* define-library \\ (srfi 41 primitive)
export . (
stream-cons stream-null
stream-pair? stream-null? stream?
stream-car stream-cdr
stream-lambda
)
*>

; TODO: FIXME -
; must handle "." in middle of line with (..) list on RHS followed by *>
;
; (define-library
;   (srfi 41 primitive)
;   (export
;     stream-cons
;     stream-null
;     stream-pair?
;     stream-null?
;     stream?
;     stream-car
;     stream-cdr
;     stream-lambda))
; 
; <* define-library \\ (srfi 41 primitive)
; export . (
; stream-cons stream-null
; stream-pair? stream-null? stream?
; stream-car stream-cdr
; stream-lambda
; ) *>
