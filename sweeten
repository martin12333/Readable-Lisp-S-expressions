#!/bin/sh
# Filter to read S-expressions and output indented sweet-expressions.

# Takes list of files, if no list, reads from stdin.

# *Requires* that sweeten.scm, makefile, etc. be in current directory.

make sweeten.scm 2> ,make-report >&2 ||
 (
  cat ,make-report
  exit 1
 )


runsweetener () {
  # The "$1" is the prefix, e.g., "exec"
  $1 guile sweeten.scm
}


if [ $# -eq 0 ] ; then
 runsweetener "exec"
else
 for file ; do
  runsweetener < "$file"
 done
fi

exit 0

# ============ AUTO-COMPILE APPROACH ==============
# The below automatically loads sweet.sscm and compiles it with "readable".
# Unfortunately, "readable" doesn't currently have a way to completely
# switch back to the standard reader - the ports end up consuming extra
# characters (like "(") when there's no blank line between datums.
# Switch to the approach below once there's a way to
# completely revert to the standard reader.

# Requires guile and runs sweeten.sscm.
# Currently presumes sweeten.sscm is in the same path as this file.

# To completely clear out the environment first, replace "env" with:
#    env -i HOME="$HOME" PATH="$PATH"

runsweetener () {
  this_script="$1"
  # guile's poorly-documented "-q" flag inhibits loading of user init file.
  $2 env GUILE_LOAD_PATH="${GUILE_LOAD_PATH:-"`dirname $1`"}" guile -q -s "$1"
}

if [ $# -eq 0 ] ; then
 runsweetener "$0" "exec"
else
 for file ; do
  runsweetener "$0" < "$file"
 done
fi
echo
exit

# The following starts the script run by guile (per the -s flag):
!#

(use-modules (readable sweet-impl))
(replace-read sweet-read)
(load "sweeten.sscm")
