; math.slisp - demonstrate math simplification system
; by David A. Wheeler
; Demonstrates using sweet-expressions in Common Lisp.
; This program focuses on returning exact results where possible.

; There are many implementations of Computer Algebra Systems (CASs)
; in Common Lisp, but they typically have to implement their own reader
; because the built-in reader is so painful to use.
; You *can* implement your own language, of course, but having a
; built-in notation that's easier to use makes it easier to move on
; to actually solving problems instead.  So this demonstration
; shows *using* sweet-expressions to write the program, *and* uses
; sweet-expressions as the input notation.

; To run test suite: "make check-math"

#-quicklisp
(let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

; We'll reuse the optima pattern-matcher.  Its notation is more
; complex than cl-pattern, but it has more functionality and we need it.
(ql:quickload "optima")
(ql:quickload "readable")

(use-package :optima)
(readable:enable-sweet)

; These optima patterns are like optima's "list" and "list*", but inline.
defpattern ilist (arg)
  when consp(arg)
   ` cons ,car(arg) ilist(,cdr(arg))

defpattern ilist* (arg)
  if null(cdr(arg))
      ` and ,car(arg) type(list)
      ` cons ,car(arg) ilist*(,cdr(arg))

; Return t if expr is a numeric-only operation using an op in op-list
defun numeric-operationp (expr op-list)
  and
    consp expr
    member car(expr) op-list
    not null(cdr(expr))
    every #'numberp cdr(expr)

defun numberlistp (x)
  {not(null(x)) and every(#'numberp x)}

defun more-than-onep (x) {consp(x) and consp(cdr(x))}

defun generous-zerop (x) {numberp(x) and {x = 0}}

defun generous-onep (x)  {numberp(x) and {x = 1}}

defun true-valuep (x)  {x eq 'true}
defun false-valuep (x)  {x eq 'false}

defun constant-valuep (x)
  {numberp(x) or eq(x 'pi) or eq(x 'e)}

defun truthiness (x)
  if x 'true 'false

; Implement "num" function, which forces numerical calculation.
; Numeric + - * / already computed using simplification, so no need to do that.
defun compute-numeric (x)
  cond
    eq(x 'pi) pi
    eq(x 'e)  exp(1)
    not(consp(x)) x
    numeric-operationp(x '(^))
      apply #'expt cdr(x)
    numeric-operationp(x '(log ln sin cos))
      apply car(x) cdr(x)
    t
      x

defun simplify-expression (expr)
  "Simplify one expression (its operands have already been simplified)."
  optima:match expr
    list*('* args)
      when \\ find 0 args
      0
    list*('and args)
      when \\ find 'false args
      'false
    list*(params)
      when \\ find('undef params)
      'undef
    list*(op args)
      when \\ {member(op '(+ - *)) and numberlistp(args)}
      apply op args
    list*(op args)
      when \\ {member(op '(= < <= > >=)) and numberlistp(args)}
      truthiness $ apply op args
    list*('<> args)
      when \\ numberlistp(args)
      truthiness $ apply #'/= args
    list*('+ args)
      when \\ find 0 args
      simplify-expression $ cons '+ remove-if(#'generous-zerop args)
    list*('* args)
      when \\ find 1 args
      simplify-expression $ cons '* remove-if(#'generous-onep args)
    list*('and args)
      when \\ find 'true args
      simplify-expression $ cons 'and remove-if(#'true-valuep args)
    list*('or args)
      when \\ find 'false args
      simplify-expression $ cons 'or remove-if(#'false-valuep args)
    list*('or args)
      when \\ find 'true args
      'true
    ilist{lhs '/ rhs}
      when \\ {integerp(lhs) and integerp(rhs) and {rhs /= 0}}
      {lhs / rhs}
    ilist{lhs '^ rhs}
      when \\ {integerp(lhs) and integerp(rhs) and {rhs >= 2}}
      expt lhs rhs
    list*(op args)
      when \\ {member(op '(+ *)) and {length(args) >= 2} and
               {length(remove-if(complement(#'numberp) args)) > 1}}
      ; Mixed numbers and symbols - simplify just the numbers.
      simplify-expression
        append
          list op
            apply op remove-if(complement(#'numberp) args)
          remove-if #'numberp args
    list('+ a)                     a
    list('* a)                     a
    list('+)                       0
    list('or)                      'false
    list('*)                       1
    list('and)                     'true
    ilist{a '+ eql(a)}             `{2 * ,a}
    ilist{a '- 0}                  a
    ilist{0 '- a}                  `-(,a)
    ilist{a '- eql(a)}             0
    ilist{a '+ list('- eql(a))}    0
    ilist{a '* 1}                  a
    ilist{1 '* a}                  a
    ilist{a '* eql(a)}             `{,a ^ 2}
    ilist{a '* eql(a) '* eql(a)}   `{,a ^ 3}
    ilist{a '/ 0}                  'undef
    ilist{a '/ 1}                  a
    ilist{a '/ eql(a)}             1
    ilist{0 '^ 0}                  'undef
    ilist{a '^ 0}                  1
    ilist{0 '^ a}                  0
    ilist{1 '^ a}                  1
    ilist{a '^ 1}                  a
    ilist{a '^ -1}                 `{1 / ,a}
    ilist{ilist{a '* b} '/ eql(a)} b
    ilist{ilist{b '* a} '/ eql(a)} b
    ilist{a '* ilist{b '/ eql(a)}} b
    ilist{ilist{b '/ a} '* eql(a)} b
    list('log 0)                   'undef
    list('log 0 _)                 'undef
    list('log 1)                   0
    list('log 1 _)                 0
    list('log a eql(a))            1
    list('ln 0)                    'undef
    list('ln e)                    1
    list('sin 0)                   0
    list('sin 'pi)                 0
    list('cos 0)                   1
    list('cos 'pi)                 -1
    list('d constant '/ 'd x)      when constant-valuep(constant) 0
    list('d x '/ 'd (eql x))       when symbolp(x)                1
    list('num arg)                 compute-numeric(arg) ; "num(...)" function
    list('not 'true)               'false
    list('not 'false)              'true
    list*('/= args)                `(<> ,@args)  ; Prefer "<>"
    list*('!= args)                `(<> ,@args)
    ilist{a '= eql(a)}             'true
    list('if 'true tside)          tside
    list('if 'true tside fside)    tside
    list('if 'false tside)         'undef
    list('if 'false tside fside)   fside
    a                              a

defun simplify-all (expr)
  "Simplify an expression: first its operands, then the whole thing."
  if atom(expr)
     expr
     simplify-expression mapcar(#'simplify-all expr)

princ "Math - Simplify possibly-symbolic math sweet-expressions."
terpri()
princ "Examples: {3 * {1 + 2}}, cos(0), {x + {y * 0}}"
terpri()
terpri()

princ "Please enter expressions to be simplified:"
terpri()
loop for line = read-preserving-whitespace(*standard-input* nil :eof)
     until \\ eq line :eof
     do \\ progn
       readable:write-readable simplify-all(line) :case :downcase
       terpri()

(readable:disable-readable)
