; math.slisp - demonstrate math simplification system
; by David A. Wheeler
; Demonstrates using sweet-expressions in Common Lisp.
; This program focuses on returning exact results where possible.

; There are many implementations of Computer Algebra Systems (CASs)
; in Common Lisp, but they typically have to implement their own reader
; because the built-in reader is so painful to use.
; You *can* implement your own language, of course, but having a
; built-in notation that's easier to use makes it easier to move on
; to actually solving problems instead.  So this demonstration
; shows *using* sweet-expressions to write the program, *and* uses
; sweet-expressions as the input notation.

; To run test suite: "make check-math"

#-quicklisp
(let ((quicklisp-init
        (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

; We'll reuse the optima pattern-matcher.  Its notation is more
; complex than cl-pattern, but it has more functionality and we need it.
(ql:quickload "optima")
(ql:quickload "readable")

(use-package :optima)
(readable:enable-sweet)

defun numeric-operationp (expr op-list)
  "Return t if expr is a numeric-only operation using an op in op-list."
  and
    consp expr
    member car(expr) op-list
    not null(cdr(expr))
    every #'numberp cdr(expr)

defun numberlistp (x)    {not(null(x)) and every(#'numberp x)}
defun more-than-onep (x) {consp(x) and consp(cdr(x))}

defun generous-zerop (x) {numberp(x) and {x = 0}}
defun generous-onep (x)  {numberp(x) and {x = 1}}

defun true-valuep (x)    {x eq 'true}
defun false-valuep (x)   {x eq 'false}

defun truthiness (x)
  if x 'true 'false

defun constant-valuep (x)
  {numberp(x) or eq(x 'pi) or eq(x 'e)}

; Implement "num" function, which forces numerical calculation.
; Numeric + - * / already computed using simplification, so no need to do that.
defun compute-numeric (x)
  cond
    eq(x 'pi) pi
    eq(x 'e)  exp(1)
    not(consp(x)) x
    numeric-operationp(x '(^))
      apply #'expt cdr(x)
    numeric-operationp(x '(log ln sin cos))
      apply car(x) cdr(x)
    t
      x

defun symbol-beginsp (sym start)
  "Returns t if symbol sym begins with string start."
  and
    symbolp(sym)
    {length(symbol-name(sym)) >= length(start)}
    string= subseq(symbol-name(sym) 0 length(start)) start

; We use a pattern language especially good for math expressions.
; The following converts our local pattern language into optima, so that
; we can use optima's optimizations and facilities.
; ?symbol is a variable, else symbol (and atom) is constant.
; "?args" matches 1+ arguments of a list.
; ?=symbol is a repeat of a previous symbol.
defun rewrite-match-pattern (x)
  cond
    eq(x '?args)
      'args
    eq(x '_)
      x
    symbol-beginsp(x "?=")
      list 'eql intern(substring(symbol-name(x) 2))
    symbol-beginsp(x "?")
      intern substring(symbol-name(x) 1)
    member(x '(op args lhs rhs a b))
      error "Operation should have ?"  ; DEBUG
    symbolp(x)
      `quote(,x)
    atom(x)
      x
    consp(x)
      if eq(car(last(x)) '?args)
        ` list* ,@mapcar(#'rewrite-match-pattern x)
        ` list  ,@mapcar(#'rewrite-match-pattern x)

defun convert-math-patterns (x)
  cond
    null(x) x
    consp(x)
      cons
        cons
          rewrite-match-pattern car(car(x))
          cdr car(x)
        convert-math-patterns cdr(x)

defmacro math-patterns (expr &rest patterns)
  ` optima:match ,expr
      ,@ convert-math-patterns patterns

defun simplify-expression (expr)
  "Simplify one expression (its operands have already been simplified)."
  math-patterns expr
    *(?args) when find(0 args)
      0
    and(?args) when find('false args)
      'false
    ; In general, any undef propogates as undef:
    (?args) when find('undef args)
      'undef
    ?op(?args) when {member(op '(+ - *)) and numberlistp(args)}
      apply op args
    ?op(?args) when {member(op '(= < <= > >=)) and numberlistp(args)}
      truthiness $ apply op args
    <>(?args) when numberlistp(args)
      truthiness $ apply #'/= args
    +(?args) when find(0 args)
      simplify-expression `(+ ,@remove-if(#'generous-zerop args))
    *(?args) when find(1 args)
      simplify-expression `(* ,@remove-if(#'generous-onep args))
    and(?args) when find('true args)
      simplify-expression `(and ,@remove-if(#'true-valuep args))
    or(?args) when find('true args)
      'true
    or(?args) when find('false args)
      simplify-expression `(or ,@remove-if(#'false-valuep args))
    {?lhs / ?rhs} when {integerp(lhs) and integerp(rhs) and {rhs /= 0}}
      {lhs / rhs}
    {?lhs ^ ?rhs} when {integerp(lhs) and integerp(rhs) and {rhs >= 2}}
      expt lhs rhs
    ?op(?args) when {member(op '(+ *)) and {length(args) >= 2} and
                      {length(remove-if-not(#'numberp args)) > 1}}
      ; Mixed numbers and symbols - simplify just the numbers.
      simplify-expression
        append
           list op
             apply op remove-if-not(#'numberp args)
           remove-if #'numberp args
    +(?a)                          a
    *(?a)                          a
    +()                            0
    or()                           'false
    *()                            1
    and()                          'true
    {?a + 0}                       a
    {?a + ?=a}                     `{2 * ,a}
    {?a - 0}                       a
    {0 - ?a}                       `-(,a)
    {?a - ?=a}                     0
    {?a + -(?=a)}                  0
    {?a * 1}                       a
    {1 * ?a}                       a
    {?a * ?=a}                     `{,a ^ 2}
    {?a * ?=a * ?=a}               `{,a ^ 3}
    {?a / 0}                       'undef
    {?a / 1}                       a
    {?a / ?=a}                     1
    {0 ^ 0}                        'undef
    {?a ^ 0}                       1
    {0 ^ ?a}                       0
    {1 ^ ?a}                       1
    {?a ^ 1}                       a
    {?a ^ -1}                      `{1 / ,a}
    {{?a * ?b} / ?=a}              b
    {{?b * ?a} / ?=a}              b
    {?a * {?b / ?=a}}              b
    {{?b / ?a} * ?=a}              b
    log(0)                         'undef
    log(0 _)                       'undef
    log(1)                         0
    log(1 _)                       0
    log(?a ?=a)                    1
    ln(0)                          'undef
    ln(e)                          1
    sin(0)                         0
    sin(pi)                        0
    cos(0)                         1
    cos(pi)                        -1
    (d ?constant / d ?x)           when constant-valuep(constant) 0
    (d ?x / d ?=x)                 when symbolp(x)                1
    num(?arg)                      compute-numeric(arg) ; "num(...)" function
    /=(?args)                      `(<> ,@args)  ; Prefer "<>"
    (!= ?args)                     `(<> ,@args)
    {?a = ?=a}                     'true
    {?a <> ?=a}                    'false
    not(true)                      'false
    not(false)                     'true
    {false -> false}               'true
    {false -> true}                'true
    {true -> false}                'false
    {true -> true}                 'true
    if(true ?tside)                tside
    if(true ?tside ?fside)         tside
    if(false ?tside)               'undef
    if(false ?tside ?fside)        fside
    ?a                             a

defun simplify-all (expr)
  "Simplify an expression: first its operands, then the whole thing."
  if atom(expr)
     expr
     simplify-expression mapcar(#'simplify-all expr)

princ "Math - Simplify possibly-symbolic math sweet-expressions."
terpri()
princ "Examples: {3 * {1 + 2}}, cos(0), {x + {y * 0}}"
terpri()
terpri()

princ "Please enter expressions to be simplified:"
terpri()
loop for line = read-preserving-whitespace(*standard-input* nil :eof)
     until \\ eq line :eof
     do \\ progn
       readable:write-readable simplify-all(line) :case :downcase
       terpri()

(readable:disable-readable)
