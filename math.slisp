; math.slisp - demonstrate math simplification system
; by David A. Wheeler
; Demonstrates using sweet-expressions in Common Lisp.
; This program focuses on returning exact results where possible.

; There are many implementations of Computer Algebra Systems (CASs)
; in Common Lisp, but they typically have to implement their own reader
; because the built-in reader is so painful to use.
; You *can* implement your own language, of course, but having a
; built-in notation that's easier to use makes it easier to move on
; to actually solving problems instead.  So this demonstration
; shows *using* sweet-expressions to write the program, *and* uses
; sweet-expressions as the input notation.

; To run test suite: "make check-math"

#-quicklisp
(let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

; We'll reuse the optima pattern-matcher.  Its notation is more
; complex than cl-pattern, but it has more functionality and we need it.
(ql:quickload "optima")
(ql:quickload "readable")

(use-package :optima)
(readable:enable-sweet)

; These optima patterns are like optima's "list" and "list*", but inline.
defpattern ilist (arg)
  when consp(arg)
   ` cons ,car(arg) ilist(,cdr(arg))

defpattern ilist* (arg)
  if null(cdr(arg))
      ` and ,car(arg) type(list)
      ` cons ,car(arg) ilist*(,cdr(arg))

; Return t if expr is a numeric-only operation using an op in op-list
defun numeric-operationp (expr op-list)
  and
    consp expr
    member car(expr) op-list
    not null(cdr(expr))
    every #'numberp cdr(expr)

defun more-than-onep (x) {consp(x) and consp(cdr(x))}

defun generous-zerop (x) {numberp(x) and {x = 0}}

defun generous-onep (x)  {numberp(x) and {x = 1}}

defun constant-valuep (x)
  {numberp(x) or eq(x 'pi) or eq(x 'e)}

; Implement "num" function, which forces numerical calculation.
; Numeric + - * / already computed using simplification, so no need to do that.
defun compute-numeric (x)
  cond
    eq(x 'pi) pi
    eq(x 'e)  exp(1)
    not(consp(x)) x
    numeric-operationp(x '(^))
      apply #'expt cdr(x)
    numeric-operationp(x '(log ln sin cos))
      apply car(x) cdr(x)
    t
      x

defun simplify-using-pattern (expr)
  optima:match expr
    list('+ a)                     a
    list('* a)                     a
    list('+)                       0
    list('*)                       1
    ilist{a '+ eql(a)}             `{2 * ,a}
    ilist{a '- 0}                  a
    ilist{0 '- a}                  `-(,a)
    ilist{a '- eql(a)}             0
    ilist{a '+ list('- eql(a))}    0
    ilist{a '* 1}                  a
    ilist{1 '* a}                  a
    ilist{a '* eql(a)}             `{,a ^ 2}
    ilist{a '* eql(a) '* eql(a)}   `{,a ^ 3}
    ilist{a '/ 0}                  'undef
    ilist{a '/ 1}                  a
    ilist{a '/ eql(a)}             1
    ilist{0 '^ 0}                  'undef
    ilist{a '^ 0}                  1
    ilist{0 '^ a}                  0
    ilist{1 '^ a}                  1
    ilist{a '^ 1}                  a
    ilist{a '^ -1}                 `{1 / ,a}
    ilist{ilist{a '* b} '/ eql(a)} b
    ilist{ilist{b '* a} '/ eql(a)} b
    ilist{a '* ilist{b '/ eql(a)}} b
    ilist{ilist{b '/ a} '* eql(a)} b
    list('log 0)                   'undef
    list('log 0 _)                 'undef
    list('log 1)                   0
    list('log 1 _)                 0
    list('log a eql(a))            1
    list('ln 0)                    'undef
    list('ln e)                    1
    list('sin 0)                   0
    list('sin 'pi)                 0
    list('cos 0)                   1
    list('cos 'pi)                 -1
    list('d constant '/ 'd x)      when constant-valuep(constant) 0
    list('d x '/ 'd (eql x))       when symbolp(x)                1
    list('num arg)                 compute-numeric(arg) ; "num(...)" function
    a                              a

defun simplify-expression (expr)
  "Simplify one expression (its operands have already been simplified)."
  cond
    ; If we can do straight-up exact numerical calculations, do it:
    numeric-operationp(expr '(+ - *))
      apply car(expr) cdr(expr)
    {eq(car(expr) '+) and find(0 cdr(expr))} ; Remove zeros from +
      simplify-expression $ cons '+ remove-if(#'generous-zerop cdr(expr))
    {eq(car(expr) '*) and find(1 cdr(expr))} ; Remove ones from *
      simplify-expression $ cons '* remove-if(#'generous-onep cdr(expr))
    {eq(car(expr) '*) and find(0 cdr(expr))} ; Any 0 in *
      0
    {numeric-operationp(expr '(/)) and ; Division, avoid divide by zero.
     more-than-onep(cdr(expr)) and
     notany(#'zerop cddr(expr))}
      apply car(expr) cdr(expr)
    {numeric-operationp(expr '(^)) and integerp(second(expr)) and
     integerp(third(expr)) and {third(expr) >= 2}}
      apply #'expt cdr(expr)
    {member(car(expr) '(+ *)) and {length(expr) >= 3} and
     {length(remove-if(complement(#'numberp) expr)) > 1}}
     ; Mixed numbers and symbols - simplify just the numbers.
     simplify-expression $ append
         list car(expr)
           apply car(expr) remove-if(complement(#'numberp) expr)
         remove-if #'numberp cdr(expr)
    {consp(expr) and find('undef expr)}  ; undef normally dominates.
      'undef
    t
      simplify-using-pattern expr

defun simplify-all (expr)
  "Simplify an expression; first its operands, then the whole thing."
  if atom(expr)
     expr
     simplify-expression mapcar(#'simplify-all expr)

princ "Math - Simplify possibly-symbolic math sweet-expressions."
terpri()
princ "Examples: {3 * {1 + 2}}, cos(0), {x + {y * 0}}"
terpri()
terpri()

princ "Please enter expressions to be simplified:"
terpri()
loop for line = read-preserving-whitespace(*standard-input* nil :eof)
     until \\ eq line :eof
     do \\ progn
       readable:write-readable simplify-all(line) :case :downcase
       terpri()

(readable:disable-readable)
