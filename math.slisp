; math.slisp - demonstrate math simplification system
; by David A. Wheeler
; Demonstrates using sweet-expressions in Common Lisp.
; This program focuses on returning exact results where possible.

; There are many implementations of Computer Algebra Systems (CASs)
; in Common Lisp, but they typically have to implement their own reader
; because the built-in reader is so painful to use.
; You *can* implement your own language, of course, but having a
; built-in notation that's easier to use makes it easier to move on
; to actually solving problems instead.  So this demonstration
; shows *using* sweet-expressions to write the program, *and* uses
; sweet-expressions as the input notation.

; To run test suite: "make check-math"

#-quicklisp
(let ((quicklisp-init
        (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

; We'll reuse the optima pattern-matcher.  Its notation is more
; complex than cl-pattern, but it has more functionality and we need it.
(ql:quickload "optima")
(ql:quickload "readable")

(use-package :optima)
(readable:enable-sweet)

defun numeric-operationp (expr op-list)
  "Return t if expr is a numeric-only operation using an op in op-list."
  and
    consp expr
    member car(expr) op-list
    not null(cdr(expr))
    every #'numberp cdr(expr)

defun numberlistp (x)    {not(null(x)) and every(#'numberp x)}
defun more-than-onep (x) {consp(x) and consp(cdr(x))}
defun generous-zerop (x) {numberp(x) and {x = 0}}
defun generous-onep (x)  {numberp(x) and {x = 1}}

defun true-valuep (x)    {x eq 'true}
defun false-valuep (x)   {x eq 'false}

defun truthiness (x)
  if x 'true 'false

defun constant-valuep (x)
  {numberp(x) or eq(x 'pi) or eq(x 'e)}

defun filter (pred list)
  remove-if complement(pred) list

; Implement "num" function, which forces numerical calculation.
; Numeric + - * / already computed using simplification, so no need to do that.
defun compute-numeric (x)
  cond
    eq(x 'pi) pi
    eq(x 'e)  exp(1)
    not(consp(x)) x
    numeric-operationp(x '(^))
      apply #'expt cdr(x)
    numeric-operationp(x '(log ln sin cos))
      apply car(x) cdr(x)
    t
      x

defun symbol-beginsp (sym start)
  "Returns t if symbol sym begins with string start."
  and
    symbolp(sym)
    {length(symbol-name(sym)) >= length(start)}
    string= subseq(symbol-name(sym) 0 length(start)) start

; If simplification makes it better, return it, otherwise fail.
defmacro simplify-all-if-can (expr)
  ` let* <* old-expr ,expr \\ new-expr simplify-all(old-expr) *>
    if equal(old-expr new-expr)
      fail()
      new-expr

; We use a pattern language especially good for math expressions.
; The following converts our local pattern language into optima, so that
; we can use optima's optimizations and facilities.
; ?symbol is a variable, else symbol (and atom) is constant.
; "?args" matches 1+ arguments of a list.
; ?=symbol is a repeat of a previous symbol.
defun rewrite-match-pattern (x)
  cond
    eq(x '?args)
      'args
    eq(x '?n-args)
      '(guard args (numberlistp args))  ; list of only numbers
    eq(x '_)
      x
    symbol-beginsp(x "?=")
      list 'eql intern(substring(symbol-name(x) 2))
    symbol-beginsp(x "?")
      intern substring(symbol-name(x) 1)
    member(x '(op args lhs rhs a b))
      error "Operation should have ?"  ; DEBUG
    symbolp(x)
      `quote(,x)
    atom(x)
      x
    consp(x)
      if member(car(last(x)) '(?args ?n-args))
        ` list* ,@mapcar(#'rewrite-match-pattern x)
        ` list  ,@mapcar(#'rewrite-match-pattern x)

defun convert-math-patterns (x)
  cond
    null(x) x
    consp(x)
      cons
        cons
          rewrite-match-pattern car(car(x))
          cdr car(x)
        convert-math-patterns cdr(x)

defmacro math-patterns (expr &rest patterns)
  ` optima:match ,expr
      ,@ convert-math-patterns patterns

defun simplify-expression (expr)
  "Simplify one expression (its operands have already been simplified)."
  math-patterns expr
    *(?args) when find(0 args)
      0
    and(?args) when find('false args)
      'false
    ; In general, any undef propagates as undef:
    (?args) when find('undef args)
      'undef
    ?op(?n-args) when member(op '(+ - *))
      apply op args
    ?op(?n-args) when member(op '(= < <= > >=))
      truthiness $ apply op args
    <>(?n-args)
      truthiness $ apply #'/= args
    +(?args) when find(0 args)
      simplify-expression `(+ ,@remove-if(#'generous-zerop args))
    *(?args) when find(1 args)
      simplify-expression `(* ,@remove-if(#'generous-onep args))
    and(?args) when find('true args)
      simplify-expression `(and ,@remove-if(#'true-valuep args))
    or(?args) when find('true args)
      'true
    or(?args) when find('false args)
      simplify-expression `(or ,@remove-if(#'false-valuep args))
    {?lhs / ?rhs} when {integerp(lhs) and integerp(rhs) and {rhs /= 0}}
      {lhs / rhs}
    {?lhs ^ ?rhs} when {integerp(lhs) and integerp(rhs) and {rhs >= 2}}
      expt lhs rhs
    +(?args) when {{length(args) >= 2} and
                   {length(filter(#'numberp args)) > 1}}
      simplify-expression
        `(+ ,@remove-if(#'numberp args) ,apply('+ filter(#'numberp args)))
    *(?args) when {{length(args) >= 2} and
                   {length(filter(#'numberp args)) > 1}}
      simplify-expression
        `(* ,apply('* filter(#'numberp args)) ,@remove-if(#'numberp args))
    +(?a)                          a
    *(?a)                          a
    +()                            0
    or()                           'false
    *()                            1
    and()                          'true
    {?a + 0}                       a
    {?a + ?=a}                     `{2 * ,a}
    {?a - 0}                       a
    {0 - ?a}                       `-(,a)
    {?a - ?=a}                     0
    {?a + -(?=a)}                  0
    {?a * 1}                       a
    {1 * ?a}                       a
    {?a * ?=a}                     `{,a ^ 2}
    {?a * ?=a * ?=a}               `{,a ^ 3}
    {?a / 0}                       'undef
    {?a / 1}                       a
    {?a / ?=a}                     simplify-all(`if({,a <> 0} 1))
    {0 ^ 0}                        'undef
    {?a ^ 0}                       1
    {0 ^ ?a}                       0
    {1 ^ ?a}                       1
    {?a ^ 1}                       a
    {?a ^ -1}                      `{1 / ,a}
    {{?a - ?b} <> 0}               simplify-expression(`{,a <> ,b})
    {{?a * ?b} / ?=a}              simplify-all(`if({,a <> 0} ,b))
    {{?b * ?a} / ?=a}              simplify-all(`if({,a <> 0} ,b))
    {?a * {?b / ?=a}}              simplify-all(`if({,a <> 0} ,b))
    {{?b / ?a} * ?=a}              simplify-all(`if({,a <> 0} ,b))
    {?n + ?a} when numberp(n)      `{,a + ,n}
    {?a * ?n} when numberp(n)      `{,n * ,a}
    log(0)                         'undef
    log(0 _)                       'undef
    log(1)                         0
    log(1 _)                       0
    log(?a ?=a)                    1
    ln(0)                          'undef
    ln(e)                          1
    sin(0)                         0
    sin(pi)                        0
    cos(0)                         1
    cos(pi)                        -1
    (d ?x / d ?=x)                 when symbolp(x)                1
    (d ?constant / d ?x)           when constant-valuep(constant) 0
    (d ?y / d ?x)                  when symbolp(y)                0
    (d +(?args) / d ?x)
      simplify-all-if-can `(+ ,@mapcar(lambda((expr) `(d ,expr / d ,x)) args))
    (d -(?args) / d ?x)
      simplify-all-if-can `(- ,@mapcar(lambda((expr) `(d ,expr / d ,x)) args))
    (d {?f * ?g} / d ?x)
      simplify-all-if-can `{{(d ,f / d ,x) * ,g} + {,f * (d ,g / d ,x)}}
    (d {?x ^ ?n} / d ?=x) when {numberp(n) and {n /= 0}}
      `{,n * {,x ^ ,{n - 1}}}      ; Power rule
    num(?arg)                      compute-numeric(arg) ; "num(...)" function
    /=(?args)                      `(<> ,@args)  ; Prefer "<>"
    (!= ?args)                     `(<> ,@args)
    {?a = ?=a}                     'true
    {?a <> ?=a}                    'false
    not(true)                      'false
    not(false)                     'true
    {false -> false}               'true
    {false -> true}                'true
    {true -> false}                'false
    {true -> true}                 'true
    if(true ?tside)                tside
    if(true ?tside ?fside)         tside
    if(false ?tside)               'undef
    if(false ?tside ?fside)        fside
    ?a                             a

defun simplify-all (expr)
  "Simplify an expression: first its operands, then the whole thing."
  if atom(expr)
     expr
     simplify-expression mapcar(#'simplify-all expr)

princ "Math - Simplify possibly-symbolic math sweet-expressions."
terpri()
princ "Examples: {3 * {1 + 2}}, cos(0), {x + {y * 0}}"
terpri()
terpri()

princ "Please enter expressions to be simplified:"
terpri()
loop for line = read-preserving-whitespace(*standard-input* nil :eof)
     until \\ eq line :eof
     do \\ progn
       readable:write-readable simplify-all(line) :case :downcase
       terpri()

(readable:disable-readable)
