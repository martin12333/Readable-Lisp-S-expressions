; math.slisp - demonstrate math simplification system
; by David A. Wheeler
; Demonstrates using sweet-expressions in Common Lisp.
; This program focuses on returning exact results where possible.

; There are many implementations of Computer Algebra Systems (CASs)
; in Common Lisp, but they typically have to implement their own reader
; because the built-in reader is so painful to use.
; You *can* implement your own language, of course, but having a
; built-in notation that's easier to use makes it easier to move on
; to actually solving problems instead.  So this demonstration
; shows *using* sweet-expressions to write the program, *and* uses
; sweet-expressions as the input notation.

; To run test suite: "make check-math"

#-quicklisp
(let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

; We'll reuse the optima pattern-matcher.  Its notation is more
; complex than cl-pattern, but it has more functionality and we need it.
(ql:quickload "optima")
(ql:quickload "readable")

(use-package :optima)
(readable:enable-sweet)

; These optima patterns are like optima's "list" and "list*", but inline.
defpattern ilist (arg)
  when consp(arg)
   ` cons ,car(arg) ilist(,cdr(arg))

defpattern ilist* (arg)
  if null(cdr(arg))
      ` and ,car(arg) type(list)
      ` cons ,car(arg) ilist*(,cdr(arg))

; Return t if expr is a numeric-only operation using an op in op-list
defun numeric-operationp (expr op-list)
  and
    consp expr
    member car(expr) op-list
    not null(cdr(expr))
    every #'numberp cdr(expr)

defun numberlistp (x)
  {not(null(x)) and every(#'numberp x)}

defun more-than-onep (x) {consp(x) and consp(cdr(x))}

defun generous-zerop (x) {numberp(x) and {x = 0}}

defun generous-onep (x)  {numberp(x) and {x = 1}}

defun true-valuep (x)  {x eq 'true}
defun false-valuep (x)  {x eq 'false}

defun constant-valuep (x)
  {numberp(x) or eq(x 'pi) or eq(x 'e)}

defun truthiness (x)
  if x 'true 'false

; Implement "num" function, which forces numerical calculation.
; Numeric + - * / already computed using simplification, so no need to do that.
defun compute-numeric (x)
  cond
    eq(x 'pi) pi
    eq(x 'e)  exp(1)
    not(consp(x)) x
    numeric-operationp(x '(^))
      apply #'expt cdr(x)
    numeric-operationp(x '(log ln sin cos))
      apply car(x) cdr(x)
    t
      x

; We use a pattern language especially good for math expressions.
; The following converts our local pattern language into optima, so that
; we can use optima's optimizations and facilities.
; ?symbol is a variable, else symbol (and atom) is constant.
; "?args" matches 1+ arguments of a list.
; ?=symbol is a repeat of a previous symbol.
defun rewrite-match-pattern (x)
  cond
    eq(x '?args)
      'args
    eq(x '_)
      x
    {symbolp(x) and equal(char(symbol-name(x) 0) #\?)}
      if equal(char(symbol-name(x) 1) #\=)
         list 'eql intern(substring(symbol-name(x) 2))
         intern(substring(symbol-name(x) 1))
    member(x '(op args lhs rhs a b))
      error "Operation should have ?"  ; DEBUG
    symbolp(x)
      `quote(,x)
    atom(x)
      x
    consp(x)
      if eq(car(last(x)) '?args)
        ` list* ,@mapcar(#'rewrite-match-pattern x)
        ` list  ,@mapcar(#'rewrite-match-pattern x)

defun convert-math-patterns (x)
  cond
    null(x) x
    consp(x)
      cons
        cons
          rewrite-match-pattern car(car(x))
          cdr car(x)
        convert-math-patterns cdr(x)

defmacro math-patterns (expr &rest patterns)
  ` optima:match ,expr
      ,@ convert-math-patterns patterns

defun simplify-expression (expr)
  "Simplify one expression (its operands have already been simplified)."
  math-patterns expr
    (* ?args)
      when \\ find 0 args
      0
    {?a + 0}
      a
    (and ?args)
      when \\ find 'false args
      'false
    (?args)
      when \\ find('undef args)
      'undef
    (?op ?args)
      when \\ {member(op '(+ - *)) and numberlistp(args)}
      apply op args
    (?op ?args)
      when \\ {member(op '(= < <= > >=)) and numberlistp(args)}
      truthiness $ apply op args
    (<> ?args)
      when \\ numberlistp(args)
      truthiness $ apply #'/= args
    (+ ?args)
      when \\ find 0 args
      simplify-expression $ cons '+ remove-if(#'generous-zerop args)
    (* ?args)
      when \\ find 1 args
      simplify-expression $ cons '* remove-if(#'generous-onep args)
    (and ?args)
      when \\ find 'true args
      simplify-expression $ cons 'and remove-if(#'true-valuep args)
    (or ?args)
      when \\ find 'false args
      simplify-expression $ cons 'or remove-if(#'false-valuep args)
    (or ?args)
      when \\ find 'true args
      'true
    {?lhs / ?rhs}
      when \\ {integerp(lhs) and integerp(rhs) and {rhs /= 0}}
      {lhs / rhs}
    {?lhs ^ ?rhs}
      when \\ {integerp(lhs) and integerp(rhs) and {rhs >= 2}}
      expt lhs rhs
    (?op ?args)
      when \\ {member(op '(+ *)) and {length(args) >= 2} and
               {length(remove-if(complement(#'numberp) args)) > 1}}
      ; Mixed numbers and symbols - simplify just the numbers.
      simplify-expression
        append
          list op
            apply op remove-if(complement(#'numberp) args)
          remove-if #'numberp args
    (+ ?a)                         a
    (* ?a)                         a
    (+)                            0
    (or)                           'false
    (*)                            1
    (and)                          'true
    {?a + ?=a}                     `{2 * ,a}
    {?a - 0}                       a
    {0 - ?a}                       `-(,a)
    {?a - ?=a}                     0
    {?a + (- ?=a)}                 0
    {?a * 1}                       a
    {1 * ?a}                       a
    {?a * ?=a}                     `{,a ^ 2}
    {?a * ?=a * ?=a}               `{,a ^ 3}
    {?a / 0}                       'undef
    {?a / 1}                       a
    {?a / ?=a}                     1
    {0 ^ 0}                        'undef
    {?a ^ 0}                       1
    {0 ^ ?a}                       0
    {1 ^ ?a}                       1
    {?a ^ 1}                       a
    {?a ^ -1}                      `{1 / ,a}
    {{?a * ?b} / ?=a}              b
    {{?b * ?a} / ?=a}              b
    {?a * {?b / ?=a}}              b
    {{?b / ?a} * ?=a}              b
    log(0)                         'undef
    log(0 _)                       'undef
    log(1)                         0
    log(1 _)                       0
    log(?a ?=a)                    1
    ln(0)                          'undef
    ln(e)                          1
    sin(0)                         0
    sin(pi)                        0
    cos(0)                         1
    cos(pi)                        -1
    (d ?constant / d ?x)           when constant-valuep(constant) 0
    (d ?x / d ?=x)                 when symbolp(x)                1
    num(?arg)                      compute-numeric(arg) ; "num(...)" function
    (/= ?args)                     `(<> ,@args)  ; Prefer "<>"
    (!= ?args)                     `(<> ,@args)
    {?a = ?=a}                     'true
    not(true)                      'false
    not(false)                     'true
    {false -> false}               'true
    {false -> true}                'true
    {true -> false}                'false
    {true -> true}                 'true
    if(true ?tside)                tside
    if(true ?tside ?fside)         tside
    if(false ?tside)               'undef
    if(false ?tside ?fside)        fside
    ?a                             a

defun simplify-all (expr)
  "Simplify an expression: first its operands, then the whole thing."
  if atom(expr)
     expr
     simplify-expression mapcar(#'simplify-all expr)

princ "Math - Simplify possibly-symbolic math sweet-expressions."
terpri()
princ "Examples: {3 * {1 + 2}}, cos(0), {x + {y * 0}}"
terpri()
terpri()

princ "Please enter expressions to be simplified:"
terpri()
loop for line = read-preserving-whitespace(*standard-input* nil :eof)
     until \\ eq line :eof
     do \\ progn
       readable:write-readable simplify-all(line) :case :downcase
       terpri()

(readable:disable-readable)
