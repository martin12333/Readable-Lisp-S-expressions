; math.slisp - math expression simplifier
; by David A. Wheeler
; This simplifies various math expressions, returning exact results.
; Its real purpose is to demonstrate sweet-expressions in Common Lisp.
; This is a pattern rule based system.

; MIT license.
; Copyright (c) 2014 David A. Wheeler
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
; 
; The above copyright notice and this permission notice shall be included in
; all copies or substantial portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
; THE SOFTWARE.

; To run test suite: "make check-math"

#-quicklisp
(let ((quicklisp-init
        (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))

; We'll reuse the optima pattern-matcher.  Its notation is more
; complex than cl-pattern, but it has more functionality and we need it.
(ql:quickload "optima")
(ql:quickload "readable")

(use-package :optima)
(readable:enable-sweet)

defun numeric-operationp (expr op-list)
  "Return t if expr is a numeric-only operation using an op in op-list."
  and
    consp expr
    member car(expr) op-list
    not null(cdr(expr))
    every #'numberp cdr(expr)

defun numberlistp (x)    {not(null(x)) and every(#'numberp x)}
defun more-than-onep (x) {consp(x) and consp(cdr(x))}
defun lastvalue (x)      car(last(x))
defun generous-zerop (x) {numberp(x) and {x = 0}}
defun generous-onep (x)  {numberp(x) and {x = 1}}

defun true-valuep (x)    {x eq 'true}
defun false-valuep (x)   {x eq 'false}

defun truthiness (x) ; Convert Common Lisp truth value to our notation.
  if x 'true 'false

defun constant-valuep (x)
  {numberp(x) or eq(x 'pi) or eq(x 'e)}

defun filter (pred list)
  remove-if complement(pred) list

; Implement "num" function, which forces numerical calculation.
; Numeric + - * / already computed using simplification, so no need to do that.
defun compute-numeric (x)
  cond
    eq(x 'pi) pi
    eq(x 'e)  exp(1)
    not(consp(x)) x
    numeric-operationp(x '(^))
      apply #'expt cdr(x)
    numeric-operationp(x '(log ln sin cos))
      apply car(x) cdr(x)
    t
      x

defun symbol-beginsp (sym start)
  "Returns t if symbol sym begins with string start."
  and
    symbolp(sym)
    {length(symbol-name(sym)) >= length(start)}
    string= subseq(symbol-name(sym) 0 length(start)) start

; If simplification makes it better, return it, otherwise fail.
defmacro simplify-all-if-can (expr)
  ` let* <* old-expr ,expr \\ new-expr simplify-all(old-expr) *>
    if equal(old-expr new-expr)
      fail()
      new-expr

; We use a pattern language especially good for math expressions.
; The following converts our local pattern language into optima, so that
; we can use optima's optimizations and facilities.
; ?symbol is a variable, else symbol (and atom) is constant.
; "?args" matches 1+ arguments of a list.
; ?=symbol is a repeat of a previous symbol.
defun rewrite-match-pattern (x)
  cond
    eq(x '?args)
      'args
    eq(x '?n-args)
      '(guard args (numberlistp args))  ; list of only numbers
    eq(x '_)
      x
    symbol-beginsp(x "?=")
      list 'eql intern(substring(symbol-name(x) 2))
    symbol-beginsp(x "?")
      intern substring(symbol-name(x) 1)
    member(x '(op args lhs rhs a b))
      error "Operation should have ?"  ; DEBUG
    symbolp(x)
      `quote(,x)
    atom(x)
      x
    consp(x)
      if member(car(last(x)) '(?args ?n-args))
        ` list* ,@mapcar(#'rewrite-match-pattern x)
        ` list  ,@mapcar(#'rewrite-match-pattern x)

defun convert-math-patterns (x)
  cond
    null(x) x
    consp(x)
      cons
        cons
          rewrite-match-pattern car(car(x))
          cdr car(x)
        convert-math-patterns cdr(x)

defmacro math-patterns (expr &rest patterns)
  ` optima:match ,expr
      ,@ convert-math-patterns patterns

defun simplify-expression (expr)
  "Simplify one expression (its operands have already been simplified)."
  math-patterns expr
    *(?args) when find(0 args)
      0
    and(?args) when find('false args)
      'false
    ; In general, any undef propagates as undef:
    (?args) when find('undef args)
      'undef
    ?op(?n-args) when member(op '(+ - *))
      apply op args
    ?op(?n-args) when member(op '(= < <= > >=))
      truthiness $ apply op args
    <>(?n-args)
      truthiness $ apply #'/= args
    +(?args) when find(0 args)
      simplify-expression `(+ ,@remove-if(#'generous-zerop args))
    *(?args) when find(1 args)
      simplify-expression `(* ,@remove-if(#'generous-onep args))
    and(?args) when find('true args)
      simplify-expression `(and ,@remove-if(#'true-valuep args))
    or(?args) when find('true args)
      'true
    or(?args) when find('false args)
      simplify-expression `(or ,@remove-if(#'false-valuep args))
    {?lhs / ?rhs} when {integerp(lhs) and integerp(rhs) and {rhs /= 0}}
      {lhs / rhs}
    {?lhs ^ ?rhs} when {integerp(lhs) and integerp(rhs) and {rhs >= 2}}
      expt lhs rhs
    +(?args) when {{length(args) >= 2} and
                   {length(filter(#'numberp args)) > 1}}
      simplify-expression
        `(+ ,@remove-if(#'numberp args) ,apply('+ filter(#'numberp args)))
    *(?args) when {{length(args) >= 2} and
                   {length(filter(#'numberp args)) > 1}}
      simplify-expression
        `(* ,apply('* filter(#'numberp args)) ,@remove-if(#'numberp args))
    +(?a)                          a
    *(?a)                          a
    +()                            0
    or()                           'false
    *()                            1
    and()                          'true
    {?a + 0}                       a
    {?a + ?=a}                     simplify-expression(`{2 * ,a})
    {?a - 0}                       a
    {0 - ?a}                       `-(,a)
    {?a - ?=a}                     0
    {?a + -(?=a)}                  0
    {?a * 1}                       a
    {1 * ?a}                       a
    {?a * ?=a}                     `{,a ^ 2}
    {?a * ?=a * ?=a}               `{,a ^ 3}
    {?a / 0}                       'undef
    {?a / 1}                       a
    {?a / ?=a}                     simplify-all(`if({,a <> 0} 1))
    {0 ^ 0}                        'undef
    {?a ^ 0}                       1
    {0 ^ ?a}                       0
    {1 ^ ?a}                       1
    {?a ^ 1}                       a
    {?a ^ -1}                      `{1 / ,a}
    {{?a - ?b} <> 0}               simplify-expression(`{,a <> ,b})
    {{?a * ?b} / ?=a}              simplify-all(`if({,a <> 0} ,b))
    {{?b * ?a} / ?=a}              simplify-all(`if({,a <> 0} ,b))
    {?a * {?b / ?=a}}              simplify-all(`if({,a <> 0} ,b))
    {{?b / ?a} * ?=a}              simplify-all(`if({,a <> 0} ,b))
    {?a * *(?args)}                simplify-expression(`*(,a ,@args))
    {?a + +(?args)}                simplify-expression(`+(,a ,@args))
    log(0)                         'undef
    log(0 _)                       'undef
    log(1)                         0
    log(1 _)                       0
    log(?a ?=a)                    1
    ln(0)                          'undef
    ln(e)                          1
    sin(0)                         0
    sin{pi / 2}                    1
    sin{1/2 * pi}                  1
    sin(pi)                        0
    sin{3/2 * pi}                  -1
    sin{{3 * pi} / 2}              -1
    sin{2 * pi}                    0
    cos(0)                         1
    cos{pi / 2}                    0
    cos{1/2 * pi}                  0
    cos(pi)                        -1
    cos{3/2 * pi}                  0
    cos{{3 * pi} / 2}              0
    cos{2 * pi}                    1
    tan(0)                         0
    tan(pi)                        0
    deriv(?x ?=x)                  when symbolp(x)                1
    deriv(?constant ?x)            when constant-valuep(constant) 0
    deriv(?y ?x)                   when symbolp(y)                0
    deriv(+(?args) ?x)
      simplify-all-if-can `+(,@mapcar(lambda((expr) `deriv(,expr ,x)) args))
    deriv(-(?args) ?x)
      simplify-all-if-can `-(,@mapcar(lambda((expr) `deriv(,expr ,x)) args))
    deriv({?f * ?g} ?x)
      simplify-all-if-can `{{deriv(,f ,x) * ,g} + {,f * deriv(,g ,x)}}
    deriv({?f / ?g} ?x)
      simplify-all-if-can
        ` if {,g <> 0}
             {{{deriv(,f ,x) * ,g} - {,f * deriv(,g ,x)}} / {,g ^ 2}}
    deriv({?f ^ ?g} ?x)
      simplify-all
        `{ {,g * {,f ^ {,g - 1}} * deriv(,f ,x)}
         + {{,f ^ ,g} * log(,f)  * deriv(,g ,x)}}
    deriv(log(?f) ?x)              simplify-all(`{deriv(,f ,x) / ,f})
    deriv({e ^ ?f} ?x)             simplify-all(`{{e ^ ,f} * deriv(,f ,x)})
    deriv(sin(?f) ?x)              simplify-all(`{cos(,f) * deriv(,f ,x)})
    deriv(cos(?f) ?x)              simplify-all(`{-(sin(,f)) * deriv(,f ,x)})
    num(?arg)                      compute-numeric(arg) ; "num(...)" function
    /=(?args)                      `(<> ,@args)  ; Prefer "<>"
    (!= ?args)                     `(<> ,@args)
    {?a = ?=a}                     'true
    {?a <> ?=a}                    'false
    not(true)                      'false
    not(false)                     'true
    {false -> false}               'true
    {false -> true}                'true
    {true -> false}                'false
    {true -> true}                 'true
    if(true ?tside)                tside
    if(true ?tside ?fside)         tside
    if(false ?tside)               'undef
    if(false ?tside ?fside)        fside
    +(?args) when
      {{length(args) > 1} and not(numberp(lastvalue(args))) and
        some(#'numberp args)}
      `+(,@remove-if(#'numberp args) ,@filter(#'numberp args))
    *(?args) when
      {{length(args) > 1} and not(numberp(car(args))) and
        some(#'numberp args)}
      `*(,@filter(#'numberp args) ,@remove-if(#'numberp args))
    ?a                             a

defun simplify-all (expr)
  "Simplify an expression: first its operands, then the whole thing."
  if atom(expr)
     expr
     simplify-expression mapcar(#'simplify-all expr)

defun show-help ()
  dolist
    line
      ' <*
"Enter mathematical expressions, and this program prints simplified versions."
"Enter expressions in sweet-expression format. For example:"
"- Infix operations are surrounded by {...}, e.g., {3 + 4}"
"- Prefix operations can begin before parentheses, e.g., sin(0)"
"- Indent expressions to make them children of the main expression."
"Enter a blank line to complete an expression."
"This simplifier accepts symbolic expressions, e.g., {2 * x * 3 * y}."
"Supported operations are:"
" +, -, *, /, ^ : Infix add, subtract, multiply, divide, exponentiate."
" =, <>, <, <=, >, >=: Infix numeric comparision."
" and, or, ->: Infix (logical) and, (logical) or, implication."
" log(n [base]), ln(n), ln(n [base]): Logarithmic functions."
" sin(x), cos(x), tan(x): Trigonometric functions (radians)."
" undef, true, false: Constant values undefined, true, false."
" pi, e: Constant values pi (3.14159...) and e (2.71828...)."
" not(x): Logical negation."
" if(condition true-result [false-result]): If-then-else."
" deriv(expression variable): Derivative of expression w.r.t. variable."
"     Symbols are considered constants; use f(x) to represent a function."
" num(expression): Force numeric calculation of expression."
"This program doesn't compete with programs like Maxima.  However,"
"it is unusual in that it tracks undefined values e.g., by division-by-zero."
"For example, {z / z} simplifies to if({z <> 0} 1), not just 1."
"Number-only expressions with exact results simplify to that number."
"Examples: {3 * {1 + 2}} => 9, cos(0) => 0, {x + {y * 0}} => x,"
" {true and false} => false, deriv({x ^ 3} x) => {3 * {x ^ 2}}."
*>
    princ line
    terpri()

princ "Math - Simplify possibly-symbolic math sweet-expressions."
terpri()
princ "Examples: {3 * {1 + 2}}, cos(0), {x + {y * 0}}"
terpri()
terpri()

princ "Please enter expressions to be simplified (:help ENTER ENTER for help):"
terpri()
loop for line = read-preserving-whitespace(*standard-input* nil :eof)
     until \\ eq line :eof
     do \\ progn
       if eq(line :help)
         show-help()
         readable:write-readable simplify-all(line) :case :downcase
       terpri()

(readable:disable-readable)
