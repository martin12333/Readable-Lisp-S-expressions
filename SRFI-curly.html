<!DOCTYPE html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
<title>Readable Lisp S-expressions / Wiki / SRFI-Curly</title>
</head>
<body>

<h1 id="title">Title</h1>
<p>Curly-infix-expressions</p>

<h1 id="author">Author</h1>
<p>David A. Wheeler</p>

<h1 id="status">Status</h1>
<p>This is a draft SRFI.  To see an explanation of each status that a SRFI can hold, see <a href="http://srfi.schemers.org/srfi-process.html" rel="nofollow">here</a>.</p>
<p>To provide input on this SRFI, please  <a href="mailto:srfi%20minus%20???%20at%20srfi%20dot%20schemers%20dot%20org">mail to <code>&lt;srfi minus ??? at srfi dot schemers dot org&gt;</code></a>.  See  <a href="http://srfi.schemers.org/srfi-list-subscribe.html" rel="nofollow">instructions here</a> to subscribe to the list.  You can access previous messages via  <a href="http://srfi.schemers.org/mail-archive/maillist.html???" rel="nofollow">the archive of the mailing list</a>.</p>

<h1 id="related-srfis">Related SRFIs</h1>
<p>None</p>

<h1 id="abstract">Abstract</h1>
<p>Lisp-based languages, like Scheme, are almost the only programming languages in modern use that do not support infix notation.  Adding infix support to Scheme would eliminate a common complaint by developers who currently choose to use other languages.  Scheme currently reserves {...} "for possible future extensions to the language".  We propose that {...} be used to support "curly-infix" notation as a reader abbreviation, just as 'x is an abbreviation for (quote x). These are lists whose visual presentation is in infix order instead of prefix order.
For example, {n > 2} maps to (&gt; n 2); {a + b + c} maps to (+ a b c), and {- x} maps to (- x).  By intent; there is no precedence; forms implying precedence have "nfx" inserted instead to enable later macro processing, e.g., {2 + 3 * 5} maps to (nfx 2 + 3 * 5).</p>

<h1 id="rationale">Rationale</h1>
<p>Lisp-based languages, like Scheme, are almost the only programming languages in modern use that do not support infix notation.  Even some Lisp advocates, like Paul Graham, admit that they "don't find prefix math expressions natural." (<a href="http://www.paulgraham.com/pypar.html" rel="nofollow">http://www.paulgraham.com/pypar.html</a>)  Paul Prescod has said, "I have more faith that you could convince the world to use Esperanto than prefix notation."  Infix is not going away; nearly all new programming languages also include infix.  Adding infix support to Scheme would eliminate a common complaint by developers who currently choose to use other languages instead.</p>
<p>Scheme currently reserves {...} "for possible future extensions to the language".  We propose that {...} be used to support "curly-infix" notation as a reader abbreviation, just as 'x is an abbreviation for (quote x).</p>
<p>This proposal is an extremely <em>simple</em> and <em>straightforward</em> technique for supporting infix notation.  There is no complex precedence system, all other Scheme capabilities (including macros) work unchanged, and Scheme remains general and homoiconic. Curly-infix expressions are just a convenient reader abbreviation for infix notation, just like 'x is an abbreviation of (quote x). </p>
<p>Many previous systems have implemented "infix" systems as a named macro or procedure (e.g., INFIX).  This looks ugly, and it does the wrong thing - the resulting list always has INFIX at the beginning, not the actual infix operator, so this approach can interfere with quoting, macros, and other capabilities.  Many of these past systems also created a whole new notation which simultaneously lost Lisp's abilities for quoting, quasiquoting, and so on.  This proposal avoids these problems. For example, in curly-infix, '{a + b} maps cleanly to '(+ a b), which works as expected with all macros.</p>
<p>Many past "infix" systems for Lisp build in precedence.  However, Lisp systems often process other languages, freely mixing different languages, and thus the same symbol may have different meanings and precedence levels in different contexts.  The symbol might not even be defined where it is being used.  By avoiding precedence, a very simple yet useful infix system results.  In practice, we've found that simple infix is all that's needed most of the time.  By intentionally <em>not</em> building in a precedence system, we make things amazingly simple - we don't need to register procedures, decide their order, or anything like it.  It obviously would be possible to extend this mechanism to provide a precedence system (e.g., if an expression is not simple, attempt to use various precedence rules), but such capabilities would be extensions not required by this SRFI (though some future SRFI might add it somehow).</p>
<p>Some past efforts tried to automatically detect infix operators, but this turns out to not work well.  It's hard to express good rules for detecting infix operators, and the rules become too complex for users (e.g., "punctuation-only symbols" doesn't detect "and" or "or").  And in any case, if they were automatically detected, an escape mechanism would be needed anyway.  Allowing the user to expressly notate when infix was intended, using {...}, turns out to be far more clearer and more intuitive.  In particular, curly-infix allows the use of infix with any symbol, whenever you want... and where it's not convenient, you don't need to use it.  It is also very backwards-compatible: Normal lists work normally, and if you want infix, use {...}.</p>
<p>The "simple" curly-infix list accepts ordinary lists, merely written in a different order.  Its mapping is (even-parameter odd-parameters) so that more than two operands are handled clearly, e.g., {a + b + c} maps to (+ a b c).  The empty curly-infix list {} maps to (), as it <i>is</i> an empty list, and this is the likely user meaning (reducing unnecessary errors).  An escaping {e} is mapped to e to help other notations that build on curly-infix.  With this mapping, the neoteric-expression f{x} becomes (f x), the likely intended meaning, and it easily escapes sweet-expression symbols that would otherwise have other meanings.  The unary operation curly-infix list {e f} maps to (e f), so that {- x} maps to (- x), the likely interpretation, and so that the neoteric-expression f{- x} maps correctly to (f (- x)).</p>
<p>At first I considered reporting an error if a simple infix expression isn't provided, but prepending "nfx" is much more flexible.  Developers can then define macros or procedures called "nfx", or define processing systems that expect "nfx", to implement precedence systems if they desire.</p>
<p>Curly-infix requires that infix operators be delimited (e.g., by spaces).  This is consistent with Lisp history; operators are always delimited in traditional s-expressions (typically by left parentheses on the left, and space on the right).  It's also impractical to do otherwise; most Lisps, including Scheme, allow and predefine symbols that include characters (like "-") that are typically used for infix operators.  Many developers will put space around infix operators even in languages that don't require them, so syntactically requiring them is no burden.  In short, it is difficult to allow infix operators without delimiters, and the visual results are the same as many real-world uses in other languages, so the result appears quite customary to typical software developers.</p>
<p>If a reader implements this SRFI, we would like it to <em>always</em> be enabled.  However, we provide a conventional name for an implementation to turn it on, and a "enable-curly-infix" procedure to turn it on as well.  This way, implementors can make it optional in their "native" implementation, or to switch from whatever was their previous interpretation.  By having a standard mechanism for enabling it, we hope will encourage adoption.  Users should invoke "(enable-curly-infix)" before using curly-infix lists.  The "curly-infix-read" procedure allows reading external curly-infix data, even if the implementation doesn't implement it by default.</p>
<p>By intent, this SRFI (including the enabling mechanism) doesn't use or interact with any module system at all (including the R6RS and R7RS module systems).  This is because some implementations won't have a module system (or at least not a standard one). Curly-infix is an intentionally simple mechanism that can be built into even trivial Scheme implementation. Mandating module support is unnecessary and might inhibit its adoption.</p>
<p>The "transform-mixed-infix" procedure is suggested so that a future SRFI author could more easily implement a precedence system that is built into the reader. Precedence is intentionally not included in curly-infix itself; instead, application and library writers can implement precedence by defining and controlling the scope of an "nfx" macro or procedure.  However, if a future community decides it wants precedence built into the reader, transform-mixed-infix could be redefined to provide one. This is only defined to help simplify implementing a plausible future SRFI; it is not required.</p>
<p>There's no explicit "disable-curly-infix".  There's no reason to disable it within this SRFI, and if some other action changes the meaning of braces, it would be that other action that disables it.</p>
<p>There is no requirement that writers (e.g., "write" or a pretty-printer) write out curly-infix expressions.  They may choose to do so, e.g., for lists of length 3-6 whose car is the symbol "and", the symbol "or", or a punctuation-only symbol.  However, it would probably be wise to wait until many implementations can handle c-expressions.</p>
<p><a href="http://docs.racket-lang.org/guide/Pairs__Lists__and_Racket_Syntax.html">Racket allows a notation called the "infix convention" of the form "(a . <i>operation</i> . b)". A pro of this alternative is that it does not use the braces, so it might be easier to implement in Schemes which already define {...} in a local extension.  However, the Racket "infix convention" has many problems:</p>
<ul>
<li>The Racket infix convention is much longer and more awkward that curly-infix notation.  In the Racket infix convention, every infix operator adds 6 characters.  Infix operations are a very common operation, so convenience matters. An expression like (1 . + . 2) is far longer, and less convenient, than {1 + 2}.</li>
<li>It doesn't look like other languages or math. A human notation should be maximally understandable to people given what they already know.  {a + b} is much more similar to standard notation than (a . + . b).</li>
<li>It is easy to make mistakes.  If you forget a "." somewhere, you end up with the wrong result.  This notation also makes it harder to see improper lists; improper lists are important but rare, so it's good to make them obvious - the Racket infix convention makes improper lists hard to distinguish.  The Racket documentation even goes out of its way to emphasize that infix convention use is unrelated to improper lists... which suggests that they are easily confused.</li>
<li>Without {...}, {x} is no longer useful as an escape mechanism for sweet-expressions (a notation that builds on curly-infix).  An alternative would be to use (. x) as an escape mechanism, but at that point dots-in-lists become busy and confusing.</li>
<li>Racket's implementation does not allow multiple operations, e.g., (a . + . b . + . c . + . d).  That could be added, but using them makes the Racket infix convention notation even more unwieldy.  For example, compare this to {a + b + c + d}.</li>
<li>Even Racket users don't use this convention often.  Its documentation says that "Racket programmers use the infix convention sparingly&#8212;mostly for asymmetric binary operators such as &lt; and is-a?."  The documentation does not say why, but its extra length and awkwardness may be part of the reason.</li>
</ul>
<p>In short, infix is extremely common, so its notation should be convenient. The Racket "infix convention" may be the next-best notation for infix notation after curly-infix, but it's next-best, and we should strive for the <i>best</i> available notation for such a common need.  Curly-infix does not <em>conflict</em> with the Racket infix convention; implementations could implement both.  We recommend that an implementation that implements the Racket infix convention should also allow multiple operands and use curly-infix semantics for them, pretending that . op . is a single parameter.  In that case, (a . + . b . + . c) would map to (+ a b c), and (a . + . b . * . c) would map to (nfx a + b * c).  Note that the existence of the Racket "infix convention" is additional evidence of the <i>need</i> for a standard infix convention; many have separately created mechanisms to try to provide infix support.</p>
<p>Curly-infix is designed so that it can work on other Lisps as well. We even have a working implementation in Common Lisp.
</p>
<p>Curly-infix is an unusually simple mechanism, but like much of any Lisp-based language, its power comes from its simplicity.</p>
<p>The "curly-foo" command convention is required so that users can easily invoke the implementation with curly-infix enabled to start with.</p>
<p>Note that this is the first of three tiers developed by the "readable" project.  We intend to later submit two more SRFIs, for defining the other two tiers that build on top of curly-infix-expressions.</p>

<h1 id="specification">Specification</h1>
<p>"Curly-infix-expressions" (c-expressions) are s-expressions with an additional notation: The curly-infix list.  A curly-infix list is syntactically identical to a normal list, except it is surrounded by curly braces instead of by parentheses.  Once a curly-infix list is read, it is mapped differently than a regular list:
</p>
<ol>
<li>A simple curly-infix has an odd number of parameters, at least three parameters, and all even parameters are "eq?" symbols. A simple curly-infix list is mapped by the reader into a list with the even parameter followed by the odd parameters. 
E.g., {n &lt;= 2} maps to (&lt;= n 2), and {2 * 3 * 4} maps to (* 2 3 4).</li>
<li>The empty curly-infix list {} is mapped to the empty list ().</li>
<li>The escaping curly-infix list {e} is mapped to e.</li>
<li>The unary-operation curly-infix list {e1 e2} is mapped to (e1 e2). E.g., {- x} maps to (- x).</li>
<li>Any other curly-infix list (including all improper lists) is mixed; it is mapped to the list with the symbol "nfx" added to its front. E.g., {q + r * s} maps to (nfx q + r * s).</li>
</ol>

<p>A "curly-infix-expression" datum reader is a reader that can correctly read curly-infix-expressions.</p>
<p>Here are some examples of c-expressions:</p>
<ul>
<li>{a * {b + c}} maps to (* a (+ b c))</li>
<li>{x eqv? 'a} maps to (eqv? x 'a)</li>
<li>{(- a) / b} maps to (/ (- a) b)</li>
<li>{(f a b) + (g h)} maps to (+ (f a b) (g h))</li>
<li>'{a + (f b) + x} maps to '(+ a (f b) x)</li>
<li>{{a &gt; 0} and {b &gt;= 1}} maps to (and (&gt; a 0) (&gt;= b 1))</li>
</ul>

<p>This implies that the braces { and } must be delimiters.</p>

<p>Procedures:</p>
<ul>
<li>Implementations must provide the procedure (curly-infix-read . port) that can read a c-expression.</li>
<li>Implementations must provide the procedure (enable-curly-infix), which enables this capability in the default reader ("read" and "get-datum"), the reader used in the REPL, and the reader used by "load", whether or not it was previously enabled.   However, we encourage systems to <em>always</em> have this capability enabled, even if enable-curly-infix is not called.</li>
<li>Implementations may provide an overrideable procedure (transform-mixed-infix lyst) that can be "set!".  This procedure would receive a mixed curly-infix list and return a transformation of it.  By default, this function returns the original list but with "nfx" in front; this procedure is suggested to simplify implementation of plausible future SRFIs.</li>
</ul>
<p>
If an implementation <i>foo</i> does not enable curly-infix by default, and it is possible to invoke it from a command line, it <i>must</i> provide an alternative command <i>curly-foo</i> (the command prefixed with "curly-") that enables curly-infix by default.</p>

<p>Note that, by definition, this SRFI modifies lexical syntax.</p>

<h1 id="reference-implementation">Reference implementation</h1>
<p>The implementation below is portable, with the exception that Scheme provides no standard mechanism to override {...} in its built-in reader.  Thus, implementations will typically have a modified reader that detects "{", starts reading a list until its matching "}", and then calls process-curly defined below.  We recommend that implementations <em>always</em> do this, but an implementation must at least activate this behavior when (enable-curly-infix) is called.</p>
<p>This reference implementation is SRFI type 2: "A mostly-portable solution that uses some kind of hooks provided in some Scheme interpreter/compiler. In this case, a detailed specification of the hooks must be included so that the SRFI is self-contained."</p>

<pre>
; Return true if lyst has an even # of parameters, and the (alternating)
; first parameters are "op".  Used to determine if a longer lyst is infix.
; If passed empty list, returns true (so recursion works correctly).
(define (even-and-op-prefix? op lyst)
  (cond
    ((null? lyst) #t)
    ((not (pair? lyst)) #f) ; Not a list.
    ((not (eq? op (car lyst))) #f) ; fail - operators not the same
    ((null? (cdr lyst)) #f) ; fail - wrong # of parameters in lyst.
    (#t (even-and-op-prefix? op (cddr lyst))))) ; recurse.

; Return true if the lyst is in simple infix format
; (and thus should be reordered at read time).
(define (simple-infix-list? lyst)
  (and
    (pair? lyst)           ; Must have list;  '() doesn't count.
    (pair? (cdr lyst))     ; Must have a second argument.
    (pair? (cddr lyst))    ; Must have a third argument (we check it
                           ; this way for performance)
    (symbol? (cadr lyst))  ; 2nd parameter must be a symbol.
    (even-and-op-prefix? (cadr lyst) (cdr lyst)))) ; true if rest is simple

; Return alternating parameters in a lyst (1st, 3rd, 5th, etc.)
(define (alternating-parameters lyst)
  (if (or (null? lyst) (null? (cdr lyst)))
    lyst
    (cons (car lyst) (alternating-parameters (cddr lyst)))))

; Transform a simple infix list - move 2nd parameter into first position,
; followed by all the odd parameters.  Thus (3 + 4 + 5) becomes (+ 3 4 5).
(define (transform-simple-infix lyst)
   (cons (cadr lyst) (alternating-parameters lyst)))

; Not a simple infix list - transform it.  Written as separate procedure
; so that future experiments or SRFIs can easily replace just this piece.
(define (transform-not-simple-infix lyst)
   (cons 'nfx lyst))

; Given curly-infix lyst, map it to its final internal format.
(define (process-curly lyst)
  (if (simple-infix-list? lyst)
     (transform-simple-infix lyst) ; Simple infix expression.
     (transform-not-simple-infix lyst)))

; In the reader, when #\{ is detected, read (as a list) from that port
; until its matching #\}, then process that list with "process-curly".
</pre>


<h1 id="references">References</h1>
<p>The readable project website has more information: <a href="http://readable.sourceforge.net">http://readable.sourceforge.net</a></p>

<h1 id="acknowledgments">Acknowledgments</h1>
<p>I thank Alan Manuel Gloria for his helpful efforts in getting this available.</p>

<h1 id="copyright">Copyright</h1>
<p>Copyright (C) 2012 David A. Wheeler. All Rights Reserved.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p></div>

</body>
