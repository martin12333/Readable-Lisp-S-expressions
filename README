Readable Lisp S-expressions ("readable")
========================================

This "readable" software improves the readability of Lisp S-expressions
by adding up to three tiers of new s-expression abbreviations.
These tiers are (oversimplified):

1. Curly-infix-expressions (c-expressions): Lists with {...} are infix, in a
   Lispy way: {a op b ...} maps to (op a b ...). No precedence, by intent.
2. Neoteric-expressions (n-expressions): An e(...) maps to
   (e ...), and e{...} with content maps to e({...}).
3. Sweet-expressions (t-expressions): Parentheses are deduced from indentation:
   - An indented line is a parameter of its parent.
   - Later terms on a line are parameters of the first term.
   - A line with exactly one term and no child lines is simply that term.
   - Empty lines end the previous expression. Just type ENTER ENTER
     to execute what you've typed.

Unlike nearly all past efforts to improve s-expression readability, these
are general (the notation is independent from any underlying semantic)
and homoiconic (the underlying data structure is clear from the syntax).
They are also backwards-compatible; well-formatted traditional
s-expressions continue work normally.  Thus, it's easy to transition to
these, and you can use traditional forms whenever it's convenient.

Lisp-based languages where this approach or software can be helpful
include Scheme (including guile), Common Lisp, Emacs Lisp, Clojure, Arc,
BitC, ACL2, SUO-KIF, the GCC MiddleEndLispTranslator (MELT),
Satisfiability Modulo Theories Library (SMT-LIB), NewLisp, and ISLisp.
For Scheme these notations are defined in SRFI-105 and SRFI-110.
At this time, the tools focus on Scheme and Common Lisp, but
some of the tools can be easily used with many other Lisps.

For more information, see:
  http://readable.sourceforge.net


Example
=======

Here is an example of a sweet-expression:

define fibfast(n)   ; Typical function notation
  if {n < 2}        ; Indentation, infix {...}
     n              ; Single expr = no new list
     fibup n 2 1 0  ; Simple function calls

That sweet-expression would be interpreted as:

(define (fibfast n)
  (if (< n 2)
      n
      (fibup n 2 1 0)))

A sweet-expression reader would accept *either* one.


Maturity
========

This code is *mature* and *production-ready*, and comes with an
extensive test suite.


License
=======

The software is released under the MIT license, which permits practically
any use.  The MIT license is an open source software / Free Software
license approved by both the OSI (opensource.org) as an open source software
license, and by the FSF (fsf.org) as a Free software license.

See the COPYING file for the license text.


Getting, building, and installing
=================================

This software supports the usual GNU Build System conventions.
Here are the steps, spelled out.

1. Download/Prepare to configure

You need to get the files.  You've probably done that, since you're
reading this, but here are the basics.

If you want to get the current stable version, go to:

   http://readable.sourceforge.net
   Click on "Download files", and download the current version.
   Then uncompress them; one way is via the command line:
     tar xvzf readable-*.tar.gz
     cd readable-*

If you want to get the latest developmental version, download the
files from our git code repository & prepare it to be configured:

   git clone git://git.code.sf.net/p/readable/code readable-code
   cd readable-code
   git checkout develop  # The "master" branch is for final releases
   autoreconf -i

2. Configure

As usual, configure.  To accept all the defaults, installing to /usr/local:

    ./configure

If you want it to install to /usr (e.g., programs go in /usr/bin),
which many will want:

    ./configure --prefix=/usr

3. Build ("make") / test

Now build the code.

    make

You can optionally run the testsuite; it's a very good idea (you need
guile, clisp, a correctly-installed adsf, and expect to run the tests):

    make check

4. Install ("make install")

You actually don't *have* to install the software.  Just run
"./unsweeten", "./sweeten", "./sweet-guile", and it'll work.
But it's often more convenient to install.  Do this with:

    make install


Scheme Tutorial
==============

File "scheme-tutorial.md" is the Scheme tutorial on how to use it.


Common Lisp Tutorial
====================

File "common-lisp-tutorial.md" is the Common Lisp tutorial for how to use it.

The Common Lisp implementation creates a package :readable and uses the
usual ASDF system.  A "make install" puts files in the usual place,
$PREFIX/share/common-lisp/source (where $PREFIX is /usr/local by default).

You need ASDF.  Most Common Lisp users already have that ready to go.
If you don't have it, get it here:
  http://common-lisp.net/project/asdf/
Cygin's clisp doesn't have asdf by default; you can install it with:
  mkdir -p ~/lisp/asdf
  cp asdf.lisp ~/lisp/asdf
  clisp
  (load (compile-file "asdf.lisp"))
  (exit)

Configure ASDF so it knows what directories to look at, e.g.,
put this in file "/etc/common-lisp/source-registry.conf":
 (:source-registry
   (:tree (:home "cl")) ;; will expand to e.g. "/home/joeluser/cl/"
   (:tree "/usr/share/common-lisp/source/")
   :inherit-configuration)
Alternatively, you can set the environment variable CL_SOURCE_REGISTRY, e.g.,
to set the environment variable to the current directory and run sbcl:
CL_SOURCE_REGISTRY="`realpath .`" sbcl

Now fire up a Common Lisp (e.g., "clisp" or "sbcl") and run:
 (require 'asdf) ; or (load "tests/my-asdf.lisp")  if asdf isn't installed.
 (asdf:load-system :readable)
 (readable:enable-basic-curly) ; or enable-sweet or whatever.

; now you can do:
{3 + 4}



Transitioning
=============

The "sweeten" tool is a pretty-printer that translates
s-expressions to sweet-expressions.  You can use "sweeten" to create a file,
hand-tweak the result to make it "prettier", and then use "diff-s-sweet"
to verify that your newly-formatted file has exactly the same meaning.

The "unsweeten" tool can be used as a sweet-expression pre-processor,
so you can use these notations even if your Lisp implementation does not
yet support them.

By default the "sweeten" and "unsweeten" tools process Scheme; if you
have Common Lisp (or something like it), provide the "-C" (Common Lisp)
option as documented.  They can be used as front-ends for other tools.


For more information
===================

For more information, see:
  http://readable.sourceforge.net

Discussions are held on its "readable-discuss" mailing list.

