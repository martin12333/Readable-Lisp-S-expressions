Readable Lisp S-expressions Project
===================================

This software improves the readability of Lisp S-expressions, by
implementing three tiers of additional abbreviations in S-expressions.
These tiers are (oversimplified):
1. Curly-infix-expressions (c-expressions): Lists with {...} are infix, in
   a Lispy way. {a op b ...} => (op a b ...). No precedence, by intent.
2. Neoteric-expressions (n-expressions): An e(...) is interpreted as
   (e ...), an e{...} is interpreted as e({...}).
3. Sweet-expressions (t-expressions): Parentheses are deduced from indentation:
   - An indented line is a parameter of its parent.
   - Later terms on a line are parameters of the first term.
   - A line with exactly one term and no child lines is simply that term.
   - Empty lines end the previous expression. Just type ENTER ENTER
     to execute what you've typed.

Well-formatted traditional s-expressions continue to be read in normally,
so you only need to use the abbreviations when you find them useful.

For more information, see: http://readable.sourceforge.net.
In particular, see the [Tutorial], [Solution], and other pages on the wiki.

Lisp-based languages where this software can be helpful include Common Lisp,
Scheme (including guile), Emacs Lisp, Clojure, Arc, BitC, ACL2,
SUO-KIF, the GCC MiddleEndLispTranslator (MELT),
Satisfiability Modulo Theories Library (SMT-LIB), NewLisp, and ISLisp.

The tools provided here primarily handle Scheme and Common Lisp.
By default the "sweeten" and "unsweeten" tools process Scheme;
If you have Common Lisp, provide the "-C" (Common Lisp) option as documented.


Maturity
=======================

This code is *mature* and *production-ready* for Scheme, especially
guile Scheme.  It's been extensively tested, and comes with
a large regression test suite, and is based on a specially-analyzed grammar.
The intent is for Scheme implementations to use this code as a starting
point to embed the reader into their code... but the code can also be used
as a pre-processor so that you can use these notations today.

The code is *prototype-level* and *less mature* for Common Lisp.
If you're careful to stay within its limitations, it works, but the
Common Lisp capabilities are not as mature as Scheme.
Please contact us if you're interested in helping us mature
the Common Lisp implementation.


License
=======

The software is released under the MIT license, which permits practically
any use.  The MIT license is an open source software / Free Software
license approved by both the OSI (opensource.org) as an open source software
license, and by the FSF (fsf.org) as a Free software license.

See the COPYING file for the license text.


Building and Installing
=======================

This software supports the usual GNU Build System conventions.
Here are the steps, spelled out.

1. Download/Prepare to configure

You need to get the files.  You've probably done that, since you're
reading this, but here are the basics.

If you want to get the current stable version, go to:

   http://readable.sourceforge.net
   Click on "Download files", and download the current version.
   Then uncompress them; one way is via the command line:
     tar xvzf readable-*.tar.gz
     cd readable-*

If you want to get the latest developmental version, download the
files from our git code repository & prepare it to be configured:

   git clone git://git.code.sf.net/p/readable/code readable-code
   cd readable-code
   git checkout develop  # The "master" branch is for final releases
   autoreconf -i

2. Configure

As usual, configure.  To accept all the defaults, installing to /usr/local:

    ./configure

If you want it to install to /usr (e.g., programs go in /usr/bin):

    ./configure --prefix=/usr

3. Build ("make") / test

Now build the code.

    make

You can optionally run the testsuite; it's a very good idea (you need
guile and clisp to run the tests):

    make check

4. Install ("make install")

You actually don't *have* to install the software.  Just run
"./unsweeten", "./sweeten", "./sweet-guile", and it'll work.
But it's often more convenient to install.  Do this with:

    make install


Scheme
======

See the Scheme tutorial (scheme-tutorial.md) for how to use it.


Common Lisp
===========

See the Common Lisp tutorial (common-lisp-tutorial.md) for how to use it.

The Common Lisp implementation creates a package :readable and uses the
usual ASDF system.  A "make install" puts files in the usual place,
$PREFIX/share/common-lisp/source (where $PREFIX is /usr/local by default).

You need ASDF.  Most Common Lisp users already have that ready to go.
If you don't already have ASDF installed and configured (why?),
the "tests/" directory has an ASDF version 3 "my-asdf.lisp" you can use.
Configure ASDF so it knows what directories to look at, e.g.,
put this in file "/etc/common-lisp/source-registry.conf":
(:source-registry
  (:tree (:home "cl")) ;; will expand to e.g. "/home/joeluser/cl/"
  (:tree "/usr/share/common-lisp/source/")
  :inherit-configuration)
Alternatively, you can set the environment variable CL_SOURCE_REGISTRY, e.g.,
to set the environment variable to the current directory and run sbcl:
CL_SOURCE_REGISTRY="`realpath .`" sbcl

Now fire up a Common Lisp (e.g., "clisp" or "sbcl") and run:
 (require 'asdf) ; or (load "tests/my-asdf.lisp")  if asdf isn't installed.
 (asdf:load-system :readable)
 (readable:enable-basic-curly) ; or enable-sweet or whatever.

; now you can do:
{3 + 4}



Key files
=========

Some of the key files are:

## Installed:

Executables:

*   unsweeten: A filter that reads in (from stdin) a file of
    sweet-expressions, and outputs sweet-expressions.  You can use this
    in "makefiles" so that you can write files using sweet-expressions.
    MIT license.
*   sweeten: A filter that reads in s-expressions (Scheme format) from
    standard in, and generates sweet-expressions on standard out.
    This makes it much easier to transition to sweet-expressions.
    MIT license.
*   diff-s-sweet: A program that tells you if 2 files are semantically
    different.  When transitioning to sweet-expressions, run "sweeten" and
    then this tool if you want to confirm that everything's okay. MIT license.
*   neoteric-guile: Start up guile, but use neoteric-expressions to
    interact with it. MIT license.
*   sweet-guile: Start up guile, but use sweet-expressions to interact
    with it. MIT license.

Common Lisp implementation:

*   readable.asd - The ASDF file that simplifies compiling and loading
*   basic-curly.lisp - Implementation of basic curly-infix-expressions
*   neoteric.lisp - Implementation of neoteric-expressions
*   backquote.lisp - Support file for sweet-expressions
*   sweet.lisp - Implementation of sweet-expressions


Documentation:

*   README: This file.
*   solution.md: A description of the notations this project implements.
    See the project website for the current version of this.
*   scheme-tutorial.md: A tutorial (Scheme-focused).
    See the project website for a current version of this.
*   common-lisp-tutorial.md: A tutorial (Common-Lisp-focused).
    See the project website for a current version of this.
*   src/sweeten.sscm: An example of code written using sweet-expressions.
*   "man pages"

The spec-* files need to be updated (volunteers welcome).  For now, see
"solution.md" for the real specification.

## Not Installed:

*   src/kernel.scm: An implementation of the three notation tiers
    curly-infix-read, neoteric-read, and sweet-read.  Implemented in the
    Guile dialect of Scheme; it includes hooks for other dialects.  This is
    installed into the "readable" site directory of guile. MIT license.
*   src/sweeten.sscm: The source of the "sweeten" program.  It's written
    in Scheme using sweet-expressions, so if you want to see what
    sweet-expressions look like, well, here's an example.
*   SRFI-105.html - The SRFI defining curly-infix-expressions for Scheme
*   SRFI-110.html - The draft SRFI defining sweet-expressions for Scheme

Key directories
===============

src/      - Most source files
bin/      - Generated command (script) files for installation
readable/ - Guile library (generated, don't edit these)
tests/    - Test scripts and test cases

The "src/" directory holds most of the source code.
A "make" will generate files in the top dir, bin/ directory, and the
readable/ directory.  The generated files in the top directory are
scripts designed to invoke the locally-built readable library, even if
there's another one installed.

File suffixes are:
.lisp  - Common Lisp
.scm   - Scheme
.sscm  - Sweet-Scheme; Scheme written with sweet-expressions.

You can invoke the readers from your own Guile programs by doing:
  (use-modules (readable kernel))
and you can even:
  (replace-read sweet-read)

On Guile 2.0 there are occassional strangenesses in the interaction
between the module system and autocompilation - the particular
strangeness is when autocompilation is turned OFF.  If you want to
use sweet-guile or neoteric-guile, turn ON autocompilation, as
otherwise use-modules will use the default reader rather than
what you replace.



For more information
===================

For more information, see:
  http://readable.sourceforge.net

Discussions are held on the mailing list.

