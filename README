Readable Lisp S-expressions Project

This software improves the readability of Lisp S-expressions.

For more information, see: http://readable.sourceforge.net.

Lisp-based languages where this software can be helpful include Common Lisp,
Scheme (including guile), Emacs Lisp, Clojure, Arc, BitC, ACL2,
SUO-KIF, the GCC MiddleEndLispTranslator (MELT),
Satisfiability Modulo Theories Library (SMT-LIB), NewLisp, and ISLisp.

All of the code is released under open source software / Free Software
licenses approved by both the OSI (opensource.org) and FSF (fsf.org).
Most are released under the MIT license, which permits practically any use.

File suffixes are:
.cl    - Common Lisp
.lisp  - Common Lisp
.scm   - Scheme
.sscm  - Sweet-Scheme; Scheme written with sweet-expressions.

This directory includes (in alphabetical order):

* curly-infix.cl: A simple Common Lisp reader macro that
implements infix operations in lists surrounded by {...}.  MIT license.

* iformat.sscm: A simple pretty-printer that generates I-expressions
(indented S-expressions) given an object, in sweet-expression format.
Run "make" to generate Scheme, "guile iformat.scm" runs it as a filter
(input is stdin, output is stdout).  MIT license.

* modern.scm: "Modern Lisp" reader, Scheme.  "modern-scm-test.scm" is
  a guile Scheme program you can run to test it.

* sweetener: A filter that takes ordinary S-expressions as input,
  and generates nice-looking sweet-expressions as output.

* sugar.scm: an implementation of an indentation reader, defined mostly in
SFRI-49.  These use indentation to reduce the number of parentheses
needed to represent S-expressions.  MIT license.

* sweet.scm: an implementation of a "sweet-expression" reader, a much
easier-to-read format for S-expressions.  Implemented in the guile
dialect of Scheme.  MIT license.
Builds on sugar.scm and modern.scm.

* spec-indent.txt: Detailed specification information on I-expressions.


Some of this code uses guile's module capability.
To use these in guile, you need to make sure that the %load-path
includes the directory where the source code resides.  For example,
to add searching the current directory "." to the end of the search path:
  (set! %load-path (append %load-path '(".")))
You could include this command in your ~/.guile file, and then it would
be run each time.
Alternatively, you can do this at a shell prompt (or ~/.bashrc or similar):
  export GUILE_LOAD_PATH="."
which will insert the given path(s) at the beginning of %load-path.
Beware: the GUILE_LOAD_PATH has the highest precedence when setting
up the %load-path, so while this is useful for testing,
setting GUILE_LOAD_PATH to include "." can have security problems
if used in "real" programs (an attacker might arrange for a malicious
scheme file to be loaded instead of an intended one).

Once the %load-path is set up, you can easily load modules, e.g.:
  (use-modules (sugar))

