Readable Lisp S-expressions Project

This software improves the readability of Lisp S-expressions.

For more information, see: http://readable.sourceforge.net.

Lisp-based languages where this software can be helpful include Common Lisp,
Scheme (including guile), Emacs Lisp, Clojure, Arc, BitC, ACL2,
SUO-KIF, the GCC MiddleEndLispTranslator (MELT),
Satisfiability Modulo Theories Library (SMT-LIB), NewLisp, and ISLisp.

All of the code is released under open source software / Free Software
licenses approved by both the OSI (opensource.org) and FSF (fsf.org).
Most are released under the MIT license, which permits practically any use.

This software supports the usual GNU Build System conventions;
here are the steps.

1. Download/Uncompress.

You need to get the files.  You've probably done that, since you're
reading this, but just in case you haven't, here's one way:

   git clone git://git.code.sf.net/p/readable/code readable-code
   cd readable-code

2. Create "configure".

If you've downloaded directly from the source repository, autoreconf it
by running this command:

    autoreconf -i

3. Configure

As usual, configure.  To accept all the defaults, installing to /usr/local:

    ./configure

If you want it to install to /usr (e.g., programs go in /usr/bin):

    ./configure --prefix=/usr

4. Build ("make")

Now build the code.

    make

5. Install ("make install")

You actually don't *have* to install the software.  Just run
"./unsweeten", "./sweeten", "./sweet-guile", and it'll work.
But it's often more convenient to install.  Do this with:

    make install

The usual conventions all work (DESTDIR, VPATH builds, etc.).


=== Key directories ===

src/      - Most source files
bin/      - Generated command (script) files for installation
readable/ - Guile library (generated, don't edit these)
tests/    - Test scripts and test cases

The "src/" directory holds most of the source code.
A "make" will generate files in the top dir, bin/ directory, and the
readable/ directory.  The generated files in the top directory are
scripts designed to invoke the locally-built readable library, even if
there's another one installed.


=== Key files ===

* curly-infix.cl: A simple Common Lisp reader macro that
implements infix operations in lists surrounded by {...}.  MIT license.

* sweeten: A filter that reads in s-expressions (Scheme format)
from standard in, and generates sweet-expressions on standard out.
MIT license.

* src/sweet-impl.scm: An implementation of the three tiers
curly-infix-read, neoteric-read, and sweet-read.
Implemented in the Guile dialect of Scheme, includes
hooks for other dialects.  MIT License.

* spec-indent.txt: Detailed specification information on I-expressions.

* spec-almkglor.txt: A not-so-updated specification for the entire
sweet-expression spec, created by Alan Manuel K. Gloria

* unsweeten: A filter that reads in (from stdin) a file of
sweet-expressions, and outputs sweet-expressions.  You can use this in
"makefiles" so that you can write files using sweet-expressions.


File suffixes are:
.cl    - Common Lisp
.lisp  - Common Lisp
.scm   - Scheme
.sscm  - Sweet-Scheme; Scheme written with sweet-expressions.


You can invoke the readers from your own Guile programs by doing:
  (use-modules (readable sweet-impl))
and you can even:
  (replace-read sweet-read)

On Guile 2.0 there are occassional strangenesses in the interaction
between the module system and autocompilation - the particular
strangeness is when autocompilation is turned OFF.  If you want to
use sweet-guile or neoteric-guile, turn ON autocompilation, as
otherwise use-modules will use the default reader rather than
what you replace.

