Readable Lisp S-expressions Project

This software improves the readability of Lisp S-expressions.

For more information, see: http://readable.sourceforge.net.

Lisp-based languages where this software can be helpful include Common Lisp,
Scheme (including guile), Emacs Lisp, Clojure, Arc, BitC, ACL2,
SUO-KIF, the GCC MiddleEndLispTranslator (MELT),
Satisfiability Modulo Theories Library (SMT-LIB), NewLisp, and ISLisp.

All of the code is released under open source software / Free Software
licenses approved by both the OSI (opensource.org) and FSF (fsf.org).
Most are released under the MIT license, which permits practically any use.

File suffixes are:
.cl    - Common Lisp
.lisp  - Common Lisp
.scm   - Scheme
.sscm  - Sweet-Scheme; Scheme written with sweet-expressions.

This directory includes (in alphabetical order):

* curly-infix.cl: A simple Common Lisp reader macro that
implements infix operations in lists surrounded by {...}.  MIT license.

* iformat.sscm: A simple pretty-printer that generates I-expressions
(indented S-expressions) given an object, in sweet-expression format.
Run "make" to generate Scheme, "guile iformat.scm" runs it as a filter
(input is stdin, output is stdout).  MIT license.

* readable/sweet-impl.scm: An implementation of a "sweet-expression"
reader; provides the three tiers curly-infix-read, neoteric-read, and
sweet-read.  Implemented in the Guile dialect of Scheme, includes
hooks for other dialects.  MIT License.

* sweeten: A filter that reads in (from stdin) a file of ordinary
S-expressions (Scheme format) and outputs sweet-expressions.

* spec-indent.txt: Detailed specification information on I-expressions.

* spec-almkglor.txt: A not-so-updated specification for the entire
sweet-expression spec, created by Alan Manuel K. Gloria

* unsweeten: A filter that reads in (from stdin) a file of
sweet-expressions, and outputs sweet-expressions.  You can use this in
"makefiles" so that you can write files using sweet-expressions.

Some of this code uses guile's module capability.
To use these in guile, you need to make sure that the %load-path
includes the directory where the source code resides.  For example,
to add searching the current directory "." to the end of the search path:
  (set! %load-path (append %load-path '(".")))
You could include this command in your ~/.guile file, and then it would
be run each time.
Alternatively, you can do this at a shell prompt (or ~/.bashrc or similar):
  export GUILE_LOAD_PATH="."
which will insert the given path(s) at the beginning of %load-path.
Beware: the GUILE_LOAD_PATH has the highest precedence when setting
up the %load-path, so while this is useful for testing,
setting GUILE_LOAD_PATH to include "." can have security problems
if used in "real" programs (an attacker might arrange for a malicious
scheme file to be loaded instead of an intended one).

Once the %load-path is set up, you can easily load modules, e.g.:
  (use-modules (readable sweet-impl))
  (replace-read sweet-read)

On Guile 2.0 there are occassional strangenesses in the interaction
between the module system and autocompilation - the particular
strangeness is when autocompilation is turned OFF.  If you want to
use sweet-guile or neoteric-guile, turn ON autocompilation, as
otherwise use-modules will use the default reader rather than
what you replace.

