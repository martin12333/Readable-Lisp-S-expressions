Readable Lisp S-expressions ("readable")
========================================

This "readable" software improves the readability of Lisp S-expressions
by adding up to three tiers of new s-expression abbreviations.
These tiers are (oversimplified):

1. Curly-infix-expressions (c-expressions): Lists with {...} are infix, in a
   Lispy way: {a op b ...} maps to (op a b ...). No precedence, by intent.
2. Neoteric-expressions (n-expressions): An e(...) maps to
   (e ...), and e{...} with content maps to e({...}).
3. Sweet-expressions (t-expressions): Parentheses are deduced from indentation:
   - An indented line is a parameter of its parent.
   - Later terms on a line are parameters of the first term.
   - A line with exactly one term and no child lines is simply that term.
   - Empty lines end the previous expression. Just type ENTER ENTER
     to execute what you've typed.

Unlike nearly all past efforts to improve s-expression readability, these
are general (the notation is independent from any underlying semantic)
and homoiconic (the underlying data structure is clear from the syntax).
They are also backwards-compatible; well-formatted traditional
s-expressions continue work normally.  Thus, it's easy to transition to
these, and you can use traditional forms whenever it's convenient.

Lisp-based languages where this approach or software can be helpful
include Scheme (including guile), Common Lisp, Emacs Lisp, Clojure, Arc,
BitC, ACL2, SUO-KIF, the GCC MiddleEndLispTranslator (MELT),
Satisfiability Modulo Theories Library (SMT-LIB), NewLisp, and ISLisp.
For Scheme these notations are defined in SRFI-105 and SRFI-110.
At this time, the tools focus on Scheme and Common Lisp, but
some of the tools can be easily used with many other Lisps.

For more information, see:
  http://readable.sourceforge.net


Example
=======

Here is an example of a sweet-expression:

define fibfast(n)   ; Typical function notation
  if {n < 2}        ; Indentation, infix {...}
     n              ; Single expr = no new list
     fibup n 2 1 0  ; Simple function calls

That sweet-expression would be interpreted as:

(define (fibfast n)
  (if (< n 2)
      n
      (fibup n 2 1 0)))

A sweet-expression reader would accept *either* one.


Maturity
========

This code is *mature* and *production-ready*, and comes with an
extensive test suite.


License
=======

With one exception, the software is released under the
"MIT license", which permits practically any use.
The MIT license is an open source software / Free Software
license approved by both the OSI (opensource.org) as an open source software
license, and by the FSF (fsf.org) as a Free software license.
See the COPYING file for the license text.

The one exception is the file "sweet-clisp", which interfaces to clisp.
Most of this file is also licensed under the MIT license.
However, that file contains code derived from the "clisp" program.
Clisp is licensed under the "GNU General Public License version 2 (GPLv2)",
so those parts are also under the GPLv2 (see the file for details).
The GPLv2 is also an open source software / Free Software license approved
by both the OSI (opensource.org) as an open source software license,
and by the FSF (fsf.org) as a Free software license.
See the COPYING.GPL file for those conditions.


Getting, building, and installing
=================================

This software supports the usual GNU Build System conventions.
Here are the steps, spelled out.

1. Download/Prepare to configure

You need to get the files.  You've probably done that, since you're
reading this, but here are the basics.

If you want to get the current stable version, go to:

   http://readable.sourceforge.net
   Click on "Download files", and download the current version.
   Then uncompress them; one way is via the command line:
     tar xvzf readable-*.tar.gz
     cd readable-*

If you want to get the latest developmental version, download the
files from our git code repository & prepare it to be configured:

   git clone git://git.code.sf.net/p/readable/code readable-code
   cd readable-code
   git checkout develop  # The "master" branch is for final releases
   autoreconf -i

2. Configure

As usual, configure.  To accept all the defaults, installing to /usr/local:

    ./configure

If you want it to install to /usr (e.g., programs go in /usr/bin),
which many will want:

    ./configure --prefix=/usr

3. Build ("make") / test

Now build the code.

    make

You can optionally run the testsuite; it's a very good idea (you need
guile, clisp, a correctly-installed adsf, and expect to run the tests):

    make check

4. Install ("make install")

You actually don't *have* to install the software.  Just run
"./unsweeten", "./sweeten", "./sweet-guile", and it'll work.
But it's often more convenient to install.  Do this with:

    make install


Scheme Tutorial
==============

File "scheme-tutorial.md" is the Scheme tutorial on how to use it.


Common Lisp Tutorial
====================

File "common-lisp-tutorial.md" is the Common Lisp tutorial for how to use it.

The Common Lisp implementation creates a package :readable and uses the
usual ASDF system.  A "make install" puts files in the usual place,
$PREFIX/share/common-lisp/source (where $PREFIX is /usr/local by default).

You need ASDF.  Most Common Lisp users already have that ready to go.
You can quickly install ASDF on many Linux distributions (such as Fedora,
Debian, and Ubuntu) by installing the package "cl-asdf".
If you don't have asdf, get it here:
  http://common-lisp.net/project/asdf/

Many clisp packages don't include asdf, or its support, by default.
If you use Cygin's clisp, install asdf by doing this:
  mkdir -p ~/lisp/asdf
  cp asdf.lisp ~/lisp/asdf     # See below.
  clisp
  (load (compile-file "asdf.lisp"))
  (exit)
If you use clisp and a Linux distribution's asdf package, follow the above
steps, but instead of the "cp asdf.lisp ~/lisp/asdf" command do this:
  ln -s /usr/share/common-lisp/source/cl-asdf/asdf.lisp ~/lisp/asdf/
That way, updates to your Linux distribution's asdf will be used automagically.

Ensure ASDF is configured so it knows what directories to look at, e.g.,
put this in file "/etc/common-lisp/source-registry.conf":
 (:source-registry
   (:tree (:home "cl")) ;; will expand to e.g. "/home/joeluser/cl/"
   (:tree "/usr/share/common-lisp/source/")
   :inherit-configuration)
Alternatively, you can set the environment variable CL_SOURCE_REGISTRY, e.g.,
to set the environment variable to the current directory and run sbcl:
CL_SOURCE_REGISTRY="`realpath .`" sbcl

Now fire up a Common Lisp (e.g., "clisp" or "sbcl") and run:
 (require "asdf") ; or (load "tests/my-asdf.lisp")  if asdf isn't installed.
 (asdf:load-system :readable)
 (readable:enable-basic-curly) ; or enable-sweet or whatever.

; now you can do:
{3 + 4}


Specification
====================

For Scheme, SRFI-105 is the official definition of
full curly-infix notation, and it also defines neoteric-expressions.
SRFI-110 defines sweet-expressions.  It has an especially rigorous BNF.

The solution.md is the official definition for all other Lisps.
If it's unclear what something means, look at SRFI-105 and SRFI-110
for clarification, but note that the SRFIs include various
Scheme-specific material (e.g., #!sweet is a Scheme-specific mechanism
for enabling sweet-expressions).


Transitioning
=============

The "sweeten" tool is a pretty-printer that translates
s-expressions to sweet-expressions.  You can use "sweeten" to create a file,
hand-tweak the result to make it "prettier", and then use "diff-s-sweet"
to verify that your newly-formatted file has exactly the same meaning.

The "unsweeten" tool can be used as a sweet-expression pre-processor,
so you can use these notations even if your Lisp implementation does not
yet support them.

By default the "sweeten" and "unsweeten" tools process Scheme; if you
have Common Lisp (or something like it), provide the "-C" (Common Lisp)
option as documented.  They can be used as front-ends for other tools.


For more information
===================

For more information, see:
  http://readable.sourceforge.net

Discussions are held on its "readable-discuss" mailing list.

