Readable Lisp S-expressions Project
===================================

This software improves the readability of Lisp S-expressions, by
implementing three tiers of additional abbreviations in S-expressions.
These tiers are (oversimplified):
1. Curly-infix-expressions (c-expressions): Lists surrounded by {...} are
   interpreted as infix notation, in a Lispy way.
2. Neoteric-expressions (n-expressions): An e(...) is interpreted as
   (e ...), an e{...} is interpreted as e({...}).
3. Sweet-expressions (t-expressions): Parentheses are deduced from indentation:
   - An indented line is a parameter of its parent.
   - Later terms on a line are parameters of the first term.
   - A line with exactly one term and no child lines is simply that term.
   - Empty lines end the previous expression. Just type ENTER ENTER
     to execute what you've typed.

Well-formatted traditional s-expressions continue to be read in normally,
so you only need to use the abbreviations when you find them useful.

For more information, see: http://readable.sourceforge.net.
In particular, see the [Tutorial], [Solution], and other pages on the wiki.

Lisp-based languages where this software can be helpful include Common Lisp,
Scheme (including guile), Emacs Lisp, Clojure, Arc, BitC, ACL2,
SUO-KIF, the GCC MiddleEndLispTranslator (MELT),
Satisfiability Modulo Theories Library (SMT-LIB), NewLisp, and ISLisp.


License
=======

The software is released under the MIT license, which permits practically
any use.  The MIT license is an open source software / Free Software
license approved by both the OSI (opensource.org) as an open source software
license, and by the FSF (fsf.org) as a Free software license.

See the COPYING file for the license text.


Building and Installing
=======================

This software supports the usual GNU Build System conventions.
Here are the steps, spelled out.

1. Download/Prepare to configure

You need to get the files.  You've probably done that, since you're
reading this, but here are the basics.

If you want to get the current stable version, go to:

   http://readable.sourceforge.net
   Click on "Download files", and download the current version.
   Then uncompress them; one way is via the command line:
     tar xvzf readable-*.tar.gz
     cd readable-*

If you want to get the latest developmental version, download the
files from our git code repository & prepare it to be configured:

   git clone git://git.code.sf.net/p/readable/code readable-code
   cd readable-code
   autoreconf -i

2. Configure

As usual, configure.  To accept all the defaults, installing to /usr/local:

    ./configure

If you want it to install to /usr (e.g., programs go in /usr/bin):

    ./configure --prefix=/usr

3. Build ("make") / test

Now build the code.

    make

You can optionally run the testsuite; it's a very good idea:

    make check

4. Install ("make install")

You actually don't *have* to install the software.  Just run
"./unsweeten", "./sweeten", "./sweet-guile", and it'll work.
But it's often more convenient to install.  Do this with:

    make install

The usual conventions all work (DESTDIR, VPATH builds, etc.).



Key files
=========

Some of the key files are:

## Installed:

Executables:

*   unsweeten: A filter that reads in (from stdin) a file of
    sweet-expressions, and outputs sweet-expressions.  You can use this
    in "makefiles" so that you can write files using sweet-expressions.
    MIT license.
*   sweeten: A filter that reads in s-expressions (Scheme format) from
    standard in, and generates sweet-expressions on standard out.  MIT license.
*   neoteric-guile: Start up guile, but use neoteric-expressions to
    interact with it. MIT license.
*   sweet-guile: Start up guile, but use sweet-expressions to interact
    with it. MIT license.

Documentation:

*   README: This file.
*   solution.md: A description of the notations this project implements.
    See the project website for the current version of this.
*   tutorial.md: A tutorial.  See the project website for a
    current version of this.
*   spec-indent.txt: Detailed specification information on I-expressions,
    the basis of sweet-expressions.
*   spec-almkglor.txt: A not-so-updated specification for the
    entire sweet-expression spec, created by Alan Manuel K. Gloria.
*   sweeten.sscm: An example of code written using sweet-expressions.
    This is the original source code for "sweeten", which reads
    traditional s-expressions and writes sweet-expression versions of them.

The spec-* files need to be updated (volunteers welcome).  For now, see
"solution.md" for the real specification.

## Not Installed:

*   src/kernel.scm: An implementation of the three notation tiers
    curly-infix-read, neoteric-read, and sweet-read.  Implemented in the
    Guile dialect of Scheme; it includes hooks for other dialects.  This is
    installed into the "readable" site directory of guile. MIT license.
*   src/sweeten.sscm: The source of the "sweeten" program.  It's written
    in Scheme using sweet-expressions, so if you want to see what
    sweet-expressions look like, well, here's an example.
*   curly-infix.cl: A simple Common Lisp reader readtable macro that
    implements infix operations in lists surrounded by {...}.  MIT license.


Key directories
===============

src/      - Most source files
bin/      - Generated command (script) files for installation
readable/ - Guile library (generated, don't edit these)
tests/    - Test scripts and test cases

The "src/" directory holds most of the source code.
A "make" will generate files in the top dir, bin/ directory, and the
readable/ directory.  The generated files in the top directory are
scripts designed to invoke the locally-built readable library, even if
there's another one installed.

File suffixes are:
.cl    - Common Lisp
.lisp  - Common Lisp
.scm   - Scheme
.sscm  - Sweet-Scheme; Scheme written with sweet-expressions.

You can invoke the readers from your own Guile programs by doing:
  (use-modules (readable kernel))
and you can even:
  (replace-read sweet-read)

On Guile 2.0 there are occassional strangenesses in the interaction
between the module system and autocompilation - the particular
strangeness is when autocompilation is turned OFF.  If you want to
use sweet-guile or neoteric-guile, turn ON autocompilation, as
otherwise use-modules will use the default reader rather than
what you replace.

For more information
===================

For more information, see:
  http://readable.sourceforge.net

Discussions are held on the mailing list.

