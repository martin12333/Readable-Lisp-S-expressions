# Makefile.am for "readable" project

# Copyright (C) 2007-2013 by David A. Wheeler and Alan Manuel K. Gloria.
#
# This software is released as open source software under the "MIT" license:
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.


# Usual automake header, so some auxilliary files are tucked into m4/:

ACLOCAL_AMFLAGS = -I m4 --install
EXTRA_DIST = m4/DUMMY

# GNU Standards "General Conventions for Makefiles" says set SHELL.  The
# autoconf documentation section "The Make Macro SHELL" says do it this way
# (automake will do this automatically, but doing this here will force
# automake to generate definitions in a more reasonable order):
SHELL = @SHELL@


# Guile original source files are in "src/".  At build time we create
# the guile library files in "readable/" and user-executable scripts in
# "bin/". The "bin/" scripts depend on the final GUILE_SITE location
# of the library.  These files will be installed by "make install".

# As a convenience for testing, we *also* create scripts in the *current*
# (top) directory that will depend on the local "readable/" versions,
# *EVEN IF* another version of the readable library is installed.
# This way, when testing, you can just use
# ./unsweeten (or whatever) and it will depend on the development version
# without having to set an environment variable (which is easy to forget).
# If we don't do this, it'll be easy to test the "wrong version" of the
# library, wasting time.

UNSWEETEN = ./unsweeten

# Here is the usual POSIX-portable inference rule for unsweetening:
# .sscm.scm:
#	$(UNSWEETEN) < $< > $@
# .SUFFIXES: .sscm .scm
# We can't use that inference rule in this makefile, because POSIX doesn't
# allow us to portably declare a dependency in inference rules.
# Since we're *building* unsweeten, we *do* have such a dependency.
# A lot of makes will let you do it anyway, as an obvious extension,
# but in this Makefile we'll use the more portable approach
# of giving separate rules for each target.


if HAVE_MARKDOWN
# Rules for translating markdown (.md) files into HTML.
SUFFIXES = .md .html
.md.html:
	rm -f "$@"
	(    cat $(srcdir)/head.html ; \
	     $(MARKDOWN) $< ; \
	     cat $(srcdir)/tail.html ) | \
	  $(SED) -e "s/@TITLE[@]/"$*"/g" > $@
	chmod a-w "$@"
endif HAVE_MARKDOWN

EXTRA_DIST += head.html tail.html markdown-urls
EXTRA_DIST += markdown2.py

# ####################################################
# Definitions for creating generated scripts/files
# ####################################################

# We generate scripts, and install some of them.
# We id the sources in EXTRA_DIST, generated files in [dist_]bin_SCRIPTS,
# and all generated files are in CLEANFILES;
# see the automake documentation's section titled "Executable Scripts".
# It's easier to vary what's installed, based on configuration options,
# by setting some values to empty and using +=.

CLEANFILES =
bin_SCRIPTS =
dist_bin_SCRIPTS =
noinst_SCRIPTS =
PHONIES =

# We always want to include sources in the distribution, configured or not.

script_sources = src/sweeten.sscm src/unsweeten \
                 src/curly-guile src/neoteric-guile src/sweet-guile \
                 src/sweet-run src/sweet-scsh \
                 src/diff-s-sweet \
                 src/kernel.scm \
                 src/srfi-curly-infix.scm \
                 src/sweet-clisp src/sweet-sbcl

EXTRA_DIST += $(script_sources)


# This lists scripts that will be generated by "make", and later installed:
generated_bin_scripts =
# This lists scripts that will be generated by "make" for "local" (.) use:
generated_local_scripts =

# Here we define how to generate these scripts.
# Note: If you change how scripts are generated, run "make clean && make"
# to forceably regenerate them.

# The following assumes that none of these values have "!" in them.
# The [@] trick is described in "Autotools" by John Calcote,
# "Emulating Autoconf Text Replacement Techniques", pg 297:
generate_some_command_sed = echo "Generating  $@" ; $(SED) \
  -e "s!@GUILE[@]!$(GUILE)!g" \
  -e "s!@GUILE_READLINE_AVAILABLE[@]!$(GUILE_READLINE_AVAILABLE)!g" \
  -e "s!@BIN_ENV[@]!$(BIN_ENV)!g" \
  -e "s!@EXPECT[@]!$(EXPECT)!g" \
  -e "s!@SCSH[@]!$(SCSH)!g" \
  -e "s|@WARNING_MESSAGE[@]|Generated automatically, DO NOT EDIT!|g"

generate_bin_command_sed = $(generate_some_command_sed) \
  -e "s!@GUILE_LIBRARY_DIRECTORY[@]!$(readable_libdir)!g" \
  -e "s!@PATH_PREFIX[@]!!g" \
  -e "s!@OVERRIDE_CL_SOURCE_REGISTRY[@]!!g"

generate_local_command_sed = $(generate_some_command_sed) \
  -e "s!@GUILE_LIBRARY_DIRECTORY[@]!$(abs_builddir)!g" \
  -e "s!@PATH_PREFIX[@]!$(abs_builddir)$(PATH_SEPARATOR)!g" \
  -e "s!@OVERRIDE_CL_SOURCE_REGISTRY[@]!$(abs_builddir)!g"

# Unfortunately "$<" is only portable inside inference rules (see POSIX).
# So, we'll use $? instead.  Unfortunately, this means that we cannot
# express dependencies involving configuration changes; if a user
# changes the values of prefix, etc., they need to "make clean" first.

generate_bin_command = \
  @$(MKDIR_P) bin ; \
  $(generate_bin_command_sed) < $?  > $@ ; \
  chmod a+x $@

generate_local_command = \
  @$(RM) -f $@ ; \
  $(generate_local_command_sed) < $?  > $@ ; \
  chmod a+x $@ ; \
  chmod a-w $@




# ####################################################
# Guile library and scripts/tools that depend on it
# ####################################################

if HAVE_GUILE
readable_libdir = $(GUILE_SITE)/readable

readable_lib_DATA = readable/kernel.scm

# "Local" version so we can test things without installing them.
readable/kernel.scm: src/kernel.scm
	$(MKDIR_P) readable
	cp -p "$(srcdir)/src/kernel.scm" readable/kernel.scm

CLEANFILES += readable/kernel.scm
endif HAVE_GUILE


if HAVE_GUILE

# These are generated for eventual installation in the bindir:

generated_bin_scripts += bin/sweeten bin/unsweeten \
                         bin/curly-guile bin/neoteric-guile bin/sweet-guile \
                         bin/sweet-run \
                         bin/diff-s-sweet

# These generated into the local build directory (.),
# for testing and ease-of-use (so people don't have to install things).
# These files are *not* directly installed.
# It's the same list as above, with "." instead of "bin", but there doesn't
# seem to be a standard way in make to change *prefixes* without using
# GNU make extensions like $(NAME:...%...=...%...) or $(addprefix ...).

generated_local_scripts += ./sweeten ./unsweeten \
                         ./curly-guile ./neoteric-guile ./sweet-guile \
                         ./sweet-run \
                         ./diff-s-sweet

if HAVE_SCSH
generated_bin_scripts += bin/sweet-scsh
generated_local_scripts += ./sweet-scsh
endif HAVE_SCSH


# Rules for creating scripts (when we need to do so)

bin/sweeten: src/sweeten.sscm ./unsweeten
	@$(MKDIR_P) bin
	@$(generate_bin_command_sed) \
	   < "$(srcdir)/src/sweeten.sscm" | ./unsweeten > $@
	@chmod a+x $@

bin/unsweeten: src/unsweeten
	$(generate_bin_command)

bin/curly-guile: src/curly-guile
	$(generate_bin_command)

bin/neoteric-guile: src/neoteric-guile
	$(generate_bin_command)

bin/sweet-guile: src/sweet-guile
	$(generate_bin_command)

bin/sweet-scsh: src/sweet-scsh
	$(generate_bin_command)

bin/sweet-run: src/sweet-run
	$(generate_bin_command)

bin/diff-s-sweet: src/diff-s-sweet
	$(generate_bin_command)

# Rules for making local versions.

sweeten: src/sweeten.sscm ./unsweeten
	@$(RM) -f $@
	@$(generate_local_command_sed) \
           < "$(srcdir)/src/sweeten.sscm" | ./unsweeten > $@
	@chmod a+x $@

# Make "unsweeten" depend on the underlying library.
# That way, once "./unsweeten" is created, we know that it's ready to use
# (because its dependencies have been installed). Then other rules can just
# depend on "./unsweeten", and they won't start until unsweeten is ready.
unsweeten: src/unsweeten readable/kernel.scm
	@$(RM) -f $@
	@$(generate_local_command_sed) \
	    < "$(srcdir)/src/unsweeten" > $@
	@chmod a+x $@
	@chmod a-w $@

curly-guile: src/curly-guile
	$(generate_local_command)

neoteric-guile: src/neoteric-guile
	$(generate_local_command)

sweet-guile: src/sweet-guile
	$(generate_local_command)

sweet-scsh: src/sweet-scsh
	$(generate_local_command)

sweet-run: src/sweet-run
	$(generate_local_command)

diff-s-sweet: src/diff-s-sweet
	$(generate_local_command)

sweeten.sscm: src/sweeten.sscm
	$(generate_local_command)

endif HAVE_GUILE


# ####################################################
# Common Lisp library and scripts that depend on it
# ####################################################

# We'll install Common Lisp library source code in the conventional place,
# and let the usual Common Lisp mechanisms (e.g., asdf) handle compiling
# as needed.

CLISP = @CLISP@

common_lispdir = @COMMON_LISP_LIB_DIR@
common_lisp_sourcedir = $(common_lispdir)/source
common_lisp_source_pkgdir = $(common_lisp_sourcedir)/readable
common_lisp_systemsdir = $(common_lispdir)/systems

pkg_asd_file=readable.asd

if INSTALL_COMMON_LISP_LIB
dist_common_lisp_source_pkg_DATA = \
 basic-curly.lisp neoteric.lisp backquote.lisp sweet.lisp

dist_common_lisp_source_pkg_DATA += $(pkg_asd_file)

if HAVE_REGISTER_COMMON_LISP_SOURCE
# We have a register-common-lisp-source program available.
# If we're doing a "real" install (no DESTDIR) to /usr, use it:
MAYBE_REGISTER_CL = \
  test "$(DESTDIR)" != ""  || \
  test "$(prefix)" != '/usr' || \
  ( echo "Registering Common Lisp files" ; \
    @REGISTER_COMMON_LISP_SOURCE@ readable )
else !HAVE_REGISTER_COMMON_LISP_SOURCE
MAYBE_REGISTER_CL = echo "Note: No registration performed."
endif !HAVE_REGISTER_COMMON_LISP_SOURCE

if HAVE_UNREGISTER_COMMON_LISP_SOURCE
MAYBE_UNREGISTER_CL = \
  test "$(DESTDIR)" != ""  || \
  test "$(prefix)" != '/usr' || \
  ( echo "Unregistering Common Lisp files" ; \
    @UNREGISTER_COMMON_LISP_SOURCE@ readable )
else !HAVE_UNREGISTER_COMMON_LISP_SOURCE
MAYBE_UNREGISTER_CL = echo "Note: No unregistration performed."
endif !HAVE_UNREGISTER_COMMON_LISP_SOURCE

# Convenience target.  "make direct_cl_dir=DIR direct-common-lisp-install"
# installs Common Lisp .lisp and .asd files directly to $direct_cl_dir, which
# MUST be supplied.  This target is NOT used by anything else;
# normally we put these files in special locations.
direct-common-lisp-install:
	$(MKDIR_P) "$(direct_cl_dir)" && \
	cp -p $(dist_common_lisp_source_pkg_DATA) "$(direct_cl_dir)"

PHONIES += direct-common-lisp-install


# Install symlink so asdf can find these files. See:
# http://www.gnu.org/software/automake/manual/html_node/Extending.html
# We first try to "rm" the symlink, in case it already exists.
# Note that the LN_S must *not* use DESTDIR in its first parameter.

install-exec-hook-cl:
	$(MKDIR_P) "$(DESTDIR)$(common_lisp_source_pkgdir)"
	$(MKDIR_P) "$(DESTDIR)$(common_lisp_systemsdir)"
	$(RM) -f "$(DESTDIR)$(common_lisp_systemsdir)/$(pkg_asd_file)"
	$(LN_S)  "$(common_lisp_source_pkgdir)/$(pkg_asd_file)" \
	         "$(DESTDIR)$(common_lisp_systemsdir)/$(pkg_asd_file)"
	@$(MAYBE_REGISTER_CL)

install-exec-hook: install-exec-hook-cl

uninstall-hook-cl:
	@$(MAYBE_UNREGISTER_CL)

uninstall-hook: uninstall-hook-cl

endif INSTALL_COMMON_LISP_LIB

if HAVE_CLISP
generated_bin_scripts += bin/sweet-clisp
generated_local_scripts += ./sweet-clisp

bin/sweet-clisp: src/sweet-clisp
	$(generate_bin_command)

sweet-clisp: src/sweet-clisp
	$(generate_local_command)
endif HAVE_CLISP

if HAVE_SBCL
generated_bin_scripts += bin/sweet-sbcl
generated_local_scripts += ./sweet-sbcl

bin/sweet-sbcl: src/sweet-sbcl
	$(generate_bin_command)

sweet-sbcl: src/sweet-sbcl
	$(generate_local_command)
endif HAVE_SBCL


# #######################################################
# Ensure that generated scripts are built and cleaned up.
# #######################################################

# These bindir scripts are generated at build time, so they're not distributed
# (there's no dist_ prefix for bin_SCRIPTS here):
bin_SCRIPTS += $(generated_bin_scripts)

# The local scripts are not distributed nor installed:
noinst_SCRIPTS += $(generated_local_scripts)

# Clean up generated scripts.
CLEANFILES += $(generated_bin_scripts) $(generated_local_scripts)


# ####################################################
# ANTLR and demonstration materials
# ####################################################


# Implementation and test cases for ANTLR implementation
# of sweet-expressions.  Again, don't install.
EXTRA_DIST += sweet.g
EXTRA_DIST += output/input.txt output/correct.txt output/go
EXTRA_DIST += output/scheme/Pair.java

# Distribute extra examples (but don't install them).
EXTRA_DIST += \
 examples/sweet-run-demo-guile \
 examples/sweet-run-demo-scsh \
 examples/sweet-run-demo-clisp \
 examples/list-of.sscm \
 examples/simple-nfx.sscm \
 examples/streams.sscm \
 examples/basic-sweet.sscm \
 examples/Makefile.example \
 examples/README

# ####################################################
# Documentation
# ####################################################

# Distribute some documentation.
# README is distributed anyway; this just makes it clearer.
# Distribute some description of the solution and tutorial,
# in markdown format.  The website has the updated version, but for
# those who just have this file, it'd be useful to have SOME useful
# information on what this code is trying to do and how to use it.
dist_doc_DATA = README COPYING COPYING.GPL AUTHORS ChangeLog

# Distribute demo Makefile as documentation, to help ease use.
dist_doc_DATA += Makefile-demo

dist_doc_DATA += README-ANTLR README-files

# These the markdown (.md) files that are on the Wiki and we'll
# duplicate in the distributed package:
MDMIRRORS = Problem.md Solution.md Install-howto.md Retort.md \
            Scheme-tutorial.md Common-lisp-tutorial.md

# These are stub files that link to the website:
MDSTUBS = Rationale.md Examples.md

# These are all markdown (.md) files, including stubs:
MDFILES = $(MDMIRRORS) $(MDSTUBS)
HTML_FROM_MDFILES = $(MDFILES:.md=.html)

dist_doc_DATA += $(MDFILES)

# Generate, distribute, and install HTML files generated from .md files:
dist_doc_DATA += $(HTML_FROM_MDFILES)
# Set so "make maintainer-clean" will remove the generated HTML files:
MAINTAINERCLEANFILES = $(HTML_FROM_MDFILES)


# Man pages
dist_man_MANS =

if HAVE_GUILE
dist_man_MANS += man/unsweeten.1 man/sweet-run.1 \
                 man/sweeten.1 man/diff-s-sweet.1
endif HAVE_GUILE
if HAVE_CLISP
dist_man_MANS += man/sweet-clisp.1
endif HAVE_CLISP


# Presentation in Open Document Format (.odp) about these formats:
dist_doc_DATA += readable-s-expressions.odp

# Include SRFI specifications as documentation:
dist_doc_DATA += SRFI-105.html SRFI-110.html

# Include in documentation some trivial example of a Common Lisp program,
# in ".lisp" and ".slisp" formats:
dist_doc_DATA += factorial.lisp
dist_doc_DATA += factorial.slisp

# This is an odd case.  Since we're distributing a tool for developers,
# it's useful to have worked examples.  So here we install the
# "sweeten.sscm" file as a worked example.
dist_doc_DATA += src/sweeten.sscm



# ####################################################
# Tests and test drivers
# ####################################################


# Distribute test drivers and testsuites.
EXTRA_DIST += \
 tests/curly-infix-test-cl \
 tests/curly-infix-testsuite-scm \
 tests/curly-infix-test-scm \
 tests/full-test-cl \
 tests/neoteric-test \
 tests/neoteric-testsuite \
 tests/sweet-test \
 tests/sweet-testsuite \
 tests/roundtrip-test \
 tests/roundtrip-testsuite \
 tests/pprint \
 tests/sweeten-testsuite \
 tests/sweeten-correct \
 tests/unsweeten-testsuite \
 tests/unsweeten-correct \
 tests/unsweeten-cl-testsuite \
 tests/unsweeten-cl-correct \
 tests/curly-infix-correct2 \
 tests/curly-infix-testsuite2 \
 tests/write-test \
 tests/write-test-correct

# TODO: Improve test harness & integration into overall system.

EXTRA_DIST += my-realpath
check: check-clisp check-guile

if HAVE_CLISP
check-clisp: my-realpath
	@echo "Starting tests for CLISP"
	CL_SOURCE_REGISTRY="`$(srcdir)/my-realpath $(srcdir)`"/ \
	  $(CLISP) -lp "`$(srcdir)/my-realpath $(srcdir)`/tests/" \
	        $(srcdir)/tests/curly-infix-test-cl
	CL_SOURCE_REGISTRY="`$(srcdir)/my-realpath $(srcdir)`"/ \
	  $(CLISP) -lp "`$(srcdir)/my-realpath $(srcdir)`/tests/" \
	        $(srcdir)/tests/full-test-cl
else !HAVE_CLISP
check-clisp:
endif !HAVE_CLISP

if HAVE_GUILE
check-guile: readable/kernel.scm my-realpath
	@echo "Starting tests for GUILE"
	@echo "About to run guile curly-infix tests"
	GUILE_LOAD_PATH="$(builddir)" $(srcdir)/tests/curly-infix-test-scm \
	            < $(srcdir)/tests/curly-infix-testsuite-scm
	@echo "About to run neoteric-testsuite"
	GUILE_LOAD_PATH="$(builddir)" $(srcdir)/tests/neoteric-test \
	            < $(srcdir)/tests/neoteric-testsuite
	@echo "About to run sweet-testsuite"
	GUILE_LOAD_PATH="$(builddir)" $(srcdir)/tests/sweet-test \
	            < $(srcdir)/tests/sweet-testsuite
	@echo "About to run write-test"
	GUILE_LOAD_PATH="$(builddir)" $(srcdir)/tests/write-test \
             | diff -b -u "$(srcdir)/tests/write-test-correct" -
	@echo "Running srfi-curly-infix, showing diffs from correct results:"
	GUILE_LOAD_PATH="$(builddir)" guile \
	            $(srcdir)/src/srfi-curly-infix.scm < \
	            $(srcdir)/tests/curly-infix-testsuite2 | \
	          diff -u "$(srcdir)/tests/curly-infix-correct2" -
	@echo "Running unsweeten, showing differences from correct results:"
	"$(builddir)/unsweeten" < "$(srcdir)/tests/unsweeten-testsuite" 2>&1 | \
	     diff -b -u "$(srcdir)/tests/unsweeten-correct" -
	test "`printf '\140(a b c ,d)\n' | \"$(builddir)/unsweeten\" -C`" = \
	     '`(a b c ,d)'
	"$(builddir)/unsweeten" -C < "$(srcdir)/tests/unsweeten-cl-testsuite" \
             | diff -b -u "$(srcdir)/tests/unsweeten-cl-correct" -
	@echo "Running sweeten, showing differences from correct results:"
	"$(builddir)/sweeten" < "$(srcdir)/tests/sweeten-testsuite" | \
	     diff -u "$(srcdir)/tests/sweeten-correct" -
	@echo "About to run roundtrip-test"
	PATH="$(builddir):$(srcdir)/tests:${PATH}" \
	     $(srcdir)/tests/roundtrip-test $(srcdir)/tests/roundtrip-testsuite
else !HAVE_GUILE
check-guile:
endif !HAVE_GUILE


if HAVE_GUILE
installcheck-guile:
	test "`printf 'a b {2 + 3}\n\n' | ./unsweeten | head -1`" = \
	      '(a b (+ 2 3))'
else !HAVE_GUILE
installcheck-guile:
endif !HAVE_GUILE

if HAVE_CLISP
installcheck-clisp:
	printf 'princ {3 + 4}\n\n' > ,sweet-clisp-test
	test 7 = "`sweet-clisp ,sweet-clisp-test 2> /dev/null | tail -n 1`"
else !HAVE_CLISP
installcheck-clisp:
endif !HAVE_CLISP

# The installchecks won't work in a "make distcheck", because
# they won't be installed in the final location used by the tools.
if IS_MAKE_DISTCHECK
installcheck-local:
	echo "Running 'make distcheck'; local installchecks disabled."
else !IS_MAKE_DISTCHECK
installcheck-local: installcheck-clisp installcheck-guile
endif !IS_MAKE_DISTCHECK


# For convenience, we'll include a copy of the external asdf.lisp file from
# http://common-lisp.net/project/asdf/asdf.lisp as of 2013-10-02.
# This is *NOT* changed from the external project, and users do *NOT*
# need to use this version.  We just provide it so that users
# who do not already have it can get something to use, quickly.
EXTRA_DIST += external/asdf.lisp


CLISP_ASDF_FILE = ${HOME}/lisp/asdf/asdf.lisp
SYSTEM_ASDF_FILE = /usr/share/common-lisp/source/cl-asdf/asdf.lisp

clisp-asdf:
	@echo "Configuring this user account so clisp can invoke asdf"
	@if test -r "$(CLISP_ASDF_FILE)" ; then \
	  echo "ASDF already installed for this user" ; \
	 else \
	  if test -r "$(SYSTEM_ASDF_FILE)" ; then \
            echo "Creating link to system asdf file $(SYSTEM_ASDF_FILE)" ; \
            echo $(LN_S) "$(SYSTEM_ASDF_FILE)" "$(CLISP_ASDF_FILE)" ; \
            $(LN_S) "$(SYSTEM_ASDF_FILE)" "$(CLISP_ASDF_FILE)" ; \
          else \
            echo "Copying local asdf to $(CLISP_ASDF_FILE)" ; \
            echo cp -p "$(srcdir)/external/asdf.lisp" "$(CLISP_ASDF_FILE)" ; \
            cp -p "$(srcdir)/external/asdf.lisp" "$(CLISP_ASDF_FILE)" ; \
          fi ; \
	 fi
	@echo
	@echo "Attempting to compile"
	clisp -q -c "$(CLISP_ASDF_FILE)"
	@echo
	@echo "Attempting to re-run configure with same configuration options"
	eval $(srcdir)/configure "`./config.status --config`" --srcdir=$(srcdir)

PHONIES += clisp-asdf


# ####################################################
# Create RPM files
# ####################################################

# The following creates an "rpm" package, using an rpm spec file.
# It focuses on Fedora, but it should be a good starting point for
# other packages.  If you package for Fedora, be sure to set up your system:
# - yum install @development-tools
# - yum install fedora-packager
# For more information on RPM and Fedora, see:
# - http://fedoraproject.org/wiki/How_to_create_an_RPM_package
# - http://fedoraproject.org/wiki/Packaging:Guidelines
# Note that the results will be in "~/rpmbuild/RPMS/".

SPECFILE = readable.spec
EXTRA_DIST += $(SPECFILE) readable-simple.spec



# ####################################################
# Developer conveniences
# ####################################################

# "make push" interpreted as "git push" when current branch is "develop".
push:
	[ "`git symbolic-ref HEAD`" = "refs/heads/develop" ] && \
	    git push origin develop

# "make pull" interpreted as "git pull"
pull:
	git pull

# "make test" interpreted as synonym for "make check"
test: check

# Create SRFI-110 files to distribute.
srfi_110_fileset = SRFI-110.html sweet.g src/kernel.scm output/scheme/Pair.java
110.tar.gz: $(srfi_110_fileset)
	rm -fr 110/
	mkdir  110/
	cp -p $(srfi_110_fileset) 110/
	tar cvzf 110.tar.gz 110/
	rm -fr 110/

110: 110.tar.gz

# Development test convenience targets.
# The following record, and show diffs, of generated files.
# These are useful for ensuring that changes to file generation mechanism
# only produce expected changes.  The "$$" escapes shell variables for make.
record-generated:
	rm -fr rd/
	$(MKDIR_P) rd/bin/
	for file in $(generated_bin_scripts) $(generated_local_scripts) ; \
	    do cp -p "$${file}" "rd/$${file}" ; done

diff-generated:
	test -d rd/bin/
	for file in $(generated_bin_scripts) $(generated_local_scripts) ; \
	    do diff -u "$${file}" "rd/$${file}" ; done

rpm: $(DIST_ARCHIVES) $(SPECFILE)
	@echo "REMINDER: Run 'make dist' if you have updated the distribution"
	cp -p $(DIST_ARCHIVES) ~/rpmbuild/SOURCES/
	cp -p $(SPECFILE) ~/rpmbuild/SPECS/
	rpmbuild -ba $(SPECFILE)
	-rpmlint $(SPECFILE)

# Extract possibly-updated .md files from the wiki:
from-wiki:
	./get-from-wiki $(MDMIRRORS)

PHONIES += push pull test 110 rpm check-clisp check-guile \
           record-generated diff-generated from-wiki clisp-asdf

.PHONY: $(PHONIES)

