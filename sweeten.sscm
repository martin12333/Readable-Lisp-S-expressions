; iformat.scm
; Filter to read S-expressions and output indented sweet-expression.
;
; Copyright (C) 2006-2012 David A. Wheeler.
;
; This software is released as open source software under the "MIT" license:
;
; Permission is hereby granted, free of charge, to any person obtaining a
; copy of this software and associated documentation files (the "Software"),
; to deal in the Software without restriction, including without limitation
; the rights to use, copy, modify, merge, publish, distribute, sublicense,
; and/or sell copies of the Software, and to permit persons to whom the
; Software is furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.

; In generated .scm (but not in .sscm) you can enable debugging using:
; (use-modules (ice-9 debugging traps) (ice-9 debugging trace))

; Note: The maxwidth may be violated if, at a current indent, there is a
; long non-pair that exceeds it.  But other than long atoms, it's respected,
; so it's unlikely to exceed this width in practice:
define maxwidth 78

define indent-increment '(#\space #\space)
define max-unit-character-length 60
define max-unit-list-length 8
define boring-length 16

define group-string "\\\\"
define group-string-newline "\\\\\n"
define group-list string->list(group-string)
define infix-operators '(
            and or xor + - * / ^ ++ -- ** // ^^ < <= > >= = <> != ==)


; This program automatically handles various end-of-line situations.
; An end-of-line is a sequence of two different end-of-line chars,
; otherwise, it is a single end-of-line char.
; Thus we handle \n, \r\n, \n\r, \r, and variations of <next line> too.
; To do this, we need a list of end-of-line characters:
define end-of-line-chars
  list 
    integer->char(#x0a)     ; <linefeed>, aka \n
    integer->char(#x0d)     ; <carriage return>, aka \r
    integer->char(#x85)     ; <next line>
    ; If wide chars are supported, add this:
    ; integer->char(#x2028)   ; <line separator>


; Given an indent, return the next deeper indent.
define deeper(indent)
  append(indent indent-increment)


; Lists with these symbols as first parameter, and aren't shown as 1 line,
; are be shown as a line with SYMBOL FIRST-PARAMETER and *then* indents.
; This is used when in typical uses the first parameter is *special* and
; has a different semantic meaning from later parameters.
; This refinement isn't *necessary* but I think it looks better.
define cuddle-first-parameter '(define lambda
           if when unless case
           set! let let* letrec let1 do
           define-module                  ; Guile modules
           library export import          ; R6RS library modules
           defun block typecase           ; Common Lisp
           let-syntax letcrec-syntax define-syntax syntax-rules)


define tab integer->char(9)
define LISTLP list( #\( )
define LISTRP list( #\) )
define LISTLBRACE list((integer->char 123))
define LISTRBRACE list((integer->char 125))


; Return length of x, which may be an improper list.
; If improper, count the two sides as two, so "(a . b)" is length 2.
define general-length(x)
  general-length-inner(x 0)

define general-length-inner(x count-so-far)
  cond
    null?(x)      count-so-far
    not(pair?(x)) {count-so-far + 1}
    #t
                  general-length-inner cdr(x) {count-so-far + 1}

; Return list x's *contents* represented as a list of characters.
; Each one must use modern-expressions, space-separated;
; it will be surrounded by (...) so no indentation processing is relevant.
define unit-list(x)
  cond
    null?(x) '()
    pair?(x)
      if null?(cdr(x))
        unit car(x)
        append unit(car(x)) '(#\space) unit-list(cdr(x))
    #t  append('(#\space #\. #\space) unit(x))


; Return #t if x should be represented using curly-infix notation {...}.
define represent-as-infix?(x)
  and
    pair? x
    symbol? car(x)
    memq car(x) infix-operators
    list? x
    {length(x) >= 3}
    {length(x) <= 6}

; Return tail of an infix expression, as list of chars
define infix-tail(op x)
  cond
    null?(x)  LISTRBRACE
    pair?(x)  append( '(#\space) op '(#\space) unit(car(x))
                       infix-tail(op cdr(x)) )
    ; The following is used if we get an improper list.
    ; This can't happen if only lists are represented with curly-infix:
    #t        append( '(#\space #\. #\space) unit(x) LISTRBRACE)

; Define an association list of Lisp abbreviations.
; Eventually use "group" to define this, but currently the group
; symbol is under discussion, so best not to use it yet:
define abbreviations '(
  (quote (#\'))
  (quasiquote (#\`))
  (unquote (#\,))
  (unquote-splicing (#\, #\@)))


; return #t if we should as a traditional abbreviation, e.g., '
define represent-as-abbreviation?(x)
  and
    assq car(x) abbreviations
    pair? cdr(x)
    null? cddr(x)

; Given list of characters, return the characters that would REPRESENT
; those characters inside a string AFTER the initial double-quote,
; then return the double-quote.  This translates newline to \n, etc.
define unit-string-tail(x)
  if null?(x)
    '(#\")  ; Return the string's closing double-quote.
    append
      let ((c car(x)))
        cond             ; Can't use "case" because of "tab" variable.
          eq?(c #\\)        '(#\\ #\\)
          eq?(c #\")        '(#\\ #\")
          ; These aren't in R5RS, but NOT escaping them will
          ; cause more trouble:
          eq?(c #\newline)  '(#\\ #\n)
          eq?(c tab)        '(#\\ #\t)
          #t                list(car(x))
      unit-string-tail cdr(x)

; Return x represented as a modern-expression unit, as a list of characters.
; Indentation processing *may* be active, but the character sequence
; returned must not depend on that.
; This is widely-used; may want to memoize this.
define unit(x)
  cond
    null?(x)     string->list("()")
    number?(x)   string->list(number->string(x))
    boolean?(x)  if(x '(#\# #\t) '(#\# #\f))
    symbol?(x)   string->list(symbol->string(x))
    string?(x)   append('(#\") unit-string-tail(string->list(x)))
    pair?(x)
     cond
       represent-as-abbreviation?(x)
         append cadr(assq(car(x) abbreviations)) unit(cadr(x))
       symbol?(car(x))
         if represent-as-infix?(x)
           append LISTLBRACE unit(cadr(x)) infix-tail(unit(car(x)) cddr(x))
           append unit(car(x)) LISTLP unit-list(cdr(x)) LISTRP
       #t append(LISTLP unit-list(x) LISTRP)
    #t  string->list(object->string(x))
    ; R5RS doesn't include "object->string", but it's painful to do without.
    ; You might be able to use these in a pinch:
    ; char?(x)     append '(#\# #\\) x ; Doesn't handle special chars


; Return x, the rest of the list, as a list of characters. See line().
define line-tail(x)
  cond
    null?(x)  '()
    pair?(x)
      append unit(car(x)) '(#\space) line-tail(cdr(x))
    #t
      append '(#\. #\space) unit(x)

; Return x represented as a line of space-separated modern-expression units,
; as a list of characters.
; Indentation processing *MUST* be active.
define line(x)
  cond
    not(pair?(x))                 unit(x)
    represent-as-abbreviation?(x) unit(x)
    represent-as-infix?(x)        unit(x)
    {pair?(x) and null?(cdr(x))} ; Handle 1-datum case specially.
      if symbol?(car(x))
        append unit(car(x)) LISTLP LISTRP
        append LISTLP unit(car(x)) LISTRP
    #t
      append unit(car(x)) '(#\space) line-tail(cdr(x))

; a list is boring if it has ONLY non-pair members.
define boring?(x)
  cond
    not(pair?(x))  #t  ; This includes (), which is boring & the end.
    pair?(car(x))  #f
    #t             boring?(cdr(x))

; A list is long and boring if it's a list, it's boring, and
; its length is longer than the boring-length.
; Such a list is almost certainly NOT a function call or a
; body of some executable sequence, instead, it's almost certainly a long
; boring list of data
define long-and-boring?(x)
  cond
    not(pair?(x))                 #f
    not(list?(x))                 #f
    {length(x) < boring-length}   #f
    #t                            boring?(x)



; Return list "m" as a list of characters representing
; a long and boring split list.  We'll keep track of position inside
; this routine, since we can do that easily here.
define iformat-boring-list(x first? pos next-indent)
  cond
    null?(x) '(#\newline)
    first?
      ; if first, force its disply, even if that goes beyond width max.
      let (item(unit(car(x))))
        append item 
          iformat-boring-list(cdr(x) #f {pos + length(item)} next-indent)
    #t ; Not first.
      let (item(unit(car(x))))
        let (item-sameline(append('(#\space) group-list '(#\space) item)))
          if {{pos + length(item-sameline)} < maxwidth}
            append item-sameline
              iformat-boring-list cdr(x) #f
                {pos + length(item-sameline)} \\ next-indent
            begin
              append '(#\newline) next-indent
                iformat-boring-list x #t length(next-indent) next-indent

; Input: expression "m" with indentation string "indent".
; Output: List of characters representing it (#\newline for new line).
; This tail handles the body of a list (after its first entry) when
; indentation processing is active, each of these is its own initial line.
define iformat-body(m indent indent-already)
  if null?(m)
    '()
    append
      iformat-top  car(m) indent indent-already
      iformat-body cdr(m) indent #f

; Return list m represented in the typical indent style.
define iformat-top-normal-indent(x indent indent-already)
  if represent-as-abbreviation?(x)
    ; Use QUOTE+SPACE, etc.
    ; Problem: iformat-top doesn't have a way of NOT inserting an indent,
    ; and here we want to do the insert ourselves.
    ; The result isn't WRONG (as long as the indent only contains whitespace)
    ; but is not what we wanted.
    ; Also, this is a slight cheat in the formatter;
    ; it means that the "indent" parameter no longer represents the
    ; exact character position.   Fixing this exactly would require us
    ; to pass a "position" value around all the functions, and it's
    ; unlikely to affect anything, so we won't worry about it.
    append indent cadr(assq(car(x) abbreviations)) '(#\space)
      iformat-top(cadr(x) indent #f) ; TODO!!!
    append
      iformat-top  car(x) indent indent-already
      iformat-body cdr(x) deeper(indent) #f

; Return the string to add as indentation; should be empty if indentation
; has already occurred.
define getdent(indent-already indent)
  if indent-already
    ""
    indent

; What's the number of characters consumed in the indent (and thus
; the column position starting from 0)?
define posdent(indent-already indent)
  if indent-already
    length(indent-already)
    length(indent)

; Input: expression "m" with indentation string "indent".
;        indent-already if #f if no indentation has already taken place,
;        or if indentation *has* taken place, it contains the string of
;        indentation and any following characters that's occurred
;        (so char position, etc., can be determined).
; Output: List of characters representing it (#\newline for new line).
; At this point, we're at the beginning of a possibly-indented
; line with sweet-expression (indentation) processing active.
define iformat-top(m indent indent-already)
  if not(pair?(m)) ; if not a pair, just print it. () handled here
    append(getdent(indent-already indent) unit(m) '(#\newline))
    ; We have a pair. Can we represent it as one line of space-sep params?
    let* (asline(line(m)) length-asline(length(asline)))
      if { {length-asline < max-unit-character-length} and
           {{length-asline + posdent(indent-already indent)} < maxwidth } and
           {general-length(m) < max-unit-list-length} }
        ; Yes, we can represent it as one list of space-separated parameters:
        append getdent(indent-already indent) asline '(#\newline)
        ; No, Can't put entire expression on one line; try alternatives.
        if pair?(car(m))  ; Is car a pair?  If so, we may need GROUP.
          let* (asunit-car(unit(car(m)))) ; Get representation of car.
            if {{length(asunit-car) + posdent(indent-already indent)} < maxwidth }
              ; Don't need to use GROUP, we can squeeze the car in.
              append getdent(indent-already indent) asunit-car '(#\newline)
                iformat-body cdr(m) deeper(indent) #f
              ; Use GROUP, we can't squeeze the car in.
              append getdent(indent-already indent)
                string->list group-string-newline
                iformat-top  car(m) deeper(indent) #f
                iformat-body cdr(m) deeper(indent) #f
          ; The car isn't a pair. Try to cuddle, else use normal indent style
          cond
            long-and-boring?(m)
              ; A long-and-boring list is almost certainly data, not
              ; a function call or code sequence.  Format it differently.
              append
                getdent(indent-already indent)
                string->list(group-string-newline)
                deeper(indent)
                iformat-boring-list m #t posdent(indent-already indent) deeper(indent)
            {memq(car(m) cuddle-first-parameter) and {length(m) >= 3}}
              let* (asline-cuddled(line(list(car(m) cadr(m)))))
                 if { {length(asline-cuddled) + posdent(indent-already indent)} < maxwidth}
                    ; We can cuddle up on line with one parameter:
                    append getdent(indent-already indent)
                      asline-cuddled \\ '(#\newline)
                      iformat-body cddr(m) deeper(indent) #f
                    ; Can't cuddle - use normal format.
                    iformat-top-normal-indent m getdent(indent-already indent) #f
            #t
              iformat-top-normal-indent m indent indent-already

; Display x (a list of chars and strings), but do NOT display
; the last end-of-line.  Because we only take generated files,
; the end-of-line is exactly \#newline and nothing else.
define display-skip-last-eol(x)
  cond
    null?(x)
      #t
    string?(car(x))
      display(car(x))
      display-skip-last-eol(cdr(x))
    {char?(car(x)) and null?(cdr(x)) and (eq? car(x) #\newline)}
      #t
    char?(car(x))
      write-char(car(x))
      display-skip-last-eol(cdr(x))
    #t
      display("BUG!!! in display-skip-last-eof!")

; Display formatted expression "m" using indentation string "indent".
; Do NOT display the final end-of-line, due to an interesting subtlety:
; read() doesn't consume the end-of-line, so if we are translating
; what read() has read in, then we need to NOT generate the last end-of-line
; so that they will match up.
define iformat(m)
  display-skip-last-eol iformat-top(m string->list("") #f)



; Consume an end-of-line. This is 2 unequal end-of-line characters,
; or a single end-of-line character, whichever is longer.
define consume-end-of-line()
  let ( c(peek-char()) )
    if memq(c end-of-line-chars)
      begin
        read-char()
        let ( next(peek-char()) )
          if {not(eq?(c next)) and memq(next end-of-line-chars)}
            begin
              read-char()

; Copy one line from stdin to stdout, end on EOF or end-of-line.
; Consume the end of line.
define (copy-line port)
  let ((c peek-char(port)))
    cond
      eof-object?(c)   c
      memq(c end-of-line-chars)
        consume-end-of-line()
        newline()
      #t write-char(read-char(port)) copy-line(port)


; filter stdin to stdout, reading in traditional s-expressions and outputting
; sweet-expressions.  Preserve the comments outside an s-expression.
define (iformat-filter)
  let ((c peek-char(current-input-port())))
    cond
      eof-object?(c)      c
      memq(c end-of-line-chars)
        consume-end-of-line()
        newline()
        iformat-filter()
      char=?(c #\;)
        copy-line current-input-port()
        iformat-filter()
      #t
        ; Do not copy space or tab directly to output; instead,
        ; use read() to skip past them.  Initial indents (from space/tab)
        ; disable sweet-expression processing, which is not what we want.
        let ((result read(current-input-port())))
          if eof-object?(result)
            result
            begin iformat(result) iformat-filter()

; You can use guile to trace, but the reader doesn't support #' ... yet.
; Thus, the .sscm file cannot currently include guile trap invocations.
; So to install traps, generate the .scm file directly with:
;    make sweeten.scm
; Add the traps by patching the sweeten.scm file (not the .sscm file), e.g.: 
;   (install-trap
;     (make <procedure-trap>
;           #:procedure iformat-filter
;           #:behaviour (list trace-trap trace-until-exit)))
; And run:
;    guile sweeten.scm


iformat-filter()

