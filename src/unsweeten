#!/bin/sh
if test "$#" = "0"; then
  exec /usr/bin/env GUILE_LOAD_PATH="@LIBRARY_DIRECTORY@" @GUILE@ -q -s "$0"
else
  cat "$@" | /usr/bin/env GUILE_LOAD_PATH="@LIBRARY_DIRECTORY@" @GUILE@ -q -s "$0"
  exit $?
fi

# @WARNING_MESSAGE@

!#

; This is a filter - it accepts sweet-expressions from standard input,
; and prints their S-expression translation as output.
; It preserves comments that are outside any sweet-expression, if they begin
; with ";" on the left edge.

; It pretty-prints - this takes extra time, but it makes the results
; much easier to understand, and even if you don't look at it all the time,
; it's very helpful when you DO choose to examine it.


(define use-pretty-print #t)

; Load pretty-printer
(if use-pretty-print
  (use-modules (ice-9 pretty-print)))

; Load sweet.
(cond-expand
  (guile-2
    (eval-when (compile load eval)
      (set! %load-path (append %load-path '(".")))))
  (guile
    (set! %load-path (append %load-path '(".")))))
(use-modules (readable kernel))


(define linefeed (integer->char #x000A))

; True if we are at column one (the beginning of a line), else false:
(define column1 #t)

(define (copy-line port)
  ; Copy line from in to out - end on EOF or newline (but don't output it)
  (let ((c (peek-char port)))
    (cond
      ((eof-object? c) c)
      ((not (or (char=? c #\newline) (char=? c linefeed)))
        (set! column1 #f)
        (write-char (read-char port))
        (copy-line port)))))

; Sweet-filter - Convert, preserve comments outside a datum, and
; specially handle beginning-of-line special formats ";#", ";!", and ";_"
; Change "pretty-print" to "write" if speed is critical.
(define (sweet-filter port)
  (let ((c (peek-char port)))
    (cond
      ((eof-object? c) c)
      ((or (char=? c #\newline ) (char=? c linefeed))
        (set! column1 #t)
        (write-char (read-char port))
        (force-output) ; guile, flush output so interactive use okay.
        (sweet-filter port))
      ((char=? c #\; )
        (read-char port) ; Consume semicolon.
        (let ((c2 (peek-char port)))
          (cond
            ; Pass ;# and ;! but WITHOUT the leading semicolon:
            ((and column1 (or (eq? c2 #\#) (eq? c2 #\!)))
              (copy-line port) (sweet-filter port))
            ; Pass ;_ WITHOUT EITHER leading character:
            ((and column1 (eq? c2 #\_))
              (read-char port) (copy-line port) (sweet-filter port))
            (#t
                (set! column1 #f)
                (write-char c)
                (copy-line port)
                (sweet-filter port)))))
      (#t
        (let ((result (sweet-read port)))
          (if (eof-object? result)
            result
            (begin
              (if use-pretty-print
                (pretty-print result)
                (write result))
              (sweet-filter port))))))))


; Older, simpler version:
; (define (sweet-filter port)
;   (let ((result (sweet-read (current-input-port))))
;     (if (eof-object? result)
;       result
;       (begin (write result) (newline) (sweet-filter port)))))


(sweet-filter (current-input-port))

