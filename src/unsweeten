#!/bin/sh
exec /usr/bin/env GUILE_LOAD_PATH="@LIBRARY_DIRECTORY@" @GUILE@ -q -s "$0"

# @WARNING_MESSAGE@

!#

; This is a filter - it accepts sweet-expressions from standard input,
; and prints their S-expression translation as output.
; It preserves comments that are outside any sweet-expression, if they begin
; with ";" on the left edge.

; It pretty-prints - this takes extra time, but it makes the results
; much easier to understand, and even if you don't look at it all the time,
; it's very helpful when you DO choose to examine it.


; Load pretty-printer
(use-modules (ice-9 pretty-print))

; Load sweet.
(cond-expand
  (guile-2
    (eval-when (compile load eval)
      (set! %load-path (append %load-path '(".")))))
  (guile
    (set! %load-path (append %load-path '(".")))))
(use-modules (readable kernel))

(define linefeed (integer->char #x000A))

; True if we are at column one (the beginning of a line), else false:
(define column1 #t)

(define (copy-line port)
  ; Copy line from in to out - end on EOF or newline.
  (let ((c (peek-char port)))
    (cond
      ((eof-object? c) c)
      ((or (char=? c #\newline) (char=? c linefeed))
        (set! column1 #t)
        (write-char (read-char port)))
      (#t
        (set! column1 #f)
        (write-char (read-char port))
        (copy-line port)))))

; Sweet-filter - written this way to preserve "external" comments
; Change "pretty-print" to "write" if speed is critical:
(define (sweet-filter)
  (let ((c (peek-char)))
    (cond
      ((eof-object? c) c)
      ((or (char=? c #\newline ) (char=? c linefeed))
        (set! column1 #t) (write-char (read-char)) (sweet-filter))
      ((char=? c #\; )
        (read-char) ; Consume semicolon.
        (let ((c2 (peek-char)))
          (cond
            ; Pass ;# and ;! but WITHOUT the leading semicolon:
            ((and column1 (or (eq? c2 #\#) (eq? c2 #\!)))
              (copy-line (current-input-port)) (sweet-filter))
            ; Pass ;_ WITHOUT EITHER leading character:
            ((and column1 (eq? c2 #\_))
              (read-char) (copy-line (current-input-port)) (sweet-filter))
            (#t
                (set! column1 #f)
                (write-char c)
                (copy-line (current-input-port))
                (sweet-filter)))))
      (#t
        (let ((result (sweet-read (current-input-port))))
          (if (eof-object? result)
            result
            (begin (pretty-print result) (sweet-filter))))))))


; Older, simpler version:
; (define (sweet-filter)
;   (let ((result (sweet-read (current-input-port))))
;     (if (eof-object? result)
;       result
;       (begin (write result) (newline) (sweet-filter)))))


(sweet-filter)

