;_#!/bin/sh
;_if test "$#" = "0"; then
;_  exec /usr/bin/env GUILE_LOAD_PATH="@LIBRARY_DIRECTORY@" @GUILE@ --debug -q -s "$0"
;_else
;_  cat "$@" | /usr/bin/env GUILE_LOAD_PATH="@LIBRARY_DIRECTORY@" @GUILE@ --debug -q -s "$0"
;_  exit $?
;_fi
;_
;_# @WARNING_MESSAGE@
;_
;_!#
; sweeten.sscm
; Filter to read S-expressions and output indented sweet-expressions.
;
; Copyright (C) 2006-2012 David A. Wheeler.
;
; This software is released as open source software under the "MIT" license:
;
; Permission is hereby granted, free of charge, to any person obtaining a
; copy of this software and associated documentation files (the "Software"),
; to deal in the Software without restriction, including without limitation
; the rights to use, copy, modify, merge, publish, distribute, sublicense,
; and/or sell copies of the Software, and to permit persons to whom the
; Software is furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
; THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.

; This reformats standard input from s-expressions into sweet-expressions.
; Internally, many functions develop possible representations as a list
; of characters; various alternatives are tried out and the "best" is used.
; For example, a "boring" list (with only non-pairs and a length of at
; least boring-length) is probably data and is represented differently.
;
; Key functions include:
; sweeten-top(): Returns a list-of-characters representation of an
;   expression; it may generate multiple lines with indentation.
; line(): Return a list-of-characters representation of *one* line
;   of space-separated neoteric-expression units.
;   Indentation must be active at the start of the line.
; unit(): Return a list-of-characters representation of some unit.
;   Indentation processing *may* be active, but the character sequence
;   returned must not depend on that; it returns a list without newline.

; Set to #t if you want to run while invoking the sweet module directly.
; We need to explicitly *disable* the sweet-reader if it's active so that we
; get the "old" reader format on read; this is important for handling
; badly-formatted old files.   In the standard build this is unnecessary.
;
; For debugging, add "--debug" after the two @ GUILE @ statements at the
; beginning of the file; this will enable very useful backtraces.

define build-on-sweet #f
if build-on-sweet
  use-modules
    readable kernel

; These are settings that control the "look" of the formatted result.
; In the future these might be controlled via option flags.

; Note: The maxwidth may be violated if, at a current indent, there is a
; long non-pair that exceeds it.  But other than long atoms, it's respected,
; so it's unlikely to exceed this width in practice:
define maxwidth 78
define indent-increment '(#\space #\space)
define marked-indent-increment '(#\! #\space)
define min-indent-marking {length(indent-increment) * 3}
define max-unit-character-length 60  ; Max character length of single unit.
define max-unit-list-length 8        ; Max list length of single unit.
define max-uncomplicated-meta-length 9 ; "Complicated" if more than this.
define boring-length 16              ; Lists >= this length may be boring.

define special-infix-operators
  ' and or xor

; Defining operators may define something as multiple items in a list
; (e.g., with an implied begin/prog), but if that happens, don't put
; them all on one line.
define defining-operators '(define lambda
  define-module                  ; Guile modules
  library export import          ; R6RS library modules
  let-syntax letcrec-syntax define-syntax syntax-rules
  letrec let let* let1
  defun block)                   ; Common Lisp

; Lists with these symbols as first parameter, and aren't shown as 1 line,
; are be shown as a line with SYMBOL FIRST-PARAMETER, followed by
; child lines (where we can manage it).
; This format is used when in typical uses the first parameter is *special*
; and has a different semantic meaning from later parameters.
; This refinement isn't *necessary* but I think it looks better.
define cuddle-first-parameter
  append
    defining-operators
    '(if when unless case
      typecase           ; Common Lisp
      set! setq do)

; Control what symbol is used for grouping.  This isn't likely to change
; now, but it was a subject of long mailing list discussion.
define group-string "\\\\"
define group-list string->list(group-string)
define group-string-newline string-append(group-string "\n")

; Other special characters and lists of characters.
define tab             integer->char(#x09)
define carriage-return integer->char(#x0d)
define LISTLP          list( #\( )
define LISTRP          list( #\) )
define LISTLBRACE      list((integer->char 123))
define LISTRBRACE      list((integer->char 125))
define LISTSP.SP       list( #\space #\. #\space )
; This list of punctuation characters is the list of punctuation characters
; in the POSIX/C locale as defined in the POSIX.1 2008 specification
; XBD section 7.3.1.1, in the same order as given for "punct".
; Thus, this is the set of characters for which C ispunct() is true in the
; POSIX or C locale.
define punct-chars     list( #\! #\" #\# #\$ #\% #\& #\'
                             #\( #\) #\* #\+ #\, #\- #\. #\/
                             #\: #\; #\< #\= #\> #\? #\@
                             #\[ #\\ #\] #\^ #\_ #\` #\{
                             #\| #\} #\~ )
                             


; This program automatically handles various end-of-line situations.
; An end-of-line is a sequence of two different end-of-line chars,
; otherwise, it is a single end-of-line char.
; Thus we handle \n, \r\n, \n\r, \r, and variations of <next line> too.
; To do this, we need a list of end-of-line characters:
define end-of-line-chars
  list 
    integer->char(#x0a)     ; <linefeed>, aka \n
    integer->char(#x0d)     ; <carriage return>, aka \r
    integer->char(#x85)     ; <next line>
    ; If wide chars are supported, add this:
    ; integer->char(#x2028)   ; <line separator>

; Does x contain a list of ONLY punctuation characters?
; An empty list is considered true.
define contains-only-punctuation?(x)
  cond
    null?(x)                 #t
    not(pair?(x))            #f ; Check this before evaluating car(x)!
    memq(car(x) punct-chars) contains-only-punctuation?(cdr(x))
    #t                       #f

; Returns #t if x is a symbol that would typically be used in infix position.
define is-infix-operator?(x)
  cond
    not(symbol?(x)) #f
    memq(x special-infix-operators) #t
    #t contains-only-punctuation?(string->list(symbol->string(x)))

; Given an indent, return the next deeper indent.
define deeper(indent)
  append indent indent-increment

; Return #t if indent's last indent was unmarked.
; Presumes indent is long enough to be marked.
define last-indent-unmarked(indent)
  not $ equal?
    list-tail indent {length(indent) - length(marked-indent-increment)}
    marked-indent-increment

; Given an indent, return the next deeper indent, marked if appropriate.
; "If appropriate" means it's already somewhat deep to start with,
; and thus it'd be helpful to have the markings for the eye to follow.
; Don't mark if the previous indent already marked its indent.
define mark-deeper(indent)
  if {{length(indent) > min-indent-marking} and last-indent-unmarked(indent)}
    append indent marked-indent-increment
    append indent indent-increment

; An x is boring if it's not a list, or it's a list with ONLY non-pair members.
define boring?(x)
  cond
    not(pair?(x))  #t  ; This includes (), which is boring & the end.
    pair?(car(x))  #f
    #t             boring?(cdr(x))

; A list is long and boring if it's a list, its length is at least
; the boring-length, and it's boring.
; A long-and-boring list is almost certainly NOT a function call or a
; body of some executable sequence - it's almost certainly a long
; boring list of data instead. If it is, we want to display it differently.
define long-and-boring?(x)
  cond
    not(pair?(x))                 #f
    not(list?(x))                 #f
    {length(x) < boring-length}   #f
    #t                            boring?(x)

; Support general-length-inner - help count length of possibly-improper list.
define general-length-inner(x count-so-far)
  cond
    null?(x)      count-so-far
    not(pair?(x)) {count-so-far + 1}
    #t
                  general-length-inner cdr(x) {count-so-far + 1}

; Return length of x, which may be an improper list.
; If improper, count the two sides as two, so "(a . b)" is length 2.
define general-length(x)
  general-length-inner x 0

; The "meta-length" is an estimate of how complicated an expression is.
; Every list element counts as 1, and every new list also adds one
; (because we count () as 1) recursively.
define meta-length(x)
  cond
    not(pair?(x)) 1  ; Includes ().
    #t            {meta-length(car(x)) + meta-length(cdr(x))}

; Return true if m is "complicated" (and thus should split lines).
; All Common Lisp "defuns" are considered complicated.
define complicated?(x)
  cond
    eq?(car(x) 'defun) #t
    memq(car(x) cuddle-first-parameter)
      if pair?(cdr(x))
        {meta-length(cddr(x)) > max-uncomplicated-meta-length}
        #f
    #t #f

; Return #t if x should be represented using curly-infix notation {...}.
define represent-as-infix?(x)
  and
    pair? x
    is-infix-operator? car(x)
    list? x           ; No improper lists!
    {length(x) <= 6}

define represent-as-inline-infix?(x)
  {represent-as-infix?(x) and {length(x) >= 3}}

; Return #t if x should be represented as a brace suffix
define represent-as-brace-suffix?(x)
  {represent-as-infix?(x) and {length(x) >= 2}}

; Define an association list mapping the Lisp function names which have
; abbreviations ==> the list of characters in their abbreviation
define abbreviations
  ' \\
    quote (#\')
    quasiquote (#\`)
    unquote (#\,)
    unquote-splicing (#\, #\@)

; return #t if we should as a traditional abbreviation, e.g., '
define represent-as-abbreviation?(x)
  and
    pair? x
    assq car(x) abbreviations
    pair? cdr(x)
    null? cddr(x)

; Return list x's *contents* represented as a list of characters.
; Each one must use neoteric-expressions, space-separated;
; it will be surrounded by (...) so no indentation processing is relevant.
define unit-list(x)
  cond
    null?(x) '()
    pair?(x)
      if null?(cdr(x))
        unit car(x)
        append unit(car(x)) '(#\space) unit-list(cdr(x))
    #t  append(LISTSP.SP unit(x))

; Return tail of an infix expression, as list of chars
; The "op" is the infix operator represented as a list of chars.
define infix-tail(op x)
  cond
    null?(x)
      LISTRBRACE
    pair?(x)
      append '(#\space) op '(#\space) unit(car(x)) infix-tail(op cdr(x))
    ; The following is used if we get an improper list.  This can't
    ; happen if only proper lists are represented using curly-infix:
    #t
      append LISTSP.SP unit(x) LISTRBRACE

; Return "x" as a list of characters, surrounded by {...}, for use as f{...}.
define as-brace-suffix(x)
  if {general-length(x) < 3}
    append LISTLBRACE unit-list(x) LISTRBRACE
    append LISTLBRACE unit(cadr(x)) infix-tail(unit(car(x)) cddr(x))

; Given list of characters, return the characters that would REPRESENT
; those characters inside a string AFTER the initial double-quote,
; then return the double-quote.  This translates newline to \n, etc.
; We'll translate carriage-return to \r and tab to \t; these aren't in
; R5RS, but failing to translate them can cause other trouble, and they
; *are* in R6RS.
define unit-string-tail(x)
  if null?(x)
    '(#\")  ; Return the string's closing double-quote.
    append
      let ((c car(x)))
        cond             ; Can't use "case" because of "tab" variable.
          eq?(c #\\)              '(#\\ #\\)
          eq?(c #\")              '(#\\ #\")
          eq?(c #\newline)        '(#\\ #\n)
          eq?(c carriage-return)  '(#\r #\n) ; Not in R5RS
          eq?(c tab)              '(#\\ #\t) ; Not in R5RS
          #t                      list(car(x))
      unit-string-tail cdr(x)

; Return x represented as a neoteric-expression unit,
; as a list of characters that are part of one line.
; Indentation processing *may* be active, but the character sequence
; returned must not depend on that.
; This is widely-used. If speed's a problem, memoize this;
; you can erase the memoized information once display-sweeten-format() has
; displayed the result.
define unit(x)
  cond
    null?(x)     string->list("()")
    number?(x)   string->list(number->string(x))
    boolean?(x)  if(x '(#\# #\t) '(#\# #\f))
    symbol?(x)   string->list(symbol->string(x))
    string?(x)   append('(#\") unit-string-tail(string->list(x)))
    pair?(x)
     cond
       represent-as-abbreviation?(x)
         append cadr(assq(car(x) abbreviations)) unit(cadr(x))
       long-and-boring?(x)
         append LISTLP unit-list(x) LISTRP
       symbol?(car(x))
         cond
           represent-as-inline-infix?(x)
             ; Special case, use {...}:
             append LISTLBRACE unit(cadr(x)) infix-tail(unit(car(x)) cddr(x))
           {pair?(cdr(x)) and null?(cddr(x)) and pair?(cadr(x)) and
             represent-as-brace-suffix?(cadr(x))}
             ; Special case, use f{...}:
             append unit(car(x)) as-brace-suffix(cadr(x))
           #t
             ; Normal case, use f(...):
             append unit(car(x)) LISTLP unit-list(cdr(x)) LISTRP
       #t
         append LISTLP unit-list(x) LISTRP
    #t  string->list(object->string(x))
    ; R5RS doesn't include "object->string", but it's painful to do without.
    ; You might be able to use these in a pinch:
    ; char?(x)     append '(#\# #\\) x ; Doesn't handle special chars

; Return x as a unit, but always represent lists as (a b c):
define unit-force-list(x)
  if pair?(x)
    append LISTLP unit-list(x) LISTRP
    unit(x)

; Return x, the rest of the list, as a list of characters. See line().
define line-tail(x)
  cond
    null?(x)  '()
    pair?(x)
      append '(#\space) unit(car(x)) line-tail(cdr(x))
    #t
      append LISTSP.SP unit(x)

; Return x represented as a line of space-separated neoteric-expression units,
; as a list of characters.
; Indentation processing *MUST* be active.
define line(x)
  cond
    not(pair?(x))                  unit(x)
    represent-as-inline-infix?(x)  unit(x)
    represent-as-abbreviation?(x)
      if {not(pair?(cadr(x))) or null?(cdr(cadr(x)))}
        unit(x) ; Just show '(x) if x isn't a multi-item list.
        append cadr(assq(car(x) abbreviations)) '(#\space) line(cadr(x))
    {pair?(x) and null?(cdr(x))} ; Handle 1-datum case specially.
      if symbol?(car(x))
        append unit(car(x)) LISTLP LISTRP
        append LISTLP unit(car(x)) LISTRP
    #t
      append unit(car(x)) line-tail(cdr(x))


; Return list "m" as a list of characters representing
; a long and boring split list.  We'll keep track of position inside
; this routine, since we can do that easily here.
define sweeten-boring-list(x first? pos next-indent)
  cond
    null?(x) '(#\newline)
    first?
      ; if first, force its disply, even if that goes beyond width max.
      let
        $ item unit(car(x))
        append item 
          sweeten-boring-list(cdr(x) #f {pos + length(item)} next-indent)
    #t ; Not first.
      let
        $ item unit(car(x))
        let
          $ item-sameline append('(#\space) group-list '(#\space) item)
          if {{pos + length(item-sameline)} < maxwidth}
            append item-sameline
              sweeten-boring-list cdr(x) #f
                {pos + length(item-sameline)} \\ next-indent
            begin
              append '(#\newline) next-indent
                sweeten-boring-list x #t length(next-indent) next-indent


; Return the string to add as indentation; should be empty if indentation
; has already occurred.
define getdent(indent-already indent)
  if indent-already
    string->list("")
    indent

; What's the number of characters consumed in the indent (and thus
; the column position starting from 0)?
define posdent(indent-already indent)
  if indent-already
    length(indent-already)
    length(indent)

; Return #t if a sequence of characters (length newlen) will fit within
; maxlen, given indent-already and indent.  Else returns #f.
define fits-width?(indent-already indent newlen)
  {{posdent(indent-already indent) + newlen} < maxwidth}

; Input: expression "m" with indentation string "indent".
; Output: List of characters representing it (#\newline for new line).
; This tail handles the body of a list (after its first entry) when
; indentation processing is active, each of these is its own initial line.
define sweeten-body(m indent indent-already)
  if null?(m)
    '()
    append
      sweeten-top  car(m) indent indent-already
      sweeten-body cdr(m) indent #f

; Return list m represented in the typical indent style.
define sweeten-top-normal-indent(x indent indent-already)
  if represent-as-abbreviation?(x)
    ; Use QUOTE+SPACE, etc.  This is handled specially! We will
    ; create a new indent-already value, so that we can insert the indent and
    ; the other characters.  This way, we can insert the right amount
    ; of space (one) after the abbreviation, and let the other functions
    ; know that the indentation has been performed.
    let*
      \\
        prefix  append(cadr(assq(car(x) abbreviations)) '(#\space))
        newdent append(getdent(indent-already indent) prefix)
      append newdent
        sweeten-top cadr(x) indent newdent
    ; Normal case, we don't have a traditional abbreviation we want to use.
    append
      sweeten-top  car(x) indent indent-already
      sweeten-body cdr(x) deeper(indent) #f

; Return a list of characters representing m,
; using multiple lines to represent m.
; There several possible formats; we'll examine various options
; to determine the most pleasing format.
define sweeten-top-multiline(m indent indent-already)
  if pair?(car(m))  ; Is car a pair?  If so, we may need GROUP.
    let* (asunit-car(unit(car(m)))) ; Get representation of car.
    ! if fits-width?(indent-already indent length(asunit-car))
    !   ; We can squeeze the car into the line - don't use GROUP.
    !   append getdent(indent-already indent) asunit-car '(#\newline)
    !     sweeten-body cdr(m) deeper(indent) #f
    !   ; We *cannot* squeeze the car into the line - use GROUP
    !   append getdent(indent-already indent)
    !     string->list group-string-newline
    !     sweeten-top  car(m) deeper(indent) #f
    !     sweeten-body cdr(m) deeper(indent) #f
    ; The car isn't a pair. Try alternatives, else normal format.
    cond
    ! long-and-boring?(m)
    ! ! ; A long-and-boring list is almost certainly data, not
    ! ! ; a function call or code sequence.  Format it specially.
    ! ! append
    ! !   getdent(indent-already indent)
    ! !   string->list(group-string-newline)
    ! !   deeper(indent)
    ! !   sweeten-boring-list m #t posdent(indent-already indent)
    ! !                       deeper(indent)
    ! {eq?(car(m) 'defun) and {general-length(m) > 3}}
    ! ! ; Handle Common Lisp "defun" specially.
    ! ! let*
    ! !    $ asline-cuddled
    ! !      append
    ! !        line list(car(m) cadr(m))  ; "defun" name-of-function
    ! !        '(#\space)                 ; space between name and parameters
    ! !        unit-force-list caddr(m)   ; list of parameters.
    ! !    if fits-width?(indent-already indent length(asline-cuddled))
    ! !      ; We can cuddle up on line with name and list of parameters:
    ! !      append getdent(indent-already indent)
    ! !        asline-cuddled \\ '(#\newline)
    ! !        sweeten-body cdddr(m) mark-deeper(indent) #f
    ! !      ; Can't cuddle "defun funcname (params)" - use normal format.
    ! !      sweeten-top-normal-indent m
    ! !        getdent(indent-already indent) \\ #f
    ! memq(car(m) cuddle-first-parameter)
    ! ! ; the car is a symbol that we'd like to cuddle. Try to do so.
    ! ! let* (asline-cuddled(line(list(car(m) cadr(m)))))
    ! !    if fits-width?(indent-already indent length(asline-cuddled))
    ! !       ; We can cuddle up on line with one parameter:
    ! !       append getdent(indent-already indent)
    ! !         asline-cuddled \\ '(#\newline)
    ! !         sweeten-body cddr(m) mark-deeper(indent) #f
    ! !       ; Can't cuddle with one parameter - use normal format.
    ! !       sweeten-top-normal-indent m
    ! !         getdent(indent-already indent) \\ #f
    ! ; Nothing special.  Use normal multi-line format:
    ! #t
    ! ! sweeten-top-normal-indent m indent indent-already

; Input: expression "m" with indentation string "indent".
;        indent-already is #f if no indentation has already taken place;
;        if indentation *has* taken place, it contains the string of
;        indentation and any following characters that's occurred
;        (so char position, etc., can be determined).
; Output: List of characters representing it (#\newline for new line).
; At this point, we're at the beginning of a possibly-indented
; line with sweet-expression (indentation) processing active.
define sweeten-top(m indent indent-already)
  if not(pair?(m)) ; if not a pair, just print it. () handled here
    append(getdent(indent-already indent) unit(m) '(#\newline))
    ; We have a pair. Can we represent it as one line of space-sep params?
    let* (asline(line(m)) length-asline(length(asline)))
      if { {length-asline < max-unit-character-length} and
           fits-width?(indent-already indent length-asline) and
           {not complicated?(m)} and
           {general-length(m) < max-unit-list-length} }
        ; Yes, we can represent it as one list of space-separated parameters:
        append getdent(indent-already indent) asline '(#\newline)
        ; No, can't put entire expression on one line. Use a multiline format.
        sweeten-top-multiline(m indent indent-already)

; True if at beginning of column (line), otherwise false.
; This value is only used when we're looking for a datum to read() in.
define column1 #t


; Display x (a list of chars and strings), but do NOT display
; the last end-of-line.  Because we only take generated files,
; the end-of-line is exactly \#newline and nothing else.
define display-skip-last-eol(x)
  cond
    null?(x)
      #t
    string?(car(x))
      display(car(x))
      ; In this program, strings only happen from indents:
      set! column1 #f
      display-skip-last-eol(cdr(x))
    {char?(car(x)) and null?(cdr(x)) and {car(x) eq? #\newline}}
      #t
    char?(car(x))
      write-char(car(x))
      set! column1 #f
      display-skip-last-eol(cdr(x))
    #t
      display("BUG!!! in display-skip-last-eof!")

; Display formatted expression "x" using indentation string "indent".
; Do NOT display the final end-of-line, due to an interesting subtlety:
; read() doesn't consume the end-of-line, so if we are translating
; what read() has read in, then we need to NOT generate the last end-of-line
; so that they will match up.
define display-sweeten-format(x)
  ; Force newline if aren't already in column1.  Otherwise, expressions like:
  ; (a)(b)  will be incorrectly output as a()b() instead of a()\nb().
  if not(column1)
    begin newline() set!(column1 #t)
  display-skip-last-eol sweeten-top(x string->list("") #f)



; Consume an end-of-line. This is 2 unequal end-of-line characters,
; or a single end-of-line character, whichever is longer.
define consume-end-of-line()
  let ( c(peek-char()) )
    if memq(c end-of-line-chars)
      begin
        read-char()
        let
          $ next peek-char()
          if {not{c eq? next} and memq(next end-of-line-chars)}
            begin
              read-char()

; Copy one line from stdin to stdout, end on EOF or end-of-line.
; Consume the end of line.
define copy-line(port)
  let
    $ c peek-char(port)
    cond
      eof-object?(c)   c
      memq(c end-of-line-chars)
        consume-end-of-line()
        newline()
        set! column1 #t
      #t write-char(read-char(port)) set!(column1 #f) copy-line(port)


; filter stdin to stdout, reading in traditional s-expressions and outputting
; sweet-expressions.  Preserve the comments outside an s-expression.
define sweeten-filter()
  if build-on-sweet
    restore-traditional-read()
  let
    $ c peek-char(current-input-port())
    cond
      eof-object?(c)
        c
      memq(c end-of-line-chars)
        consume-end-of-line()
        newline()
        set! column1 #t
        sweeten-filter()
      {c char=? #\;}
        copy-line current-input-port()
        sweeten-filter()
      {{c char=? #\space} or {c char=? tab}}
        ; Do not copy space or tab directly to output; instead,
        ; skip past them.  Initial indents (from space/tab)
        ; disable sweet-expression processing, which is not what we want.
        read-char()
        sweeten-filter()
      #t
        let ((datum read(current-input-port())))
          if eof-object?(datum)
            datum
            ; We have a datum to format and display - begin the real work:
            begin display-sweeten-format(datum) sweeten-filter()

; You can use guile to trace, but the reader doesn't support the guile
; extension #' yet.
; Thus, the .sscm file cannot currently include guile trap invocations.
; So to install traps, generate the .scm file directly with:
;    make sweeten.scm
; Now patch the generated sweetenv.scm (not the .sscm file) directly.
; Change:
;  (define build-on-sweet #t)
; to:
;  (define build-on-sweet #f)
;  (use-modules (ice-9 debugging traps) (ice-9 debugging trace))
; 
; Then add the traps you want near the bottom, e.g.:
;   (install-trap
;     (make <procedure-trap>
;           #:procedure sweeten-filter
;           #:behaviour (list trace-trap trace-until-exit)))
; And run:
;    guile sweeten.scm


sweeten-filter()

