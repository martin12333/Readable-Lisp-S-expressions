
   x

testing123

(hi)

[hi ]

{3 + 4 }

; This is a comment.
   ; Here's another comment.
; Another comment.
q

a ; inline comment.
b

'x ; quoted


`(x)

(f x)

f(x)

f(a b)

f()

{3 + {4 * 5 } }


`(,(x))

`(,@(x))


{3 + {4 * 5}}

f[a]

f{2 + 3}

f(a)(b)

{2 + 3}

'{2 + 3}

f(a b c)

  f(a
    b c)

 fibup(n 2 1 0)

 [if fibup(n 2 1 0)]

 ; Check to make sure #-processing is delimited by closing curly brace,
 ; in a variety of circumstances.

 {c char=? #\space}

 {#f and #t}

 {c char=?-ci #\[}

 {i = #xa}

 .2

 [a ... b]

 +(5 6)

 {-8 - +9}

;!!   (reader-test
;!!     '(defun fibup (max count n-1 n-2)
;!!      (if (= max count) (+ n-1 n-2) (fibup max (+ count 1) (+ n-1 n-2) n-1))))
;!!   
;!!   [defun fibup (max count n-1 n-2)
;!!     [if {max = count}
;!!       {n-1 + n-2}
;!!       [fibup max {count + 1} {n-1 + n-2} n-1]]]
;!!   
;!!   ; Calling "read-preserving-whitespace" with the modern-read table set
;!!   ; won't work; when you read this in:
;!!   ; [defun fibup (max count n-1 n-2)
;!!   ;   [if {max = count}
;!!   ;     {n-1 + n-2}
;!!   ;     [fibup max {count + 1} {n-1 + n-2} n-1]]]
;!!   ;
;!!   ; the calls to read-preserving-space STILL consume the space after
;!!   ; defun, fibup, etc., resulting in wrong interpretation.
;!!   
;!!   (princ "Problem coming up!")
;!!   
;!!   ; The backquote character will be caught by the sh shell, so
;!!   ; shell-escape it.  The backslash won't go to the Lisp interpreter.
;!!   (reader-test (quote \`x))
;!!    \`x
;!!   
;!!   ; PROBLEM: comma-lifting not working.
;!!   ; Need to re-implement backquote, comma, splicing :-(.
;!!   (reader-test (quote ((system::unquote x))))
;!!   \`[,x]
;!!   
;!!   ; Misc. notes - not used:
;!!   ; (assert (equal '{2 + 3} '(+ 2 3)))
;!!   ; 
;!!   ; (assert (equal '{2 * n} '(* 2 n)))
;!!   ; (assert (equal '{x eq y} '(eq x y)))
;!!   ; (assert (equal '{2 + 3 + 4} '(+ 2 3 4)))
;!!   ; (assert (equal '{2 + 3 * 4} '(NFX 2 + 3 * 4)))
;!!   ; (assert (equal '{(- x) / 2} '(/ (- x) 2)))
;!!   ; (assert (equal '{x = 3 * 4} '(nfx x = 3 * 4)))
;!!   ; (assert (equal '{x = 3} '(= x 3)))
;!!   
;!!   ; (assert (equal '{2 + {3 * 4}} '(+ 2 (* 3 4))))
;!!   ; (read)
;!!   ; '{2 + {3 * 4}}
;!!   ;(defun f1 (x)
;!!   ;  (princ "I'm f1"))
;!!   ;(defun f2 (x)
;!!   ;  (princ "I'm f2"))
;!!   ; (princ "Calling f2")
;!!   ; (f2 'call2)
;!!   ; (defun f2 (x) (funcall 'f1 x))
;!!   ; (setf (symbol-function 'f2) (function f1)
;!!   ; (princ "Calling f2, should print f1")
;!!   ; (f2 'call2)
;!!   ; (modern-read)
;!!   ; [defun fibfast (n)
;!!   ;   [if {n < 2}
;!!   ;     n
;!!   ;     fibup(n 2 1 0)]]
;!!   ; 
;!!   ; ; Demo its use:
;!!   ; 
;!!   ; [defun fibfast (n)
;!!   ;   [if {n < 2}
;!!   ;     n
;!!   ;     [fibup n 2 1 0]]]
;!!   ; 
;!!   ; [defun fibup (max count n-1 n-2)
;!!   ;   [if {max = count}
;!!   ;     {n-1 + n-2}
;!!   ;     [fibup max {count + 1} {n-1 + n-2} n-1]]]
;!!   ; 
;!!   ; [setf x 5]
;!!   ; [setf correct {1 <= x <= 10}]
;!!   ; 
;!!   ; ; Test that demo worked correctly:
;!!   ; (assert (= (fibfast 10) 55))
;!!   ; (assert correct)
;!!   ; 
;!!   ; ; More demos:
;!!   ; 
;!!   ; [setf y {3 + {4 * 5}}]
;!!   ; [setf z {{1 <= x <= 10} and {x > 0}}]
